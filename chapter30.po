#
# NuINu <don't@send.my>, 2020.
#
#. extracted from in/chapter30.html
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-04-19 13:51+0300\n"
"PO-Revision-Date: 2020-05-18 18:13+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter30.html:5
msgid ""
"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/"
"html4/strict.dtd\">\n"
"<html><head>\n"
"<title>Successful Lisp - Chapter 30</title>\n"
"</head> "
msgstr ""

#: in/chapter30.html:8
msgid ""
"<body bgcolor=\"white\" text=\"black\">\n"
"<h1>Chapter 30 - Helpful Hints for Debugging and Bug-Proofing</h1> "
msgstr ""
"<body bgcolor=\"white\" text=\"black\">\n"
"<h1>Глава 30 - Полезные советы по отладке и проверке\n"
"ошибок</h1> "

#: in/chapter30.html:13
msgid ""
"<P>As with any programming language, error avoidance is the best\n"
"debugging strategy. Take advantage of the online documentation \n"
"(available with most systems) and test functions, or even parts\n"
"of functions, as you write them."
msgstr ""
"<P>\n"
"Как и в любом другом языке программирования, предотвращение ошибок \n"
"является лучшей стратегией отладки. Воспользуйтесь преимуществами \n"
"интерактивной документации (доступной для большинства систем) и \n"
"тестовых функций или даже частей функций, когда вы их пишете."

#: in/chapter30.html:18
msgid ""
"<p>Still, you'll inevitably face the unexpected error, and you\n"
"should know how to use the debugger. More often than not, a quick\n"
"look at the error location as shown by the debugger will point out\n"
"an obvious problem. "
msgstr ""
"<p>\n"
"Тем не менее, вы неизбежно столкнетесь с неожиданной ошибкой, и вы \n"
"должны знать, как использовать отладчик. Чаще всего быстрый взгляд \n"
"на местоположение ошибки, показанное отладчиком, указывает на \n"
"очевидную проблему.\n"

#: in/chapter30.html:24
msgid ""
"<p>Some problems, though, are not obvious; your program will run\n"
"without error, but produce incorrect results. When examination of\n"
"the code does not reveal an error, you can rely upon built in Lisp\n"
"tools to expose the details of your program's operation and find the\n"
"error during execution."
msgstr ""
"<p>\n"
"Некоторые проблемы, однако, не очевидны; ваша программа будет работать \n"
"без ошибок, но даст неправильные результаты. Если проверка кода не \n"
"выявила ошибки, вы можете положиться на встроенные инструменты Lisp, \n"
"чтобы выявить детали работы вашей программы и найти ошибку во время \n"
"выполнения."

#: in/chapter30.html:26
msgid "<h2>Finding the cause of an error</h2>"
msgstr "<h2>Поиск причины ошибки</h2>"

#: in/chapter30.html:33
msgid ""
"<p>There are two ways to notice an error. The intrusion of the Lisp\n"
"debugger is the most obvious. The debugger will appear whenever your\n"
"program causes Lisp to signal an error. This is often the result of\n"
"something obvious, like trying to perform arithmetic on\n"
"<code>NIL</code> or trying to <code>FUNCALL</code> an object that is\n"
"not a function."
msgstr ""
"<p>\n"
"Есть два способа заметить ошибку. Вторжение отладчика Lisp является "
"наиболее \n"
"очевидным. Отладчик будет появляться всякий раз, когда ваша программа "
"вызывает \n"
"Lisp, чтобы сигнализировать об ошибке. Это часто является результатом чего-"
"то \n"
"очевидного, например, попытки выполнить арифметику с <code>NIL</code> или \n"
"попытки <code>FUNCALL</code> объекта, который не является функцией."

#: in/chapter30.html:40
msgid ""
"<p>Your program's failure to produce expected results is also an\n"
"error, even though the debugger never appears. In this case, your\n"
"program doesn't make any mistakes in its use of Lisp, but the\n"
"successful sequence of Lisp operations doesn't do what you had\n"
"intended.  Another possibility is that your program will fail to\n"
"terminate at all."
msgstr ""
"<p>\n"
"Неспособность вашей программы выдавать ожидаемые результаты также \n"
"является ошибкой, даже если отладчик никогда не появляется. В этом \n"
"случае ваша программа не делает никаких ошибок при использовании Lisp, \n"
"но успешная последовательность операций Lisp не делает того, что вы \n"
"намеревались. Другая возможность заключается в том, что ваша программа \n"
"вообще не завершается."

#: in/chapter30.html:46
msgid ""
"<p>The best defense against all of these problems is to write \n"
"short, clear function definitions and test each one as soon as\n"
"you've written it.  I find it helpful to write one or more test\n"
"cases and include them as comments (bracketed by #| and |#) in\n"
"the same file.  "
msgstr ""
"<p>\n"
"Лучшая защита от всех этих проблем - написать короткие, четкие \n"
"определения функций и протестировать каждое из них, как только \n"
"вы его напишете. Я считаю полезным написать один или несколько \n"
"тестовых случаев и включить их в качестве комментариев \n"
"(в скобках #| и |#) в один и тот же файл."

#: in/chapter30.html:48
msgid "<h2>Reading backtraces, compiler settings for debugging</h2>"
msgstr ""
"<h2>Чтение трассы вызовов(backtraces), настройки компилятора для\n"
"отладки</h2>"

#: in/chapter30.html:51
msgid ""
"<p>Every Lisp debugger will provide at least two important\n"
"pieces of information: an error message and a stack backtrace."
msgstr ""
"<p>\n"
"Каждый отладчик Lisp будет предоставлять по крайней мере две \n"
"важные части информации: сообщение об ошибке и \n"
"обратную трассировку стека."

#: in/chapter30.html:57
msgid ""
"<p>The error message describes <em>how</em> the program failed.\n"
"Normally, this is a description of an error encountered while \n"
"executing some built in Lisp function.  If your program calls\n"
"<em>ERROR</em>, the debugger will display the message you\n"
"specify."
msgstr ""
"<p>\n"
"Сообщение об ошибке описывает, <em>как</em> произошел сбой программы. \n"
"Обычно это описание ошибки, возникшей при выполнении какой-либо \n"
"встроенной функции Lisp. Если ваша программа вызывает <em>ERROR</em>,\n"
"отладчик отобразит указанное вами сообщение.\n"

#: in/chapter30.html:64
msgid ""
"<p>The stack backtrace describes <em>where</em> your program\n"
"failed by displaying the call stack at the point of the error.\n"
"The function which signalled the error will be at the \"top\" of\n"
"the stack.  Below that is the function that called the function\n"
"which signalled the error, and so on all the way to (and\n"
"sometimes beyond) the listener's read-eval-print loop."
msgstr ""
"<p>\n"
"Обратная трассировка стека описывает, <em>где</em> ваша программа \n"
"потерпела неудачу, отображая стек вызовов в точке ошибки. Функция, \n"
"которая сигнализировала об ошибке, будет находиться в \"верхней\" части \n"
"стека. Ниже приводится функция, которая вызвала функцию, которая "
"сигнализировала \n"
"об ошибке, и так далее вплоть до (а иногда и за ее пределами) цикла \n"
"чтения-выполнения-печати(REPL) слушателя."

#: in/chapter30.html:71
msgid ""
"<p>The debugger relies upon certain information provided by\n"
"the compiler or interpreter.  Although the details vary among\n"
"implementations, it's safe to say that compiler optimizations\n"
"that improve speed or reduce space tend to reduce the amount\n"
"of information available to the debugger.  You can change these\n"
"optimizations while debugging your program:"
msgstr ""
"<p>\n"
"Отладчик полагается на определенную информацию, предоставленную \n"
"компилятором или интерпретатором. Хотя детали реализации различаются, \n"
"можно с уверенностью сказать, что оптимизация компилятора, которая \n"
"повышает скорость или уменьшает пространство, как правило, уменьшает \n"
"объем информации, доступной отладчику. Вы можете изменить эти \n"
"оптимизации на время отладки вашей программы:"

#: in/chapter30.html:75
msgid ""
"<pre>\n"
"(declaim (optimize (speed 0) (space 0) (debug 3)))\n"
"</pre> "
msgstr ""

#: in/chapter30.html:83
msgid ""
"<p>If you execute this before compiling your program, the debugger\n"
"should be able to give you more useful information. You should\n"
"consult your vendor's documentation to learn about additional\n"
"implementation-specific controls. If your Lisp system gives you a\n"
"choice between using a compiler and using an interpreter, you'll\n"
"probably find that the interpreter causes the debugger to give you\n"
"better information."
msgstr ""
"<p>\n"
"Если вы выполните это перед компиляцией вашей программы, отладчик должен \n"
"быть в состоянии дать вам больше полезной информации. Вы должны "
"ознакомиться \n"
"с документацией вашего поставщика, чтобы узнать о дополнительных элементах \n"
"управления, специфичных для реализации. Если ваша система Lisp "
"предоставляет \n"
"вам выбор между использованием компилятора и интерпретатора, вы, вероятно, \n"
"обнаружите, что интерпретатор заставляет отладчик давать вам лучшую \n"
"информацию."

#: in/chapter30.html:85
msgid "<h2>Simple debugging tools</h2>"
msgstr "<h2>Простые инструменты отладки</h2>"

#: in/chapter30.html:91
msgid ""
"<p>If your program runs to completion but produces incorrect\n"
"results, or if it runs but fails to terminate, then you'll need some\n"
"additional tools. The first of these tools should be familiar to all\n"
"programmers: insert a call to the debugger or (more commonly) insert\n"
"a print statement."
msgstr ""
"<p>\n"
"Если ваша программа дорабатывает до завершения, но дает неверные "
"результаты, \n"
"или если она работает, но не завершается, то вам понадобятся некоторые \n"
"дополнительные инструменты. Первый из этих инструментов должен быть знаком \n"
"всем программистам: вставка вызова отладчика или (чаще всего) \n"
"вставка инструкции print."

#: in/chapter30.html:93
msgid "<h2>BREAK, PRINT</h2>"
msgstr "<h2>BREAK, PRINT</h2>"

#: in/chapter30.html:100
msgid ""
"<p><code>BREAK</code> causes your program to call the debugger.  Once\n"
"inside the debugger you can examine the call stack.  Most debuggers \n"
"also allow you to examine values local to each active function on the\n"
"call stack; by looking at these values at a critical point during your\n"
"program's execution, you may find an important clue as to why your\n"
"program malfunctions."
msgstr ""
"<p>\n"
"<code>BREAK</code> приводит к тому, что ваша программа вызывает отладчик. \n"
"Оказавшись внутри отладчика, вы можете изучить стек вызовов. Большинство \n"
"отладчиков также позволяют исследовать значения, локальные для каждой \n"
"активной функции в стеке вызовов; рассматривая эти значения в критической \n"
"точке во время выполнения программы, вы можете найти важный ключ к "
"пониманию \n"
"причин сбоев в работе программы.\n"

#: in/chapter30.html:107
msgid ""
"<p>The debugger will allow you to continue from a break. You may\n"
"find it helpful -- if you don't yet understand the cause of a\n"
"problem -- to correct one or more wrong values before continuing; with\n"
"other <code>BREAK</code> forms inserted at key points in your program,\n"
"this strategy may lead you to a place where the error <em>is</em> \n"
"apparent."
msgstr ""
"<p>\n"
"Отладчик позволит вам продолжить работу после break. Вы можете найти \n"
"полезным возможность - если вы еще не поняли причину проблемы - исправить "
"одно \n"
"или несколько неправильных значений, прежде чем продолжить; с другими \n"
"формами  <code>BREAK</code>, вставленными в ключевые точки вашей "
"программы, \n"
"эта стратегия может привести вас к месту, где ошибка очевидна."

#: in/chapter30.html:114
msgid ""
"<p>Of course, you can always insert <code>PRINT</code> forms at key\n"
"locations in your program and examine the resulting output.  In Lisp,\n"
"this is most useful when you need to get a feel for what's happening\n"
"deep inside some function.  For example, you might have a complex\n"
"calculation to determine whether a sequence of code is executed or\n"
"not.  A <code>PRINT</code> can tell you as the program runs."
msgstr ""
"<p>\n"
"Конечно, вы всегда можете вставить формы <code>PRINT</code> в ключевые \n"
"места вашей программы и изучить полученный результат. В Lisp это наиболее \n"
"полезно, когда вам нужно почувствовать, что происходит глубоко внутри \n"
"какой-то функции. Например, у вас может быть сложное вычисление, и чтобы \n"
"определить, выполняется ли последовательность кода или нет. <code>PRINT</"
"code>\n"
"может сказать вам, как работает программа."

#: in/chapter30.html:124
msgid ""
"<p>Don't forget that you can use <code>FORMAT</code> to print the\n"
"values of several variables together with explanatory text.  And with\n"
"either <code>PRINT</code> or <code>FORMAT</code>, be careful that you\n"
"do not change the meaning of the code by inserting the debugging\n"
"statement.  Remember that some flow-control forms (e.g. <code>IF</code> \n"
"and <code>UNWIND-PROTECT</code>) expect a single form at certain places.\n"
"Also beware of wrapping <code>PRINT</code> around a value-returning\n"
"form; this won't work if the value-receiving form expects multiple\n"
"values."
msgstr ""
"<p>\n"
"Не забывайте, что вы можете использовать <code>FORMAT</code> для печати \n"
"значений нескольких переменных вместе с пояснительным текстом. А при\n"
"использовании <code>PRINT</code> или <code>FORMAT</code> будьте осторожны, \n"
"чтобы не изменить значение кода, вставив инструкцию отладки. Помните, что \n"
"некоторые формы управления потоком (например, <code>IF</code> \n"
"и <code>UNWIND-PROTECT</code>) ожидают единую форму в определенных местах. \n"
"Кроме того, остерегайтесь обертывания <code>PRINT</code> вокруг формы \n"
"возврата значения; это не будет работать, если получатель значения ожидает \n"
"несколько значений."

#: in/chapter30.html:126
msgid "<h2>Power tools for tough problems</h2>"
msgstr "<h2>Мощные инструменты для трудных задач</h2>"

#: in/chapter30.html:129
msgid ""
"<p>Lisp provides additional debugging tools to help you observe the\n"
"dynamic behavior of your program."
msgstr ""
"<p>Lisp предоставляет дополнительные средства отладки, которые \n"
"помогут вам наблюдать динамическое поведение вашей программы."

#: in/chapter30.html:131
msgid "<h2>TRACE, STEP, ADVISE, WATCH</h2>"
msgstr ""

#: in/chapter30.html:137
msgid ""
"<p><code>TRACE</code> allows you to observe each call and return from\n"
"a specific function, no matter where the function appears in your program.\n"
"To trace a function, invoke <code>TRACE</code> with the name of the\n"
"function.  You can do this for as many functions as needed.  You can\n"
"also pass several function names to <code>TRACE</code>."
msgstr ""
"<p> \n"
"<code>TRACE</code> позволяет наблюдать за каждым вызовом и возвратом \n"
"из определенной функции, независимо от того, где эта функция появляется \n"
"в вашей программе. Чтобы отследить функцию, вызовите <code>TRACE</code> \n"
"с именем функции. Вы можете сделать это для любого количества функций, \n"
"которые вам необходимы. Вы также можете передать несколько имен функций \n"
"для <code>TRACE</code>."

#: in/chapter30.html:142
msgid ""
"<p>When your program runs a traced function, it will print the name of\n"
"the function on entry and exit.  Most <code>TRACE</code> implementations\n"
"will also print the function arguments on entry and returned values on\n"
"exit."
msgstr ""
"<p>\n"
"Когда ваша программа запускает отслеживаемую функцию, она будет печатать \n"
"имя функции при входе и выходе. Большинство реализаций трассировки также \n"
"печатают аргументы функции при входе и возвращаемые значения при выходе.\n"

#: in/chapter30.html:146
msgid ""
"<p>To discontinue tracing of a function, pass its name to\n"
"<code>UNTRACE</code>. To discontinue tracing of <em>all</em> traced\n"
"functions, evaluate <code>(UNTRACE)</code>."
msgstr ""
"<p>\n"
"Чтобы прекратить трассировку функции, передайте ее имя в <code>UNTRACE</"
"code>. \n"
"Чтобы прекратить трассировку всех отслеживаемых функций, выполните \n"
"вычисление <code>(UNTRACE)</code>."

#: in/chapter30.html:149
msgid ""
"<p>See <a href=\"chapter16.html#trace-and-step\">Chapter 16</a> for an\n"
"example of <code>TRACE</code>."
msgstr ""
"<p>\n"
"См. <a href=\"chapter16.html#trace-and-step\">Главу 16</a> \n"
"для ознакомления с примером использования <code>TRACE</code>."

#: in/chapter30.html:157
msgid ""
"<p><code>STEP</code> allows you to interactively control evaluation of\n"
"an expression.  If you step a function invocation, you should be able\n"
"to examine each subform of the function's definition just before it\n"
"is evaluated.  <code>STEP</code> implementations vary widely, so you\n"
"should consult your vendor's documentation for further details.  In\n"
"general, the same optimizations and controls that aid the debugger will\n"
"also aid the stepper."
msgstr ""
"<p>\n"
"<code>STEP</code> позволяет вам интерактивно управлять вычислением \n"
"выражения. Если вы выполняете шаг вызова функции, вы должны иметь \n"
"возможность изучить каждую подформу определения функции непосредственно \n"
"перед ее вычислением. Реализации <code>STEP</code> сильно различаются, \n"
"поэтому для получения более подробной информации вам следует обратиться \n"
"к документации вашего поставщика. В общем случае те же самые оптимизации \n"
"и элементы управления, которые помогают отладчику, будут также помогать \n"
"пошаговому исполнению.\n"

#: in/chapter30.html:162
msgid ""
"<p><code>STEP</code> is a very labor-intensive way to debug a program,\n"
"since you must tell its user interface to evaluate each subform.  This\n"
"is reasonable for straight-line code, but quickly becomes tedious in \n"
"the presence of looping or recursion."
msgstr ""
"<p>\n"
"<code>STEP</code> - это очень трудоемкий способ отладки программы, \n"
"так как вы должны указать ее пользовательский интерфейс для вычисления \n"
"каждой подформы. Это разумно для прямолинейного кода, но быстро становится \n"
"утомительным при наличии циклов или рекурсии."

#: in/chapter30.html:166
msgid ""
"<p>Some Lisp implementations provide two additional tools,\n"
"<code>ADVISE</code> and <code>WATCH</code>, that can be of use during\n"
"debugging.  "
msgstr ""
"<p>\n"
"Некоторые реализации Lisp предоставляют два дополнительных инструмента, \n"
"<code>ADVISE</code> и <code>WATCH</code>, которые могут быть использованы \n"
"во время отладки."

#: in/chapter30.html:175
msgid ""
"<p><code>ADVISE</code> modifies a function without changing its\n"
"source code. <code>ADVISE</code> can usually examine the advised\n"
"function's arguments, execute its own code, execute the advised\n"
"function, examine the advised function's return values, and modify\n"
"the returned values.  For debugging purposes, <code>ADVISE</code> \n"
"can be used to implement conditional <code>BREAK</code>s and \n"
"<code>TRACE</code>s, or to temporarily patch incorrect behavior\n"
"in one part of a program while you're debugging another part."
msgstr ""
"<p>\n"
"<code>ADVISE</code> изменяет функцию без изменения ее исходного кода. \n"
"<code>ADVISE</code> обычно может проверить аргументы рекомендованной "
"функции, \n"
"выполнить ее собственный код, выполнить рекомендованную функцию, проверить \n"
"возвращаемые значения рекомендованной функции и изменить возвращаемые "
"значения. \n"
"В целях отладки <code>ADVISE</code> можно использовать для реализации "
"условных \n"
"<code>BREAK</code> и <code>TRACE</code> или для временного исправления \n"
"неправильного поведения в одной части программы во время отладки \n"
"другой части."

#: in/chapter30.html:182
msgid ""
"<p><code>WATCH</code> lets you specify variables to be displayed\n"
"as your program executes.  This is normally available only in \n"
"Lisp implementations that provide a windowed user interface.\n"
"Because of issues of variable scope and display update timing and\n"
"overhead, <code>WATCH</code> is of limited value.  Most Lisp \n"
"implementations do not provide this tool."
msgstr ""
"<p>\n"
"<code>WATCH</code>  позволяет указать переменные, которые будут \n"
"отображаться при выполнении программы. Это обычно доступно только \n"
"в реализациях Lisp, которые предоставляют оконный пользовательский \n"
"интерфейс. Из-за проблем с переменной областью действия, временем \n"
"обновления дисплея и накладными расходами <code>WATCH</code> имеет \n"
"ограниченную ценность. Большинство реализаций Lisp не предоставляют \n"
"этот инструмент."

#: in/chapter30.html:184
msgid "<h2>Into the belly of the beast</h2>"
msgstr "<h2>Прямо в брюхо зверя</h2>"

#: in/chapter30.html:190
msgid ""
"<p>As you debug your program, you may need to see the internal\n"
"details of composite objects such as lists, structures, arrays,\n"
"streams and CLOS instances.  Lisp lets you do this whether the\n"
"data has been defined by your program or by the Lisp runtime\n"
"system."
msgstr ""
"<p>\n"
"При отладке программы может потребоваться просмотреть внутренние \n"
"сведения о составных объектах, таких как списки, структуры, массивы, \n"
"потоки и экземпляры CLOS. Lisp позволяет вам сделать это независимо \n"
"от того, были ли данные определены вашей программой или системой \n"
"выполнения Lisp."

#: in/chapter30.html:192
msgid "<h2>INSPECT, DESCRIBE</h2>"
msgstr ""

#: in/chapter30.html:198
msgid ""
"<p><code>DESCRIBE</code> is a function that accepts any object as an\n"
"argument and prints a description of that object. The form and\n"
"content of the description may vary among Lisp implementations.\n"
"<code>DESCRIBE</code> accepts an output stream as an optional second\n"
"argument."
msgstr ""
"<p>\n"
"<code>DESCRIBE</code> - это функция, которая принимает любой объект \n"
"в качестве аргумента и печатает описание этого объекта. Форма и \n"
"содержание описания могут варьироваться в зависимости от реализаций \n"
"Lisp. <code>DESCRIBE</code> принимает выходной поток в качестве \n"
"необязательного второго аргумента.\n"

#: in/chapter30.html:203
msgid ""
"<p><code>INSPECT</code> is an interactive version of\n"
"<code>DESCRIBE</code>. This is most useful for examining complex\n"
"objects by \"drilling down\" into the implementation details of\n"
"enclosed data elements."
msgstr ""
"<p>\n"
"<code>INSPECT</code> это интерактивная версия <code>DESCRIBE</code>. \n"
"Он наиболее полезен для изучения сложных объектов путем \"детализации\" \n"
"деталей реализации вложенных элементов данных."

#: in/chapter30.html:205
msgid "<h2>Continuing from an error</h2>"
msgstr "<h2>Продолжая с(?) ошибками</h2>"

#: in/chapter30.html:211
msgid ""
"<p>When faced with the debugger, you will have a choice of restart\n"
"actions depending upon how the error was signalled.  <code>ERROR</code> \n"
"requires that you abandon your program's executions.  However,\n"
"many internal Lisp functions use <code>CERROR</code>, which gives you\n"
"a chance to continue from an error."
msgstr ""
"<p>\n"
"Когда вы столкнетесь с отладчиком, у вас будет выбор действий перезапуска \n"
"в зависимости от того, как была сигнализирована ошибка. \n"
"<code>ERROR</code> требует, чтобы вы отказались от выполнения вашей "
"программы. \n"
"Однако многие внутренние функции Lisp используют <code>CERROR</code>, что "
"дает \n"
"вам возможность продолжить работу после ошибки.\n"

#: in/chapter30.html:214
msgid ""
"<p>In most debuggers, you can do quite a few useful things before\n"
"continuing from an error:"
msgstr ""
"<p>\n"
"В большинстве отладчиков вы можете сделать довольно много полезных вещей, \n"
"прежде чем продолжить работу после ошибки:"

#: in/chapter30.html:224
msgid ""
"<ul>\n"
"<li>alter variable values\n"
"<li>redefine the function that caused the error and run it again\n"
"<li>skip the rest of the function that caused the error and \n"
"    specify values to be returned\n"
"<li>restart any function further down the call stack\n"
"<li>skip the rest of any function further down the call stack and\n"
"    specify values to be returned\n"
"</ul> "
msgstr ""
"<ul>\n"
"<li>изменение значений переменных\n"
"<li>переопределить функцию, вызвавшую ошибку, и запустить ее снова\n"
"<li>пропустить остальную часть функции, вызвавшей ошибку, и \n"
"    указать возвращаемые значения\n"
"<li>перезагрузить любую функцию ниже по стеку вызовов\n"
"<li>пропустить остальную часть любой функции дальше по стеку вызовов и \n"
"    указать возвращаемые значения\n"
"</ul> "

#: in/chapter30.html:226
msgid "<h2>Problems with unwanted definitions</h2>"
msgstr "<h2>Проблемы с нежелательными определениями</h2>"

#: in/chapter30.html:236
msgid ""
"<p>Unwanted definitions are not usually a problem in a Lisp program.\n"
"You can get rid of function definitions using\n"
"<code>FMAKUNBOUND</code>, variable values with\n"
"<code>MAKUNBOUND</code>, and even symbols with\n"
"<code>UNINTERN</code>. In practice, there's usually no need to use\n"
"any of these; available memory is commonly large compared to the\n"
"size of a few misdefined variables or functions, and they will be\n"
"eliminated anyway the next time you restart your Lisp image and load\n"
"your program."
msgstr ""
"<p>\n"
"Нежелательные определения обычно не являются проблемой в программе Lisp. \n"
"Вы можете избавиться от определений функций с помощью <code>FMAKUNBOUND</"
"code>, \n"
"от значений переменных с помощью <code>MAKUNBOUND</code> и даже от "
"символов \n"
"с помощью <code>UNINTERN</code>. На практике обычно нет необходимости \n"
"использовать любой из них; доступная память обычно велика по сравнению \n"
"с размером нескольких неверно определенных переменных или функций, и \n"
"они будут устранены в любом случае при следующем перезапуске образа Lisp \n"
"и загрузке вашей программы."

#: in/chapter30.html:244
msgid ""
"<p>Method definitions are an entirely different matter.  Remember that\n"
"methods must have congruent argument lists; if you change your mind\n"
"during program development about a method's argument list -- perhaps\n"
"you thought that it needed two arguments at first but then realized\n"
"three arguments are really needed -- then you'll have to remove the\n"
"old method definition before adding the new one.  Some Lisp environments\n"
"facilitate this redefinition:"
msgstr ""
"<p>\n"
"Определения методов - это совершенно другой вопрос. Помните, что методы \n"
"должны иметь конгруэнтные списки аргументов; если вы изменили свое мнение \n"
"во время разработки программы о списке аргументов метода - возможно, "
"сначала \n"
"вы думали, что ему нужны два аргумента, но затем поняли, что на самом деле "
"нужны \n"
"три аргумента, - то вам придется удалить старое определение метода, прежде "
"чем \n"
"добавлять новое. Некоторых средах Лисп этот пересмотр облегчен:"

#: in/chapter30.html:256
msgid ""
"<pre>\n"
"? (defmethod baz (a b))\n"
"#&lt;STANDARD-METHOD BAZ (T T)&gt;\n"
"? (defmethod baz (a b c))\n"
"Error: Incompatible lambda list in #&lt;STANDARD-METHOD BAZ (T T T)&gt;\n"
"       for #&lt;STANDARD-GENERIC-FUNCTION BAZ #x3D2CB66&gt;.\n"
"Restart options:\n"
"  1. Remove 1 method from the generic-function and change its lambda list\n"
"  2. Top levl\n"
"  ? \n"
"</pre> "
msgstr ""

#: in/chapter30.html:264
msgid ""
"<p>If you simply add a method that you later decide is no longer\n"
"wanted, you'll need a way to remove the method. The least desirable\n"
"technique is to restart your Lisp system and reload your program\n"
"without the unwanted definition. Another approach, provided by some\n"
"vendors, is to interactively remove the definition using a special\n"
"editor command or a method browser. Failing all else, you can remove\n"
"the method manually using <code>REMOVE-METHOD</code>:"
msgstr ""
"<p>\n"
"Если вы просто добавляете метод, который, как вы позже решите, \n"
"больше не нужен, вам понадобится способ удалить этот метод. \n"
"Наименее желательным методом является перезагрузка системы Lisp и \n"
"перезагрузка программы без нежелательного определения. Другой подход, \n"
"который предлагают некоторые поставщики, заключается в интерактивном \n"
"удалении определения с помощью специальной команды редактора или браузера \n"
"методов. Если все остальное не удается, вы можете удалить этот метод "
"вручную \n"
"с помощью  <code>REMOVE-METHOD</code>:"

#: in/chapter30.html:274
msgid ""
"<pre>\n"
"(let* ((generic-function (symbol-function '<i>gf-name</i>))\n"
"       (method (find-method generic-function\n"
"                            '(<i>method-specializers</i>)\n"
"                            (list (find-class <i>parameter-class-name</i>)\n"
"                                  <i>; one per argument</i> \n"
"                                  ...))))\n"
"  (remove-method generic-function method))\n"
"</pre> "
msgstr ""

#: in/chapter30.html:281
msgid ""
"<p>where <i>gf-name</i> is the name of the generic function (i.e.\n"
"the name of the method), <i>method-specializers</i> is either empty\n"
"or a method combination specifier, such as <code>:BEFORE</code>,\n"
"<code>:AFTER</code>, or <code>:AROUND</code>, and\n"
"<i>parameter-class-name</i> is the name of the class on which a\n"
"particular method parameter is specialized."
msgstr ""
"<p>\n"
"где <i>gf-name</i> - это имя обобщенной функции (т. е. имя метода), \n"
"<i>method-specializers</i> - это либо пустой спецификатор, либо \n"
"комбинации спецификаторов  метода, таких как <code>:BEFORE</code>,\n"
"<code>:AFTER</code>, или <code>:AROUND</code>, а \n"
"<i>parameter-class-name</i> - это имя класса, на котором специализирован \n"
"конкретный параметр метода."

#: in/chapter30.html:283
msgid "<h2>Package problems; method definitions</h2>"
msgstr "<h2>Проблемы в пакетах; определения методов</h2>"

#: in/chapter30.html:293
msgid ""
"<p>Symbol conflicts across packages can be frustrating during\n"
"development. If you have defined multiple packages for your program,\n"
"you'll need to be careful to set the proper package (using\n"
"<code>IN-PACKAGE</code>) before defining an object intended for that\n"
"package.  If you inadvertently create an object in the wrong package\n"
"and then attempt to define it in the correct package, Lisp will signal\n"
"an error if there is a \"uses\" relationship between the two packages.\n"
"The proper response is to first remove the erroneous definition using\n"
"<code>UNINTERN</code>."
msgstr ""
"<p>\n"
"Конфликты символов между пакетами могут быть неприятными во время "
"разработки. \n"
"Если вы определили несколько пакетов для своей программы, вам нужно будет "
"быть\n"
"осторожным, чтобы установить правильный пакет (используя <code>IN-PACKAGE</"
"code>) \n"
"перед определением объекта, предназначенного для этого пакета. Если вы "
"случайно \n"
"создадите объект в неправильном пакете, а затем попытаетесь определить его "
"в \n"
"правильном пакете, Lisp будет сигнализировать об ошибке, если существует "
"связь \n"
"\"uses\" между двумя пакетами. Правильный ответ заключается в том, чтобы "
"сначала \n"
"удалить ошибочное определение с помощью <code>UNINTERN</code>."

#: in/chapter30.html:297
msgid ""
"<p>You can also get into trouble with packages by having unexported\n"
"classes defined in two packages and specializing a method based on the\n"
"wrong class."
msgstr ""
"<p>\n"
"Вы также можете попасть в неприятности с пакетами, имея unexported\n"
"(не экспортированные) классы, определенные в двух пакетах, и специализируя \n"
"метод, основанный на неправильном классе."

#: in/chapter30.html:299
msgid "<h2>The problem with macros</h2>"
msgstr "<h2>Проблемы с макросами</h2>"

#: in/chapter30.html:305
msgid ""
"<p>Macros must always be defined before use.  This is especially \n"
"important when you redefine a macro during development: every piece\n"
"of code that uses the redefined macro <code>must</code> be recompiled.\n"
"You can help yourself avoid macro redefinition problems by reloading\n"
"your source code after redefining any macro(s)."
msgstr ""
"<p>\n"
"Макросы всегда должны быть определены перед использованием. Это особенно \n"
"важно при переопределении макроса во время разработки: каждый фрагмент "
"кода, \n"
"использующий переопределенный макрос, <code>должен быть</code> "
"перекомпилирован. \n"
"Вы можете помочь себе избежать проблем с переопределением макросов, "
"перезагрузив \n"
"исходный код после переопределения любого макроса(ов)."

#: in/chapter30.html:307
msgid "<h2>Runtime tests catch \"can't happen cases\" when they do...</h2>"
msgstr ""
"<h2>Проверки времени выполнения ловят \"случаи которых не может быть\" когда "
"они\n"
"порисходят...</h2>"

#: in/chapter30.html:313
msgid ""
"<p>When I read code, finding the phrase \"can't happen\" in a comment\n"
"always raises a red flag. Usually, this statement is made after the\n"
"programmer has examined the code's execution environment and\n"
"intended use. Unfortunately, things change and \"can't happen\" cases\n"
"do happen."
msgstr ""
"<p>\n"
"Когда я читаю код, нахождение фразы \"не может произойти\" в комментарии \n"
"всегда вызывает красный флаг. Обычно это утверждение делается после того, \n"
"как программист изучил среду выполнения кода и его предполагаемое "
"использование. \n"
"К сожалению, все меняется, и случаи \"не может случиться\" действительно "
"случаются."

#: in/chapter30.html:321
msgid ""
"<p>Lisp provides a very handy facility for checking \"can't happen\"\n"
"statements at runtime.  The <code>ASSERT</code> macro expects a \n"
"form that will evaluate to true at runtime.  If the form evaluates\n"
"to <code>NIL</code> instead, <code>ASSERT</code> signals a continuable\n"
"error, transferring control to the debugger.  At the very least, this\n"
"will help you to learn which assertion was violated so you can \n"
"correct your program."
msgstr ""
"<p>\n"
"Lisp предоставляет очень удобный инструмент для проверки операторов\n"
"\"не может произойти\" во время выполнения. Макрос <code>ASSERT</code>\n"
"предполагает форму, которая будет возвращать true во время выполнения. \n"
"Если вместо этого форма принимает значение <code>NIL</code>, <code>ASSERT</"
"code>\n"
"сигнализирует о продолжаемой(continuable) ошибке, передавая управление "
"отладчику. \n"
"По крайней мере, он поможет вам узнать, какое утверждение было нарушено, "
"чтобы \n"
"вы могли исправить свою программу."

#: in/chapter30.html:324
msgid ""
"<p><code>ASSERT</code> accepts an optional list of value places that\n"
"the user can interactively change to satisfy the assertion."
msgstr ""
"<p>\n"
"<code>ASSERT</code> принимает необязательный список мест значений, \n"
"который пользователь может интерактивно изменить, чтобы удовлетворить \n"
"этому утверждению."

#: in/chapter30.html:340
msgid ""
"<pre>\n"
"? (defun add-2 (n)\n"
"    (assert (numberp n) (n))\n"
"    (+ 2 n))\n"
"? (add-2 3)\n"
"5\n"
"? (add-2 'foo)\n"
"Error: Failed assertion (NUMBERP N)\n"
"Restart options:\n"
"  1. Change the values of some places, then retry the assertion\n"
"  2. Top level\n"
"  ? 1\n"
"  Value for N: 4\n"
"6\n"
"</pre> "
msgstr ""

#: in/chapter30.html:345
msgid ""
"See <a href=\"chapter23.html\">Chapter 23</a> for additional\n"
"information about \n"
"<a href=\"chapter23.html#assert\"><code>ASSERT</code></a> and other error\n"
"detection and recovery techniques."
msgstr ""
"Дополнительную информацию о <a href=\"chapter23.html#assert\"><code>ASSERT</"
"code></a>\n"
" и других методах обнаружения и восстановления ошибок см. В \n"
"<a href=\"chapter23.html\">Главе 23</a>"

#: in/chapter30.html:347
msgid "<h2>Use method dispatch rather than case dispatch</h2>"
msgstr ""
"<h2>Используйте диспечеризацию метдов, а не условную диспетчеризацию(case "
"dispatch)</h2>"

#: in/chapter30.html:359
msgid ""
"<p>When your program needs to make a decision based on the type of\n"
"an object, you have two choices. You can use <code>TYPECASE</code>\n"
"or <code>DEFMETHOD</code>. Unless you have a circumstance that\n"
"particularly warrants the use of <code>TYPECASE</code> (or its\n"
"variants <code>CTYPECASE</code> and <code>ETYPECASE</code>) -- and\n"
"especially if the set of types will change during normal program\n"
"evolution or maintenance -- you should probably construct your\n"
"program to operate on the individual types via generic functions.\n"
"This more clearly exposes the intent of the program and eliminates\n"
"the likelihood that you will forget to update a\n"
"<code>TYPECASE</code> form during maintenance."
msgstr ""
"<p>\n"
"Когда ваша программа должна принять решение, основанное на типе объекта, \n"
"у вас есть два варианта. Вы можете использовать <code>TYPECASE</code>\n"
"или <code>DEFMETHOD</code>. Если у вас нет обстоятельств, которые особенно \n"
"оправдывают использование <code>TYPECASE</code> (или его вариантов\n"
"<code>CTYPECASE</code> и <code>ETYPECASE</code>) - и особенно если набор \n"
"типов будет меняться в ходе нормальной эволюции программы или обслуживания\n"
"- вы, вероятно, должны построить свою программу для работы с отдельными "
"типами \n"
"с помощью обобщенных функций. Это более четко раскрывает цель программы и \n"
"исключает вероятность того, что вы забудете обновить форму <code>TYPECASE</"
"code>\n"
" во время обслуживания."

#: in/chapter30.html:372
msgid ""
"<hr>\n"
"<div align=\"center\">\n"
"<a href=\"contents.html\">Contents</a> | <a href=\"cover.html\">Cover</a> "
"<br> \n"
"<a href=\"chapter29.html\">Chapter 29</a> | Chapter 30 | <a href=\"chapter31."
"html\">Chapter 31</a> \n"
"</div>\n"
"<hr>\n"
"<address>\n"
"Copyright &copy; 1995-2001, David B. Lamkins<br>\n"
"All Rights Reserved Worldwide<br>\n"
"<br>\n"
"This book may not be reproduced without the written consent of its author.  "
"Online distribution is restricted to the author's site.\n"
"</address> \n"
"</body> </html> "
msgstr ""
