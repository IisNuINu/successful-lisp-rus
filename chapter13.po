#
# NuINu <don't@send.my>, 2020.
#
#. extracted from in/chapter13.html
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-04-19 13:50+0300\n"
"PO-Revision-Date: 2020-05-29 10:34+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter13.html:5
msgid ""
"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/"
"html4/strict.dtd\">\n"
"<html><head>\n"
"<title>Successful Lisp - Chapter 13</title>\n"
"</head> "
msgstr ""

#: in/chapter13.html:8
msgid ""
"<body bgcolor=\"white\" text=\"black\">\n"
"<h1>Chapter 13 - Still More Things You Can Do with Sequences</h1> "
msgstr ""
"<body bgcolor=\"white\" text=\"black\">\n"
"<h1>Глава 13 - Еще больше вещей, которые вы можете\n"
"сделать с последовательностями(Sequences)</h1> "

#: in/chapter13.html:12
msgid ""
"<p>In this chapter we'll meet the most useful sequence functions, and see \n"
"how to use them.  We'll also reprise earlier admonitions about proper use\n"
"of destructive functions."
msgstr ""
"<p>\n"
"В этой главе мы познакомимся с наиболее полезными функциями работы с "
"последовательностями и посмотрим, как их использовать. Мы также повторим \n"
"более ранние предостережения о правильном использовании разрушающих\n"
"функций."

#: in/chapter13.html:14
msgid "<h2>CONCATENATE: new sequences from old</h2>"
msgstr "<h2>CONCATENATE: новая последовательность из старых</h2>"

#: in/chapter13.html:19
msgid ""
"<p><code>CONCATENATE</code> always creates a new sequence from (of course)\n"
"the concatenation of zero or more argument sequences. You must specify the\n"
"type of the result, and the argument types must be proper subtypes of the\n"
"sequence type."
msgstr ""
"<p><code>CONCATENATE</code>  всегда создает новую последовательность \n"
"из (Конечно же) соединяемых нуля или более последовательностей аргументов. \n"
"Вы должны указать тип результата, а типы аргументов должны быть правильными "
"подтипами типа последовательности."

#: in/chapter13.html:36
msgid ""
"<pre>\n"
"? (concatenate 'list) <i>; no argument sequences</i> \n"
"NIL\n"
"? (concatenate 'vector) <i>; no argument sequences</i> \n"
"#()\n"
"? (concatenate 'list '(1 2 3) '(4 5))\n"
"(1 2 3 4 5)\n"
"? (concatenate 'vector #(1 2 3) #(4 5))\n"
"#(1 2 3 4 5)\n"
"? (concatenate 'list #(1 2 4) '(4 5))\n"
"(1 2 3 4 5)\n"
"? (concatenate 'vector '(1 2 3) #(4 5))\n"
"#(1 2 3 4 5)\n"
"? (concatenate 'list \"hello\") <i>; string is a subtype of sequence</i> \n"
"(#\\h #\\e #\\l #\\l #\\o)\n"
"</pre> "
msgstr ""

#: in/chapter13.html:38
msgid ""
"<h2>ELT and SUBSEQ get what you want from any sequence (also, COPY-SEQ)</h2>"
msgstr ""
"<h2>ELT и SUBSEQ получают то что вы хотите из любой последовательности "
"(также см., COPY-SEQ)</h2>"

#: in/chapter13.html:45
msgid ""
"<p>If you need to pick out one element (or a range of elements) from a \n"
"sequence, you can use <code>ELT</code> (to pick out one element) or \n"
"<code>SUBSEQ</code> (to pick out a range of elements). But don't use these\n"
"unless you're really sure you can't narrow down the sequence type to a\n"
"vector or list; there are more specific (hence more efficient) accessors\n"
"for the less general types."
msgstr ""
"<p>\n"
"Если вам нужно выбрать один элемент (или диапазон элементов) из\n"
"последовательности, вы можете использовать <code>ELT</code> \n"
"(чтобы выбрать один элемент) или <code>SUBSEQ</code> \n"
"(чтобы выбрать диапазон элементов). Но не используйте их, если \n"
"вы действительно не уверены, что не можете сузить тип \n"
"последовательности до вектора или списка; существуют более \n"
"специфические (следовательно, более эффективные) методы доступа \n"
"для менее общих типов."

#: in/chapter13.html:49
msgid ""
"<p><code>SUBSEQ</code> makes a copy of a specified portion of a sequence.\n"
"<code>COPY-SEQ</code> is closely related to <code>SUBSEQ</code>, except\n"
"that it copies <em>all</em> of the elements of a sequence."
msgstr ""
"<p>\n"
"<code>SUBSEQ</code> создает копию указанной части последовательности. \n"
"<code>COPY-SEQ</code> тесно связан с <code>SUBSEQ</code>, за исключением \n"
"того, что он копирует все элементы последовательности."

#: in/chapter13.html:64
msgid ""
"<pre>\n"
"? (elt '(1 2 3 4 5) 1) <i>; zero-based indexing</i> \n"
"2\n"
"? (subseq '(1 2 3 4 5) 2) <i>; 3rd element through end</i> \n"
"(3 4 5)\n"
"? (let ((l '(1 2 3 4 5)))\n"
"    (subseq l 2 (length l))) <i>; same effect as previous</i> \n"
"? (subseq '(1 2 3 4 5) 0 3) <i>; element at ending index is not copied</i> \n"
"(1 2 3)\n"
"? (subseq #(#\\a #\\b #\\c #\\d #\\e) 2 4)\n"
"#(#\\c #\\d)\n"
"? (copy-seq '(a b c))\n"
"(A B C)\n"
"</pre> "
msgstr ""

#: in/chapter13.html:66
msgid "<h2>REVERSE turns a sequence end-for-end (also, NREVERSE)</h2>"
msgstr ""
"<h2>REVERSE переворачивает последовательность с начала в конец (см. также, "
"NREVERSE)</h2>"

#: in/chapter13.html:71
msgid ""
"<p><code>REVERSE</code> makes a copy of a sequence, with the order of\n"
"elements reversed.  <code>NREVERSE</code> is the destructive counterpart\n"
"of <code>REVERSE</code>; it is more efficient, but it modifies its\n"
"input argument."
msgstr ""
"<p><code>REVERSE</code>  делает копию последовательности, с обратным \n"
"порядком следования элементов. <code>NREVERSE</code> - это разрушающий\n"
"аналог <code>REVERSE</code>; он более эффективен, но он изменяет свой \n"
"входной аргумент."

#: in/chapter13.html:73
msgid ""
"<p><code>REVERSE</code> is commonly used in code similar to the following."
msgstr ""
"<p><code>REVERSE</code> обычно используется в коде, аналогичном следующему."

#: in/chapter13.html:82
msgid ""
"<pre>\n"
"(defun collect-even-numbers (number-list)\n"
"  (let ((result ()))\n"
"    (dolist (number number-list)\n"
"      (when (evenp number)\n"
"        (push number result)))\n"
"    (nreverse result)))\n"
"</pre> "
msgstr ""

#: in/chapter13.html:90
msgid ""
"<p>The <code>DOLIST</code> and <code>PUSH</code> collect even\n"
"numbers on the result list, but they are in the reverse order of\n"
"their original positions on the input list. The final\n"
"<code>NREVERSE</code> puts them back into their original order. This\n"
"is a safe use of the destructive function <code>NREVERSE</code>\n"
"because the <code>RESULT</code> variable can not be shared; it is\n"
"forgotten as soon as control leaves the <code>LET</code> form."
msgstr ""
"<p>\n"
"<code>DOLIST</code> и <code>PUSH</code> собирают четные числа \n"
"в списке результатов, но они находятся в обратном порядке от \n"
"их исходных позиций в списке ввода. Последний <code>NREVERSE</code>\n"
"возвращает их к первоначальному порядку. Это безопасное использование\n"
"разрушающей функции <code>NREVERSE</code>, потому что переменная \n"
"<code>RESULT</code> не может быть разделена; она забывается, как только \n"
"управление покидает форму  <code>LET</code>."

#: in/chapter13.html:92
msgid "<h2>LENGTH: size counts after all</h2>"
msgstr "<h2>LENGTH: в конце концов, размер имеет значение</h2>"

#: in/chapter13.html:96
msgid ""
"<p>There's not much to say about <code>LENGTH</code>. Just remember\n"
"that for lists, <code>LENGTH</code> counts only the elements of the\n"
"top-level list, and not those of any nested lists."
msgstr ""
"<p>\n"
"О <code>LENGTH</code> говорить особо нечего. Просто помните, что для "
"списков\n"
"<code>LENGTH</code> подсчитывает только элементы списка верхнего уровня, \n"
"а не элементы каких-либо вложенных списков.."

#: in/chapter13.html:101
msgid ""
"<pre>\n"
"? (length '((1 2 3) (4 5) (6) 7 () 8 9))\n"
"7\n"
"</pre> "
msgstr ""

#: in/chapter13.html:103
msgid "<h2>COUNT: when it's what's inside that matters</h2>"
msgstr "<h2>COUNT: когда важно, что находится внутри</h2>"

#: in/chapter13.html:107
msgid ""
"<p>If you find your program filters a sequence only to get the length\n"
"of the result, use <code>COUNT</code> (and related functions\n"
"<code>COUNT-IF</code> and <code>COUNT-IF-NOT</code>) instead."
msgstr ""
"<p>\n"
"Если вы обнаружите, что ваша программа фильтрует последовательность \n"
"только для получения длины результата, используйте вместо этого \n"
"<code>COUNT</code> (и связанные с ним функции \n"
"<code>COUNT-IF</code> и <code>COUNT-IF-NOT</code>)."

#: in/chapter13.html:116
msgid ""
"<pre>\n"
"? (count 3 '(1 3 3 4 2 5 9 8 3 1 9)) <i>; count occurrences</i> \n"
"3\n"
"? (count-if #'oddp '(1 3 3 4 2 5 9 8 3 1 9)) <i>; count matches to "
"predicate</i> \n"
"8\n"
"? (count-if-not #'evenp '(1 3 3 4 2 5 9 8 3 1 9)) <i>; count mismatches "
"using predicate</i> \n"
"8\n"
"</pre> "
msgstr ""

#: in/chapter13.html:118
msgid "<p>These functions accept keyword arguments:"
msgstr "<p>Эти функции принимают аргументы ключевые слова:"

#: in/chapter13.html:127
msgid ""
"<pre>\n"
"Keyword      Value                                        Default\n"
"-------      -----                                        -------\n"
":START       starting index (inclusive)                   0\n"
":END         ending index (exclusive)                     NIL\n"
":FROM-END    non-NIL to work backwards from end element   NIL\n"
":KEY         function to select match data from element   NIL\n"
"</pre> "
msgstr ""

#: in/chapter13.html:132
msgid ""
"<p>A <code>NIL</code> value for the <code>:END</code> keyword designates\n"
"a position just past the end of the sequence; since this is an exclusive\n"
"limit, the last element will be processed.  (If you specified the index\n"
"of the last element, the last element would <em>not</em> be processed.)"
msgstr ""
"<p><code>NIL</code> значение для ключевого слова <code>:END</code> \n"
"обозначает позицию сразу после конца последовательности; поскольку это\n"
"исключительный предел, последний элемент будет обработан. (Если вы указали \n"
"индекс последнего элемента, то последний элемент не будет обработан.)"

#: in/chapter13.html:136
msgid ""
"<p>The <code>:FROM-END</code> keyword is useful in the case that the\n"
"test function has side-effects, and the order of the side-effects is\n"
"important."
msgstr ""
"<p>\n"
"Ключевое слово <code>:FROM-END</code> полезно в том случае, \n"
"если тестовая функция имеет побочные эффекты, и порядок \n"
"побочных эффектов важен."

#: in/chapter13.html:140
msgid ""
"<p>When the <code>:KEY</code> argument is not <code>NIL</code>, it should\n"
"be a function of one argument that extracts data from the sequence element.\n"
"For example:"
msgstr ""
"<p>\n"
"Когда аргумент <code>:KEY</code>  не равен <code>NIL</code>, он должен \n"
"быть функцией одного аргумента, которая извлекает данные из элемента\n"
"последовательности. Например:"

#: in/chapter13.html:145
msgid ""
"<pre>\n"
"? (count 3 '((1 2 3) (2 3 1) (3 1 2) (2 1 3) (1 3 2) (3 2 1)) :key "
"#'second)\n"
"2\n"
"</pre> "
msgstr ""

#: in/chapter13.html:150
msgid ""
"<p><code>COUNT</code> accepts the additional keyword arguments\n"
"<code>:TEST</code> and <code>:TEST-NOT</code>.  These give you a compact\n"
"way to write a test that involves a second value.  Compare the following\n"
"equivalent forms:"
msgstr ""
"<p>\n"
"<code>COUNT</code> принимает дополнительные аргументы ключевые слова \n"
"<code>:TEST</code> и <code>:TEST-NOT</code>. Они дают вам компактный \n"
"способ написать тест, который включает в себя второе значение. Сравните \n"
"следующие эквивалентные формы:"

#: in/chapter13.html:154
msgid ""
"<pre>\n"
"<i>; Using COUNT-IF and LAMBDA</i> \n"
"(count-if #'(lambda (n) (< 3 n)) '(1 2 3 4 5 6 7))"
msgstr ""

#: in/chapter13.html:158
msgid ""
"<i>; Using COUNT and :TEST</i> \n"
"(count 3 '(1 2 3 4 5 6 7) :test #'<)\n"
"</pre> "
msgstr ""

#: in/chapter13.html:164
msgid ""
"<p>The keyword arguments for comparison predicates also let you\n"
"define the precise meaning of equality. The default predicate is\n"
"<code>EQL</code>, which is true for identical numbers and symbols.\n"
"See <a href=\"chapter17.html\">Chapter 17</a> for more information on\n"
"comparison predicates."
msgstr ""
"<p>\n"
"Ключевые слова аргументы для предикатов сравнения также позволяют \n"
"определить точное значение равенства. Предикат по умолчанию - <code>EQL</"
"code>,\n"
"что верно для идентичных чисел и символов. Дополнительную информацию о \n"
"предикатах сравнения см. В <a href=\"chapter17.html\">Главе 17</a>"

#: in/chapter13.html:166
msgid "<h2>REMOVE, SUBSTITUTE, and other sequence changers</h2>"
msgstr "<h2>REMOVE, SUBSTITUTE, и другие модификаторы последовательностей</h2>"

#: in/chapter13.html:169
msgid ""
"<p><code>REMOVE</code> removes all occurrences of a specified\n"
"element from a sequence. "
msgstr ""
"<p><code>REMOVE</code> удаляет все вхождения указанного элемента из\n"
"последовательности"

#: in/chapter13.html:174
msgid ""
"<pre>\n"
"? (remove 7 '(1 2 3 a b c t nil 7 0 7 7))\n"
"(1 2 3 A B C T NIL 0)\n"
"</pre> "
msgstr ""

#: in/chapter13.html:180
msgid ""
"<p>Keyword arguments are handled in the same way as for\n"
"<code>COUNT</code>. <code>REMOVE-IF</code> and\n"
"<code>REMOVE-IF-NOT</code> are also available; their keyword\n"
"arguments are handled in the same way as for <code>COUNT-IF</code>\n"
"and <code>COUNT-IF-NOT</code>."
msgstr ""
"<p>\n"
"Аргументы ключевые слова обрабатываются так же, как и для <code>COUNT</"
"code>.\n"
"<code>REMOVE-IF</code> и <code>REMOVE-IF-NOT</code>  доступны; их ключевые "
"аргументы обрабатываются таким же образом, как для  <code>COUNT-IF</code>\n"
"и <code>COUNT-IF-NOT</code>."

#: in/chapter13.html:183
msgid ""
"<p>A <code>:COUNT</code> keyword argument lets you limit the number\n"
"of matching elements to remove."
msgstr ""
"<p><code>:COUNT</code>  аргумент ключевое слово позволяет ограничить \n"
"количество удаляемых одинаковых элементов.\n"

#: in/chapter13.html:186
msgid ""
"<p><code>SUBSTITUTE</code> changes all occurrences of a specified\n"
"element in a sequence to another value."
msgstr ""
"<p><code>SUBSTITUTE</code>  заменяет все вхождения указанного элемента в\n"
" последовательности на другое значение."

#: in/chapter13.html:191
msgid ""
"<pre>\n"
"? (substitute '(q) 7 '(1 2 3 a b c t nil 7 0 7 7))\n"
"(1 2 3 A B C T NIL (Q) 0 (Q) (Q))\n"
"</pre> "
msgstr ""

#: in/chapter13.html:197
msgid ""
"<p>Keyword arguments are handled in the same way as for\n"
"<code>COUNT</code>. <code>SUBSTITUTE-IF</code> and\n"
"<code>SUBSTITUTE-IF-NOT</code> are also available; their keyword\n"
"arguments are handled in the same way as for <code>COUNT-IF</code>\n"
"and <code>COUNT-IF-NOT</code>."
msgstr ""
"<p>\n"
"Аргументы ключевые слова обрабатываются так же, как и для <code>COUNT</"
"code>. <code>SUBSTITUTE-IF</code> и <code>SUBSTITUTE-IF-NOT</code> доступны; "
"их \n"
"ключевые аргументы обрабатываются таким же образом, как\n"
" <code>COUNT-IF</code> и <code>COUNT-IF-NOT</code>."

#: in/chapter13.html:200
msgid ""
"<p>A <code>:COUNT</code> keyword argument lets you limit the number\n"
"of matching elements to substitute."
msgstr ""
"<p>A\n"
"аргумент ключевое слово <code>:COUNT</code> позволяет ограничить количество\n"
"совпадающих элементов подлежащих замене.\n"

#: in/chapter13.html:203
msgid ""
"<p><code>REMOVE-DUPLICATES</code> returns a copy of a sequence, modified\n"
"so that every element is different."
msgstr ""
"<p><code>REMOVE-DUPLICATES</code>  возвращает копию последовательности,\n"
"измененную таким образом, чтобы каждый элемент был уникальным."

#: in/chapter13.html:208
msgid ""
"<pre>\n"
"? (remove-duplicates '(1 2 3 a b c (1 2 3) f c g c h b i a j b a k a))\n"
"(1 2 3 (1 2 3) F G C H I J B K A)\n"
"</pre> "
msgstr ""

#: in/chapter13.html:212
msgid ""
"<p>The last copy of each identical element is retained in the result, "
"unless\n"
"you specify the keyword argument <code>:FROM-END T</code>, which causes the\n"
"first copy of each identical element to be retained."
msgstr ""
"<p>\n"
"Последняя копия каждого идентичного элемента сохраняется в результате, \n"
"если не указан аргумент ключевое слово:  <code>:FROM-END T</code>, который "
"приводит к сохранению первой копии каждого идентичного элемента."

#: in/chapter13.html:221
msgid ""
"<p><code>REMOVE-DUPLICATES</code> also accepts the same keyword\n"
"arguments as <code>COUNT</code>. The <code>:TEST</code> and\n"
"<code>:TEST-NOT</code> keyword arguments let you specify the\n"
"comparison predicate used to determine whether elements are\n"
"identical. The default predicate is <code>EQL</code>, which is true\n"
"for identical numbers and symbols. See <a\n"
"href=\"chapter17.html\">Chapter 17</a> for more information on\n"
"comparison predicates."
msgstr ""
"<p>\n"
"<code>REMOVE-DUPLICATES</code> также принимает те же аргументы \n"
"ключевые слова, что и <code>COUNT</code>. Аргументы ключевые слова\n"
"<code>:TEST</code> и <code>:TEST-NOT</code> позволяют указать предикат \n"
"сравнения, используемый для определения идентичности элементов. Предикат \n"
"по умолчанию - <code>EQL</code>, что верно для идентичных чисел и символов.\n"
"Дополнительную информацию о предикатах сравнения см. В \n"
"<a href=\"chapter17.html\">Главе 17</a>"

#: in/chapter13.html:223
msgid "<h2>DELETE, REMOVE-DUPLICATES, DELETE-DUPLICATES, and NSUBSTITUTE.</h2>"
msgstr "<h2>DELETE, REMOVE-DUPLICATES, DELETE-DUPLICATES, и NSUBSTITUTE.</h2>"

#: in/chapter13.html:227
msgid ""
"<p>Many of the functions in the preceeding section have destructive\n"
"counterparts.  The result of the destructive functions is identical,\n"
"but the input sequence may be destructively modified."
msgstr ""
"<p>\n"
"Многие функции в предшествующем разделе имеют разрушающие аналоги. \n"
"Результат разрушающих функций идентичен, но входная последовательность \n"
"может быть разрушена и изменена."

#: in/chapter13.html:239
msgid ""
"<pre>\n"
"Nondestructive    Destructive\n"
"--------------    -----------\n"
"REMOVE            DELETE\n"
"REMOVE-IF         DELETE-IF\n"
"REMOVE-IF-NOT     DELETE-IF-NOT\n"
"SUBSTITUTE        NSUBSTITUTE\n"
"SUBSTITUTE-IF     NSUBSTITUTE-IF\n"
"SUBSTITUTE-IF-NOT NSUBSTITUTE-IF-NOT\n"
"REMOVE-DUPLICATES DELETE-DUPLICATES\n"
"</pre> "
msgstr ""

#: in/chapter13.html:245
msgid ""
"<blockquote>\n"
"Remember that you <em>must not</em> depend upon the modification\n"
"of the input sequences. The only result guaranteed to be correct is\n"
"the return value of the function.\n"
"</blockquote> "
msgstr ""
"<blockquote>\n"
"Помните, что вы <em>не должны</em> зависеть от модификации входных\n"
"последовательностей. Единственный результат, гарантирующий правильность, - \n"
"это возвращаемое значение функции.\n"
"</blockquote> "

#: in/chapter13.html:247
msgid "<h2>FILL and REPLACE</h2> "
msgstr "<h2>FILL и REPLACE</h2> "

#: in/chapter13.html:253
msgid ""
"<p><code>FILL</code> destructively modifies a sequence, replacing\n"
"every element with a new value. It accepts keyword arguments for\n"
"<code>:START</code> and <code>:END</code> positions; these have the\n"
"same meaning as described earlier in this chapter.  The modified\n"
"sequence is returned as the value of <code>FILL</code>."
msgstr ""
"<p><code>FILL</code> разурушающе изменяет последовательность, заменяя \n"
"каждый элемент новым значением. Он принимает аргументы ключевые слова\n"
"для позиций <code>:START</code> и <code>:END</code>; они имеют то же \n"
"значение, что и описанные ранее в этой главе. Измененная \n"
"последовательность возвращается в виде значения <code>FILL</code>."

#: in/chapter13.html:262
msgid ""
"<pre>\n"
"? (fill (list 1 1 2 3 5 8) 7)\n"
"(7 7 7 7 7 7)\n"
"? (fill (list 1 1 2 3 5 8) '(a b))\n"
"((A B) (A B) (A B) (A B) (A B) (A B))\n"
"? (fill (list 1 1 2 3 5 8) 7 :start 2 :end 4)\n"
"(1 1 7 7 5 8)\n"
"</pre> "
msgstr ""

#: in/chapter13.html:267
msgid ""
"<p><code>REPLACE</code> copies elements from one sequence into another,\n"
"destructively modifying the target sequence. You can specify the range\n"
"of elements to use in both sequences; the shorter of the two ranges\n"
"determines the number of elements that is actually copied."
msgstr ""
"<p><code>REPLACE</code> копирует элементы из одной последовательности \n"
"в другую, разрушительно изменяя целевую последовательность. Вы можете \n"
"указать диапазон элементов для использования в обеих последовательностях; \n"
"более короткий из двух диапазонов определяет количество элементов, которые\n"
"фактически копируются."

#: in/chapter13.html:272
msgid ""
"<pre>\n"
"? (let ((a (list 1 2 3 4 5 6 7))\n"
"        (b (list 9 8 7 6 5 4 3)))\n"
"    (replace a b))"
msgstr ""

#: in/chapter13.html:277
msgid ""
"(9 8 7 6 5 4 3)\n"
"? (let ((a (list 1 2 3 4 5 6 7))\n"
"        (b (list 9 8 7 6 5 4 3)))\n"
"    (replace a b :start1 2))"
msgstr ""

#: in/chapter13.html:292
msgid ""
"(1 2 9 8 7 6 5)\n"
"? (let ((a (list 1 2 3 4 5 6 7))\n"
"        (b (list 9 8 7 6 5 4 3)))\n"
"    (replace a b :start1 2 :end1 5))\n"
"(1 2 9 8 7 6 7)\n"
"? (let ((a (list 1 2 3 4 5 6 7))\n"
"        (b (list 9 8 7 6 5 4 3)))\n"
"    (replace a b :start1 2 :end1 5 :start2 3))\n"
"(1 2 6 5 4 6 7)\n"
"? (let ((a (list 1 2 3 4 5 6 7))\n"
"        (b (list 9 8 7 6 5 4 3)))\n"
"    (replace a b :start1 2 :end1 5 :start2 3 :end2 4))\n"
"(1 2 6 4 5 6 7)\n"
"</pre> "
msgstr ""

#: in/chapter13.html:294
msgid ""
"<h2>Locating things in sequences: POSITION, FIND, SEARCH, and MISMATCH</h2>"
msgstr ""
"<h2>Поиск элементов в последовательностях: POSITION, FIND, SEARCH, и \n"
"MISMATCH</h2>"

#: in/chapter13.html:298
msgid ""
"<p><code>POSITION</code> searches a sequence for a matching element, and\n"
"returns the index of the first match or <code>NIL</code> if no matching \n"
"element is in the sequence."
msgstr ""
"<p>\n"
"<code>POSITION</code>  выполняет поиск в последовательности совпадающего \n"
"элемента и возвращает индекс первого совпадения или <code>NIL</code>, \n"
"если в последовательности нет совпадающего элемента."

#: in/chapter13.html:305
msgid ""
"<pre>\n"
"? (position #\\a \"This is all about you, isn't it?\")\n"
"8\n"
"? (position #\\! \"This is all about you, isn't it?\")\n"
"NIL\n"
"</pre> "
msgstr ""

#: in/chapter13.html:310
msgid ""
"<code>POSITION</code> accepts the same keyword arguments as\n"
"<code>COUNT</code> (described earlier in this chapter) and has (the\n"
"by now familar) variants <code>POSITION-IF</code> and\n"
"<code>POSITION-IF-NOT</code>."
msgstr ""
"<code>POSITION</code>  принимает те же ключевые аргументы, что и \n"
"<code>COUNT</code> (описанной ранее в этой главе), и имеет \n"
"(уже знакомые) варианты <code>POSITION-IF</code> и\n"
"<code>POSITION-IF-NOT</code>."

#: in/chapter13.html:319
msgid ""
"<p><code>FIND</code> is similar to <code>POSITION</code> except that\n"
"the matching element -- rather than its index in the sequence -- is\n"
"returned if there is a match. As with <code>POSITION</code>, you'll\n"
"find the usual keyword arguments (<code>:FROM-END</code>,\n"
"<code>:START</code>, <code>:END</code>, <code>:KEY</code> -- and for\n"
"the \"base\" function, <code>:TEST</code> and <code>:TEST-NOT</code>)\n"
"and function variants (i.e. <code>FIND-IF</code> and\n"
"<code>FIND-IF-NOT</code>)."
msgstr ""
"<p><code>FIND</code>  аналогичен <code>POSITION</code>, за исключением \n"
"того, что возвращает соответствующий элемент, а не его индекс в\n"
"последовательности, если есть совпадение. Как и в <code>POSITION</code>,\n"
"вы найдете привычные аргументы  (<code>:FROM-END</code>,\n"
"<code>:START</code>, <code>:END</code>, <code>:KEY</code> -- \n"
"и для \"базовых\" функций <code>:TEST</code> и <code>:TEST-NOT</code>)\n"
"и функций вариантов (т.е. <code>FIND-IF</code> и\n"
"<code>FIND-IF-NOT</code>)."

#: in/chapter13.html:326
msgid ""
"<pre>\n"
"? (find #\\a \"This is all about you, isn't it?\")\n"
"#\\a\n"
"? (find #\\! \"This is all about you, isn't it?\")\n"
"NIL\n"
"</pre> "
msgstr ""

#: in/chapter13.html:329
msgid ""
"<p><code>SEARCH</code> returns the starting position of one sequence\n"
"within another sequence, or <code>NIL</code> if no match is found."
msgstr ""
"<p><code>SEARCH</code>  возвращает начальную позицию одной \n"
"последовательности в другой последовательности или <code>NIL</code>, \n"
"если совпадение не найдено"

#: in/chapter13.html:336
msgid ""
"<pre>\n"
"? (search \"ab\" \"This is all about you, isn't it?\")\n"
"12\n"
"? (search \"not so\" \"This is all about you, isn't it?\")\n"
"NIL\n"
"</pre> "
msgstr ""

#: in/chapter13.html:343
msgid ""
"<p><code>SEARCH</code> accepts <code>:FROM-END</code>, <code>:KEY</code>,\n"
"<code>:TEST</code> and <code>:TEST-NOT</code> keyword arguments with the\n"
"usual interpretations. You can specify a range in the substring (the first\n"
"argument) using <code>:START1</code> and <code>:END1</code> keywords, and\n"
"in the target string using the <code>:START2</code> and <code>:END2</code> \n"
"keywords."
msgstr ""
"<p><code>SEARCH</code> принимает аргументы ключевые слова \n"
"<code>:FROM-END</code>, <code>:KEY</code>,\n"
"<code>:TEST</code> и <code>:TEST-NOT</code> интерпретирующиеся\n"
"как обычно. Вы можете указать диапазон в подстроке (первый\n"
"аргумент) используя ключевые слова <code>:START1</code> и \n"
"<code>:END1</code>, и в целевой строке, с помощью\n"
"ключевых слов  <code>:START2</code> и <code>:END2</code>."

#: in/chapter13.html:347
msgid ""
"<p><code>MISMATCH</code> is the functional complement to\n"
"<code>SEARCH</code> -- it returns the first position at which the\n"
"substring <em>fails</em> to match a portion of the target string."
msgstr ""
"<p><code>MISMATCH</code> это функциональное дополнение к \n"
"<code>SEARCH</code>, которое возвращает первую позицию, \n"
"в которой подстрока <em>не соответствует</em> части целевой \n"
"строки."

#: in/chapter13.html:356
msgid ""
"<pre>\n"
"? (mismatch \"banana\" \"bananananono\")\n"
"6\n"
"? (mismatch \".\" \"...hello\")\n"
"1\n"
"? (mismatch \".............\" \"...hello\")\n"
"3\n"
"</pre> "
msgstr ""

#: in/chapter13.html:358
msgid "<h2>SORT and MERGE round out the sequence toolkit</h2>"
msgstr ""
"<h2>SORT и MERGE завершают набор инструментов работающих \n"
"с последовательностями</h2>"

#: in/chapter13.html:361
msgid ""
"<p><code>SORT</code> destructively sorts a sequence; the order is\n"
"determined by a predicate which you supply."
msgstr ""
"<p><code>SORT</code>  разрушающе сортирует последовательность; \n"
"порядок определяется предикатом, который вы предоставляете."

#: in/chapter13.html:368
msgid ""
"<pre>\n"
"? (sort (list 9 3 5 4 8 7 1 2 0 6) #'&gt;)\n"
"(9 8 7 6 5 4 3 2 1 0)\n"
"? (sort (list 9 3 5 4 8 7 1 2 0 6) #'&lt;)\n"
"(0 1 2 3 4 5 6 7 8 9)\n"
"</pre> "
msgstr ""

#: in/chapter13.html:371
msgid ""
"<p>The input sequence is destructively modified -- you must use the\n"
"function result. "
msgstr ""
"<p>Входная последовательность разрушающе модифицирована - \n"
"вы должны использовать результат функции.\n"
" "

#: in/chapter13.html:374
msgid ""
"<p><code>STABLE-SORT</code> preserves the original order of\n"
"identical elements; <code>SORT</code> may not."
msgstr ""
"<p><code>STABLE-SORT</code>  сохраняет исходный порядок идентичных "
"элементов; \n"
"<code>SORT</code> не может этого сделать."

#: in/chapter13.html:377
msgid ""
"<p>You can sort structured elements (e.g. lists, structures) by using the\n"
"<code>:KEY</code> keyword argment to specify a key extraction function."
msgstr ""
"<p>Вы можете сортировать структурированные элементы (например, списки, "
"структуры)\n"
"с помощью аргумента ключевого слова <code>:KEY</code>, чтобы указать "
"функцию \n"
"извлечения ключа."

#: in/chapter13.html:380
msgid ""
"<p><code>MERGE</code> combines <em>two</em> input sequences into a\n"
"single result. Elements are interleaved according to the predicate."
msgstr ""
"<p><code>MERGE</code>  объединяет две входные последовательности \n"
"в один результат. Элементы чередуются в соответствии с предикатом."

#: in/chapter13.html:383
msgid ""
"Either input sequence may be destructively modified. You must\n"
"designate the type of the result."
msgstr ""
"Любая входная последовательность может быть разрушающе изменена. \n"
"Вы должны указать тип результата."

#: in/chapter13.html:394
msgid ""
"<pre>\n"
"? (merge 'vector (list 1 3 5 9 8) (vector 2 6 4 7 0) #'&gt;)\n"
"#(2 6 4 7 1 3 5 9 8 0)\n"
"? (merge 'list (list 1 3 5 9 8) (vector 2 6 4 7 0) #'&lt;)\n"
"(1 2 3 5 6 4 7 0 9 8)\n"
"? (merge 'vector (list 1 3 5 8 9) (vector 0 2 4 6 7) #'&gt;)\n"
"#(1 3 5 8 9 0 2 4 6 7)\n"
"? (merge 'list (list 1 3 5 8 9) (vector 0 2 4 6 7) #'&lt;)\n"
"(0 1 2 3 4 5 6 7 8 9)\n"
"</pre> "
msgstr ""

#: in/chapter13.html:400
msgid ""
"<p>Note that -- in the general case -- <code>MERGE</code> does\n"
"<em>not</em> sort the catenation of its arguments. The predicate is\n"
"used to select from one or the other of the input sequences; input\n"
"from the selected sequence continues until the sense of the\n"
"predicate changes. Look at the examples until you understand this."
msgstr ""
"<p>Обратите внимание , что - в общем случае - <code>MERGE</code>\n"
"не сортирует цепочку своих аргументов. Предикат используется для \n"
"выбора из одной или другой входной последовательности; ввод из \n"
"выбранной последовательности продолжается до тех пор, пока смысл \n"
"предиката не изменится. Посмотрите на примеры, пока вы не поймете это."

#: in/chapter13.html:403
msgid ""
"<p><code>MERGE</code> accepts a <code>:KEY</code> keyword argument\n"
"having the conventional meaning."
msgstr ""
"<p><code>MERGE</code> принимает аргумент ключевое слово <code>:KEY</code> \n"
"имеющий привычное значение."

#: in/chapter13.html:416
msgid ""
"<hr>\n"
"<div align=\"center\">\n"
"<a href=\"contents.html\">Contents</a> | <a href=\"cover.html\">Cover</a> "
"<br> \n"
"<a href=\"chapter12.html\">Chapter 12</a> | Chapter 13 | <a href=\"chapter14."
"html\">Chapter 14</a> \n"
"</div>\n"
"<hr>\n"
"<address>\n"
"Copyright &copy; 1995-2001, David B. Lamkins<br>\n"
"All Rights Reserved Worldwide<br>\n"
"<br>\n"
"This book may not be reproduced without the written consent of its author.  "
"Online distribution is restricted to the author's site.\n"
"</address> \n"
"</body> </html> "
msgstr ""
