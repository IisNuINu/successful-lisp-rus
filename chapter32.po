#
# NuINu <don't@send.my>, 2020.
#
#. extracted from in/chapter32.html
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-04-19 13:51+0300\n"
"PO-Revision-Date: 2020-06-12 20:02+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter32.html:5
msgid ""
"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/"
"html4/strict.dtd\">\n"
"<html><head>\n"
"<title>Successful Lisp - Chapter 32</title>\n"
"</head> "
msgstr ""
"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/"
"html4/strict.dtd\">\n"
"<html><head>\n"
"<META http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n"
"<title>Successful Lisp - Chapter 32</title>\n"
"</head> "

#: in/chapter32.html:8
msgid ""
"<body bgcolor=\"white\" text=\"black\">\n"
"<h1>Chapter 32 - Dark Corners and Curiosities</h1> "
msgstr ""
"<body bgcolor=\"white\" text=\"black\">\n"
"<h1>Глава 32 - Темные закоулки и Диковинки</h1> "

#: in/chapter32.html:12
msgid ""
"<P>This chapter is almost at the end of our survey of Lisp.\n"
"Here, we'll examine some Lisp features that are newer, \n"
"unstandardized, experimental, or controversial.</P>"
msgstr ""
"<P>\n"
"Эта глава почти завершает наше исследование Лиспа. Здесь мы рассмотрим \n"
"некоторые функции Lisp, которые являются более новыми, \n"
"нестандартизированными, экспериментальными или спорными.\n"
"</P>"

#: in/chapter32.html:14
msgid "<h2>Extended LOOP: Another little language</h2>"
msgstr "<h2>Расширенный LOOP: еще один маленький язык</h2>"

#: in/chapter32.html:20
msgid ""
"<p><a href=\"chapter05.html\">Chapter 5</a> described several iterative\n"
"control forms: <code>DO</code>, <code>DOTIMES</code>, <code>DOLIST</code>,\n"
"and a simple <code>LOOP</code>.  We also saw that <code>FORMAT</code> \n"
"(<a href=\"chapter24.html\">Chapter 24</a>) has its own control constructs\n"
"for iteration."
msgstr ""
"<p>\n"
"В <a href=\"chapter05.html\">Главе 5</a> описано несколько итерационных \n"
"форм управления: <code>DO</code>, <code>DOTIMES</code>, <code>DOLIST</"
"code>,\n"
"и простой <code>LOOP</code>. Мы также видели, что <code>FORMAT</code> \n"
"(<a href=\"chapter24.html\">Глава 24</a>) имеет свои собственные \n"
"управляющие конструкции для итерации.\n"

#: in/chapter32.html:30
msgid ""
"<p>Recursion is a useful tool for describing (and implementing) some\n"
"algorithms.  But in many cases it's easier to write efficient iterative\n"
"code than it is to write efficient recursive code.  In chapters \n"
"<a href=\"chapter04.html#tail-recursion\">4</a> \n"
"and <a href=\"chapter28.html#efficiency\">28</a> we saw how to write\n"
"tail-recursive code, and learned that Lisp is <em>not</em> required\n"
"to optimize tail calls.  Ironically, iteration is very important in\n"
"this implementation of a language originally conceived as a \n"
"<a href=\"chapter33.html#mccarthy60\">notation for recursive functions</a>."
msgstr ""
"<p>\n"
"Рекурсия - это полезный инструмент для описания (и реализации) некоторых \n"
"алгоритмов. Но во многих случаях проще написать эффективный итерационный "
"код,\n"
"чем эффективный рекурсивный. В главах <a href=\"chapter04.html#tail-recursion"
"\">4</a> \n"
"и <a href=\"chapter28.html#efficiency\">28</a> мы видели, как писать код с "
"хвостой\n"
"рекурсией, и узнали, что Lisp не обязательно оптимизирует хвостовые "
"вызовы. \n"
"Как ни странно, итерация очень важна в этой реализации языка, изначально \n"
"задуманного как нотация для рекурсивных функций."

#: in/chapter32.html:36
msgid ""
"<p>An <em>extended</em> loop facility was introduced late in the "
"specification\n"
"of Common Lisp.  Extended loop, like <code>FORMAT</code> control strings, "
"breaks\n"
"away from the Lisp tradition of a simple, consistent syntax.  Extended loop\n"
"uses keywords to specify initialization, actions and termination "
"conditions.\n"
"Here are a few examples:"
msgstr ""
"<p>\n"
"Средство расширенного цикла было введено в конце спецификации Common Lisp. \n"
"Расширенный цикл, как и строки управления <code>FORMAT</code>, отрывается \n"
"от традиции Lisp простого и последовательного синтаксиса. Расширенный цикл \n"
"использует ключевые слова для указания условий инициализации, действий и \n"
"завершения. Вот несколько примеров:"

#: in/chapter32.html:42
msgid ""
"<pre>\n"
"<i>;; Sum the integers from 1 to 100</i> \n"
"? (loop for n from 1 to 100\n"
"        sum n)\n"
"5050"
msgstr ""

#: in/chapter32.html:49
msgid ""
"<i>;; Compute factorial 10 iteratively</i> \n"
"? (loop for n from 1 to 10\n"
"        with result = 1\n"
"        do (setq result (* result n))\n"
"        finally return result)\n"
"3628800"
msgstr ""

#: in/chapter32.html:56
msgid ""
"<i>;; Gather the even numbers from a list</i> \n"
"? (loop for item in '(1 5 8 9 7 2 3)\n"
"        when (evenp item)\n"
"        collect item)\n"
"(8 2)\n"
"</pre> "
msgstr ""

#: in/chapter32.html:63
msgid ""
"<p>Extended loop inspires heated disagreements among Lisp users.  Its\n"
"detractors point out that the behavior is underspecified for complex\n"
"combinations of options, while its supporters point out that extended\n"
"loop forms are easier to read than most <code>DO</code> forms for\n"
"simple operations.  You should heed the advice of both camps: use\n"
"extended loop to improve readability of simple looping operations."
msgstr ""
"<p>\n"
"Расширенный цикл вызывает горячие разногласия среди пользователей Lisp. \n"
"Его недоброжелатели указывают, что поведение недостаточно специфично \n"
"для сложных комбинаций вариантов, в то время как его сторонники указывают, \n"
"что формы расширенного цикла легче читать, чем большинство форм для "
"простых \n"
"операций. Вы должны прислушаться к советам обоих лагерей: используйте \n"
"расширенный цикл для улучшения читаемости простых операций цикла."

#: in/chapter32.html:65
msgid "<h2>TAGBODY: GO if you must</h2>"
msgstr "<h2>TAGBODY: GO если нужно</h2>"

#: in/chapter32.html:72
msgid ""
"<p>Ever since the structured programming revolution of the \n"
"1970's, programmers and language designers alike have been \n"
"apologetic about the <em>GOTO</em> construct.  Yet there\n"
"are rare cases where a well-placed <em>GOTO</em>, used\n"
"with careful consideration, is the clearest way to structure the\n"
"control flow of an algorithm."
msgstr ""
"<p>\n"
"Начиная с революции структурированного программирования 1970-х годов, \n"
"программисты и языковые дизайнеры одинаково апологетично относились \n"
"к конструкции <em>GOTO</em>. Однако есть редкие случаи, когда хорошо \n"
"поставленный <em>GOTO</em>, используемый с тщательным рассмотрением, \n"
"является самым ясным способом структурировать поток управления алгоритмом."

#: in/chapter32.html:79
msgid ""
"<p>Lisp retains a <em>GOTO</em> as a <code>GO</code> form, but it must be\n"
"used within the lexical scope of a <code>TAGBODY</code> form. A\n"
"<code>TAGBODY</code> may contain Lisp forms and symbols. The forms are\n"
"evaluated, while the symbols (which in other forms might be evaluated for\n"
"their lexical binding or <code>SYMBOL-VALUE</code>) are simply used as\n"
"labels to which a <code>GO</code> form may transfer control."
msgstr ""
"<p>\n"
"Lisp сохраняет <em>GOTO</em> как форму <code>GO</code>,но он \n"
"должен использоваться в лексической области формы <code>TAGBODY</code>. \n"
"<code>TAGBODY</code> может содержать формы и символы Lisp. Формы \n"
"вычисляются, в то время как символы (которые в других формах могут \n"
"быть вычислены по их лексической привязке или <code>SYMBOL-VALUE</code>) \n"
"просто используются в качестве меток, к которым форма <code>GO</code> "
"может \n"
"передать управление."

#: in/chapter32.html:81
msgid "<h2>Processes & Stack Groups: Juggling multiple tasks</h2>"
msgstr ""
"<h2>Процессы и стековые группы: Манипулирование несколькими задачами</h2>"

#: in/chapter32.html:85
msgid ""
"<p>Leading-edge Lisp systems on dedicated hardware, and more recently on "
"the\n"
"Unix platform, have implemented a feature called \"lightweight processes.\" "
"In the\n"
"C world these are known as \"threads.\" "
msgstr ""
"<p>\n"
"Передовые системы Lisp на выделенном оборудовании, а в последнее время и \n"
"на платформе Unix, реализовали функцию под названием "
"\"легковесные(lightweight) \n"
"процессы.- В мире С они известны как \"нити(threads)\"."

#: in/chapter32.html:92
msgid ""
"<P>Lightweight processes allow you to write pieces of code which share\n"
"the CPU's time along with all of the global variables in your LISP\n"
"environment. Although this is a limited form of multitasking,\n"
"lacking protection between processes, it is very useful for handling\n"
"computations which must run \"in the background\" or in response to \n"
"asynchronous events."
msgstr ""
"<P>\n"
"Легковесные процессы позволяют вам писать фрагменты кода, которые \n"
"разделяют время процессора вместе со всеми глобальными переменными \n"
"в вашей среде LISP. Хотя это ограниченная форма многозадачности, \n"
"лишенная защиты между процессами, она очень полезна для обработки \n"
"вычислений, которые должны выполняться \"в фоновом режиме\" или в \n"
"ответ на асинхронные события."

#: in/chapter32.html:100
msgid ""
"<p>In the last few years, low-cost Lisp systems have started to include a\n"
"process facility. Of all the vendors of low-cost Lisp system, Digitool was\n"
"the first to include processes in its product. Starting with its 4.0/3.1\n"
"release, MCL includes a complete implementation of lightweight processes\n"
"including a full range of control, synchronization, and communication\n"
"abstractions. MCL's process API is very close to the API used on the Lisp\n"
"machines. I'll use MCL's API to illustrate the rest of this section."
msgstr ""
"<p>\n"
"В последние несколько лет недорогие системы Lisp начали включать в \n"
"себя технологическое оборудование. Из всех поставщиков по низкой \n"
"стоимости системы Лисп, Digitool был первым, которая включала процессы \n"
"в своем продукте. Начиная с версии 4.0/3.1, MCL включает в себя полную \n"
"реализацию облегченных процессов, включая полный спектр абстракций "
"управления,\n"
"синхронизации и коммуникации. Процессный API MCL очень близок к API, "
"используемому \n"
"на машинах Lisp. Я буду использовать API MCL, чтобы проиллюстрировать "
"остальную \n"
"часть этого раздела.\n"

#: in/chapter32.html:110
msgid ""
"<p>The MCL processes are fully preemptive -- you can set both priority\n"
"and time slice (the \"quantum\") for each process. Each process\n"
"can have private variables simply by using local variables in the\n"
"process run function (i.e., Lisp \"closures\"). As you'll probably\n"
"have a need to access shared data as well, the MCL process facility\n"
"provides locks (\"mutexes\") to ensure access to critical data by\n"
"only one process at a time; this is especially useful when multiple\n"
"fields of a complex structure must be updated in a single operation\n"
"(\"atomically\")."
msgstr ""
"<p>\n"
"Процессы MCL полностью приоритетны - вы можете установить как приоритет, \n"
"так и временной срез (\"Квант\") для каждого процесса. Каждый процесс "
"может \n"
"иметь частные переменные, просто используя локальные переменные в функции \n"
"запуска процесса (например, Lisp \"замыкания\"). Поскольку вам, вероятно, \n"
"также потребуется получить доступ к общим данным, средство обработки MCL \n"
"предоставляет блокировки (\"мьютексы\") для обеспечения доступа к "
"критическим \n"
"данным только одним процессом одновременно; это особенно полезно, когда \n"
"несколько полей сложной структуры должны быть обновлены в одной операции \n"
"(\"атомарно\")."

#: in/chapter32.html:112
msgid "<a name=\"dining-philosophers\"></a>"
msgstr ""

#: in/chapter32.html:124
msgid ""
"<p>The following code implements a solution to \n"
"<a href=\"chapter33.html#dijkstra68\">Dijkstra's</a> \"dining\n"
"philosophers\" problem using MCL processes and locks. In case you're\n"
"not familiar with this, imagine a group of philosophers seated\n"
"around a round table. Each philosopher has a plate of food. The food\n"
"can only be eaten if a philosopher holds a fork in each hand. There\n"
"is a fork between each pair of philosophers, so there are exactly as\n"
"many forks as there are philosophers. The objective is to make the\n"
"philosophers behave so that they all get a fair chance to eat. The\n"
"classic solution imposes a protocol on how resources (forks) are\n"
"acquired, in order to prevent deadlock (starvation)."
msgstr ""
"<p>\n"
"Следующий код реализует решение проблемы \"обедающих философов\" Дейкстры \n"
"с использованием процессов MCL и блокировок. Если вы не знакомы с этим, \n"
"представьте себе группу философов, сидящих за круглым столом. У каждого \n"
"философа есть тарелка с едой. Еда может быть съедена только в том случае, \n"
"если философ держит вилку в каждой руке. Между каждой парой философов \n"
"есть вилка, так что вилок ровно столько же, сколько и философов. Цель \n"
"состоит в том, чтобы заставить философов вести себя так, чтобы они все\n"
"получили справедливый шанс поесть. Классическое решение накладывает \n"
"протокол на то, как приобретаются ресурсы (форки), чтобы предотвратить \n"
"тупик (голодание)."

#: in/chapter32.html:129
msgid ""
"<pre>\n"
"(defstruct philosopher\n"
"  (amount-eaten 0)\n"
"  (task nil))"
msgstr ""

#: in/chapter32.html:145
msgid ""
"(defmacro acquire-lock-or-skip (lock post-acquire pre-release &amp;body "
"body)\n"
"  `(progn\n"
"     <i>;; Random sleep makes the output more interesting</i> \n"
"     <i>;; by introducing variability into the order of</i> \n"
"     <i>;; execution.  This is a simple way of simulating</i> \n"
"     <i>;; the nondeterminacy that would result from having</i> \n"
"     <i>;; additional processes compete for CPU cycles.</i> \n"
"     (sleep (random 5))\n"
"     (unless (lock-owner ,lock)\n"
"       (process-lock ,lock)\n"
"       ,post-acquire\n"
"       (unwind-protect\n"
"         (progn ,@body)\n"
"         ,pre-release\n"
"         (process-unlock ,lock)))))"
msgstr ""

#: in/chapter32.html:148
msgid ""
"(let ((philosophers #())\n"
"      (philosophers-output t))"
msgstr ""

#: in/chapter32.html:198
msgid ""
"  (defun dining-philosophers (number-of-philosophers &amp;optional (stream "
"t))\n"
"    (unless (equalp philosophers #())\n"
"      (stop-philosophers))\n"
"    (assert (&gt; number-of-philosophers 1) (number-of-philosophers))\n"
"    (setq philosophers-output stream)\n"
"    (format philosophers-output\n"
"            \"~2&amp;Seating ~D philosophers for dinner.~%\"\n"
"            number-of-philosophers)\n"
"    (force-output philosophers-output)\n"
"    (flet ((announce-acquire-fork (who fork)\n"
"             (format philosophers-output \n"
"                     \"~&amp;Philosopher ~A has picked up ~A.~%\" \n"
"                     who (lock-name fork)))\n"
"           (announce-release-fork (who fork)\n"
"             (format philosophers-output \n"
"                     \"~&amp;Philosopher ~A is putting down ~A.~%\" \n"
"                     who (lock-name fork)))\n"
"           (eat (who)\n"
"             (format philosophers-output \n"
"                     \"~&amp;Philosopher ~A is EATING bite ~D.~%\"\n"
"                     who (incf (philosopher-amount-eaten (aref philosophers "
"who))))))\n"
"      (flet ((philosopher-task (who left-fork right-fork)\n"
"               (loop\n"
"                 (acquire-lock-or-skip left-fork\n"
"                                       (announce-acquire-fork who left-"
"fork)\n"
"                                       (announce-release-fork who left-"
"fork)\n"
"                   (acquire-lock-or-skip right-fork \n"
"                                         (announce-acquire-fork who right-"
"fork)\n"
"                                         (announce-release-fork who right-"
"fork)\n"
"                     (eat who)))\n"
"                 (force-output stream)\n"
"                 (process-allow-schedule))))\n"
"        (let ((forks (make-sequence 'vector number-of-philosophers)))\n"
"          (dotimes (i number-of-philosophers)\n"
"            (setf (aref forks i) (make-lock (format nil \"fork ~D\" i))))\n"
"          (flet ((left-fork (who)\n"
"                   (aref forks who))\n"
"                 (right-fork (who)\n"
"                   (aref forks (mod (1+ who) number-of-philosophers))))\n"
"            (setq philosophers (make-sequence 'vector number-of-"
"philosophers))\n"
"            (dotimes (i number-of-philosophers)\n"
"              (setf (aref philosophers i)\n"
"                    (make-philosopher\n"
"                     :task (process-run-function (format nil \"Philosopher-~D"
"\" i)\n"
"                                                 #'philosopher-task\n"
"                                                 i \n"
"                                                 (left-fork i) \n"
"                                                 (right-fork i)))))))))\n"
"    (values))"
msgstr ""

#: in/chapter32.html:210
msgid ""
"  (defun stop-philosophers ()\n"
"    (dotimes (i (length philosophers))\n"
"      (process-kill (philosopher-task (aref philosophers i))))\n"
"    (format philosophers-output \n"
"            \"~&amp;Dinner is finished. Amounts eaten: {~{~D~^, ~}}~2%\" \n"
"            (map 'list #'philosopher-amount-eaten philosophers))\n"
"    (force-output philosophers-output)\n"
"    (setq philosophers #())\n"
"    (values))\n"
"  )\n"
"</pre> "
msgstr ""

#: in/chapter32.html:214
msgid ""
"<p>If you evaluate <code>(dining-philosophers 5)</code> and look\n"
"through the actions of any one philosopher, you'll see her\n"
"repeatedly do one of two things:"
msgstr ""
"<p>\n"
"Если вы вычисляете <code>(dining-philosophers 5)</code> и просматриваете \n"
"действия любого одного философа, вы увидите, что он неоднократно делает \n"
"одну из двух вещей:"

#: in/chapter32.html:220
msgid ""
"<ol>\n"
"<li>pick up a fork (the left one) and put it down again because \n"
"    the other (right) fork was in use, or\n"
"<li>pick up each fork (left, then right), eat, then put down the forks.\n"
"</ol> "
msgstr ""
"<ol>\n"
"<li>берет вилку(левую) и снова кладет ее, потому что другая (правая) вилка "
"была в употреблении, или\n"
"<li>возьмите каждую вилку (левую, затем правую), ест, а затем кладет вилки.\n"
"</ol> "

#: in/chapter32.html:225
msgid ""
"<p>When you evaluate <code>(stop-philosophers)</code> you'll see a\n"
"list of how many times each philosopher has eaten. These numbers\n"
"will be fairly close to each other, illustrating the fairness of the\n"
"algorithm."
msgstr ""
"<p>\n"
"Когда вы вычисляете <code>(stop-philosophers)</code>, вы увидите список "
"того, \n"
"сколько раз каждый философ ел. Эти числа будут достаточно близки друг к "
"другу, \n"
"иллюстрируя справедливость алгоритма."

#: in/chapter32.html:228
msgid ""
"<p>MCL also exposes a ``stack group'' abstraction, which is useful\n"
"for implementing coroutines:"
msgstr ""
"<p>\n"
"MCL также предоставляет абстракцию \"стековой группы\", которая полезна \n"
"для реализации сопрограмм:"

#: in/chapter32.html:239
msgid ""
"<pre>\n"
"<i>;;; Main routine F-FOO</i> \n"
"(defun f-foo ()\n"
"  (print 'foo-1)\n"
"  (funcall sg-bar nil)        <i>; call 1 to coroutine</i> \n"
"  (print 'foo-2)\n"
"  (funcall sg-bar nil)        <i>; call 2 to coroutine</i> \n"
"  (print 'foo-3)\n"
"  (funcall sg-bar nil)        <i>; call 3 to coroutine</i> \n"
"  nil)"
msgstr ""

#: in/chapter32.html:242
msgid ""
"<i>;;; Create a stack group for the coroutine.</i> \n"
"(defvar sg-bar (make-stack-group \"bar\"))"
msgstr ""

#: in/chapter32.html:252
msgid ""
"<i>;;; Coroutine F-BAR</i> \n"
"(defun f-bar ()\n"
"  (print 'bar-1)              <i>; do this for call 1</i> \n"
"  (stack-group-return nil)    <i>; return from call 1</i> \n"
"  (print 'bar-2)              <i>; do this for call 2</i> \n"
"  (stack-group-return nil)    <i>; return from call 2</i> \n"
"  (print 'bar-3)              <i>; do this for call 3</i> \n"
"  (stack-group-return nil)    <i>; return from call 3</i> \n"
"  nil)"
msgstr ""

#: in/chapter32.html:260
msgid ""
"<i>;;; Initialization and startup</i> \n"
"(defun run-coroutines ()\n"
"  ;; Initialize the coroutine\n"
"  (stack-group-preset sg-bar #'f-bar)\n"
"  ;; Start main coroutine\n"
"  (f-foo))\n"
"</pre> "
msgstr ""

#: in/chapter32.html:263
msgid ""
"<p>When you run the main routine, its execution is interleaved with\n"
"the coroutine:"
msgstr ""
"<p>\n"
"Когда вы запускаете основную процедуру, ее выполнение чередуется \n"
"с сопрограммой:"

#: in/chapter32.html:274
msgid ""
"<pre>\n"
"? (run-coroutines)\n"
"FOO-1 \n"
"BAR-1 \n"
"FOO-2 \n"
"BAR-2 \n"
"FOO-3 \n"
"BAR-3 \n"
"NIL\n"
"</pre> "
msgstr ""

#: in/chapter32.html:278
msgid ""
"<p>You can easily run any function within a separate lightweight\n"
"process, allowing other computation, compilation, editing, etc. to\n"
"happen concurrently:"
msgstr ""
"<p>\n"
"Вы можете легко запускать любую функцию в рамках отдельного легковесного \n"
"процесса, позволяя выполнять другие вычисления, компиляцию, редактирование \n"
"и т. д. чтобы это просходило одновременно:"

#: in/chapter32.html:287
msgid ""
"<pre>\n"
"(process-run-function \"Annoy me\" \n"
"                      #'(lambda (delay)\n"
"                          (loop \n"
"                            (sleep delay)\n"
"                            (ed-beep)))\n"
"                      5)\n"
"</pre> "
msgstr ""

#: in/chapter32.html:290
msgid "<h2>Series: Another approach to iteration and filtering</h2>"
msgstr "<h2>Ряды: Еще один подход к итерации и фильтрации</h2>"

#: in/chapter32.html:297
msgid ""
"<p>Series were formally introduced with the printing of \n"
"<a href=\"chapter33.html#cltl2\">Common Lisp: The Language (2nd ed)</a> "
"(also\n"
"known as CLtL2), but were not adopted as part of the ANSI Common Lisp\n"
"standard. Still, some Lisp vendors include series in their product because\n"
"customers came to depend upon it during the time between the publication\n"
"of CLtL2 and the ANSI Specification."
msgstr ""
"<p>\n"
"Ряды были официально введены с выходом из печати \n"
"<a href=\"chapter33.html#cltl2\">Common Lisp: The Language (2nd ed)</a> \n"
"(также известного как CLtL2), но не были приняты в качестве части \n"
"стандарта ANSI Common Lisp. Тем не менее, некоторые поставщики Lisp \n"
"включают ряды в свой продукт, потому что клиенты стали \n"
"зависеть от них в период между публикацией CLtL2 и спецификацией ANSI."

#: in/chapter32.html:302
msgid ""
"<p>Series combine the behaviors of sequences, streams and loops.  Using\n"
"series, you can write iterative code using a functional notation.  Control\n"
"is achieved by selecting or filtering elements as they pass through a \n"
"<em>series</em> of filters and operators."
msgstr ""
"<p>\n"
"Ряды объединяют поведение последовательностей, потоков и циклов. \n"
"Используя ряды, вы можете написать итерационный код, используя \n"
"функциональную нотацию. Управление достигается путем выбора или \n"
"фильтрации элементов по мере их прохождения через ряд(<em>series</em>) \n"
"фильтров и операторов.\n"

#: in/chapter32.html:304
msgid ""
"<p>The best place to find information and examples is in Appendix A of CLtL2."
msgstr ""
"<p>\n"
"Лучшее место для поиска информации и примеров находится в приложении А \n"
"к CLtL2."

#: in/chapter32.html:317
msgid ""
"<hr>\n"
"<div align=\"center\">\n"
"<a href=\"contents.html\">Contents</a> | <a href=\"cover.html\">Cover</a> "
"<br> \n"
"<a href=\"chapter31.html\">Chapter 31</a> | Chapter 32 | <a href=\"chapter33."
"html\">Chapter 33</a> \n"
"</div>\n"
"<hr>\n"
"<address>\n"
"Copyright &copy; 1995-2001, David B. Lamkins<br>\n"
"All Rights Reserved Worldwide<br>\n"
"<br>\n"
"This book may not be reproduced without the written consent of its author.  "
"Online distribution is restricted to the author's site.\n"
"</address> \n"
"</body> </html> "
msgstr ""
