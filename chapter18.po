#
# NuINu <don't@send.my>, 2020.
#
#. extracted from in/chapter18.html
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-04-19 13:50+0300\n"
"PO-Revision-Date: 2020-05-31 15:21+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter18.html:5
msgid ""
"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/"
"html4/strict.dtd\">\n"
"<html><head>\n"
"<title>Successful Lisp - Chapter 18</title>\n"
"</head> "
msgstr ""

#: in/chapter18.html:8
msgid ""
"<body bgcolor=\"white\" text=\"black\">\n"
"<h1>Chapter 18 - Very Logical, Indeed...</h1> "
msgstr ""
"<body bgcolor=\"white\" text=\"black\">\n"
"<h1>Глава 18 - Действительно, Очень Логично...</h1> "

#: in/chapter18.html:14
msgid ""
"<P>Now it's time to look at things having to do with boolean (true and\n"
"false) logic. We'll learn about common logical functions, and conditional \n"
"evaluation. If you're a bit twiddler, this chapter should warm your\n"
"heart: we'll introduce bit manipulation functions, bit vectors, and \n"
"generalized byte manipulation. "
msgstr ""
"<P>\n"
"Теперь пришло время взглянуть на вещи, имеющие отношение к булевой логике \n"
"(истинна/true и ложь/false). Мы узнаем об общих логических функциях и "
"условном\n"
"вычислении. Если вы ловкий в манипуляции с битами, эта глава должна согреть "
"ваше сердце: \n"
"мы представим функции битовой манипуляции, битовые векторы и обобщенную "
"байтовую \n"
"манипуляцию."

#: in/chapter18.html:16
msgid "<h2>AND and OR evaluate only as much as they need</h2>"
msgstr "<h2>Исполнение AND и OR, только столько, сколько им нужно</h2>"

#: in/chapter18.html:22
msgid ""
"<p><code>AND</code> and <code>OR</code> are macros in Common Lisp.\n"
"This means that they have control over when (and <em>if</em>) their\n"
"arguments get evaluated. <code>AND</code> and <code>OR</code> take\n"
"advantage of this ability: they stop evaluating their arguments as\n"
"soon as they determine an answer."
msgstr ""
"<p>\n"
"<code>AND</code> и <code>OR</code> - это макросы в Common Lisp. Это "
"означает, \n"
"что они имеют контроль над тем, когда (и если) их аргументы вычисляются. \n"
" <code>AND</code> и <code>OR</code> пользуются этой способностью: они "
"перестают \n"
"вычислять свои аргументы, как только будет определен ответ."

#: in/chapter18.html:32
msgid ""
"<p>Consider <code>AND</code>: it evaluates its arguments, starting\n"
"with the leftmost, only as long as each argument evaluates to a true\n"
"(i.e. not <code>NIL</code>) value. As soon as <code>AND</code>\n"
"evaluates the leftmost false (<code>NIL</code>) argument, its work\n"
"is done -- the result will be <code>NIL</code> no matter how many\n"
"more true arguments it evaluates, so <code>AND</code> just returns\n"
"<code>NIL</code> without evaluating any more of its arguments. (Think\n"
"of this as a \"one strike and you're out\" policy.)  <code>AND</code> "
"returns\n"
"true only if all of its arguments evaluate to a true value."
msgstr ""
"<p>\n"
"Рассмотрим <code>AND</code>:  он вычисляет свои аргументы, начиная \n"
"с крайнего левого, только до тех пор, пока каждый аргумент \n"
"вычисляется в истинное (т. е. не <code>NIL</code>) значение. \n"
"Как только <code>AND</code> вычислит самый левый аргумент ложным(false/"
"NIL), \n"
"его работа выполнена - результат будет равен <code>NIL</code> независимо "
"от \n"
"того, сколько еще истинных аргументов он должен вычислить, поэтому \n"
"<code>AND</code> просто возвращает <code>NIL</code>, не вычисляя больше \n"
"ни одного из своих аргументов. (Думайте об этом как о политике \n"
"\"один удар-и вы вне игры\".) <code>AND</code> возвращает true только в \n"
"том случае, если все его аргументы имеют значение true."

#: in/chapter18.html:37
msgid ""
"<p>In fact, <code>AND</code> returns either <code>NIL</code> (if one of\n"
"its arguments evaluates to <code>NIL</code>) or the non-<code>NIL</code> \n"
"value of its rightmost argument. Some Lisp programmers take advantage of\n"
"this to treat <code>AND</code> as a simple conditional."
msgstr ""
"<p>\n"
"Фактически, <code>AND</code> возвращает либо <code>NIL</code> (если один "
"из \n"
"его аргументов равен <code>NIL</code>), либо не-<code>NIL</code> значение "
"его \n"
"самого правого аргумента. Некоторые Лисп-программисты пользуются этим "
"преимуществом, \n"
"чтобы рассматривать <code>AND</code> как простое условное выражение."

#: in/chapter18.html:51
msgid ""
"<pre>\n"
"? (defun safe-elt (sequence index)\n"
"    (and (< -1 index (length sequence)) <i>; guard condition</i> \n"
"         (values (elt sequence index) t)))\n"
"SAFE-ELT\n"
"? (safe-elt #(1 2 3) 3)\n"
"NIL\n"
"? (elt #(1 2 3) 3)\n"
"Error: index out of bounds\n"
"? (safe-elt #(1 2 3) 2)\n"
"3\n"
"T\n"
"</pre> "
msgstr ""

#: in/chapter18.html:57
msgid ""
"<p><code>OR</code> also evaluates only enough arguments to determine\n"
"its result: it evaluates arguments, starting with the leftmost, so\n"
"long as they evaluate to <code>NIL</code>. The first\n"
"non-<code>NIL</code> result is returned as <code>OR</code>'s value;\n"
"arguments further to the right are not evaluated."
msgstr ""
"<p>\n"
"<code>OR</code> также вычисляет только необходимое число аргументов, \n"
"чтобы определить его результат: он вычисляет аргументы, начиная с \n"
"крайнего левого, до тех пор, пока они вычсляются в <code>NIL</code>. \n"
"Первый не-<code>NIL</code> результат возвращается в виде значения \n"
"<code>OR</code>; аргументы далее (правее) не вычисляются."

#: in/chapter18.html:62
msgid ""
"<p>One caution is in order about <code>AND</code> and <code>OR</code>.\n"
"Because they are macros, and not functions, they can not be used for\n"
"mapping (see <a href=\"chapter12.html\">Chapter 12</a>). Use the predicate\n"
"mapping functions (<code>SOME</code>, <code>EVERY</code>, etc.) instead."
msgstr ""
"<p>\n"
"Одно предостережение - это насчет <code>AND</code> и <code>OR</code>. \n"
"Поскольку они являются макросами, а не функциями, их нельзя использовать \n"
"для функций отображения (см. <a href=\"chapter12.html\">Главу 12</a>). \n"
"Вместо них, используйте функции отображения предикатов  \n"
"(<code>SOME</code>, <code>EVERY</code> и т.д)."

#: in/chapter18.html:64
msgid "<h2>Bits, bytes, and Boole</h2>"
msgstr "<h2>Биты(Bits), байты(bytes), и функция boole</h2>"

#: in/chapter18.html:72
msgid ""
"<p>Machine languages and low-level programming languages always provide\n"
"the ability to perform bitwise boolean operations: groups of bits are\n"
"logically combined on a bit-by-bit basis; adjacent bits have no effect\n"
"on their neighbors in determining the result. The same languages also\n"
"let you treat adjacent groupings of bits as a unit; this is commonly\n"
"called a byte or a bit field. Usually bitwise and bit field operations\n"
"are constrained by the size of hardware registers."
msgstr ""
"<p>\n"
"Машинные языки и низкоуровневые языки программирования всегда предоставляют\n"
"возможность выполнения побитовых булевых операций: группы битов логически\n"
"объединяются на основе битов; соседние биты не оказывают никакого влияния \n"
"на своих соседей при определении результата. Те же языки также позволяют \n"
"рассматривать соседние группы битов как единое целое; это обычно "
"называется \n"
"байтом или битовым полем. Обычно побитовые операции и операции с битовыми\n"
"полями ограничены размером аппаратных регистров.\n"

#: in/chapter18.html:75
msgid ""
"<p>Lisp makes these same facilities available, but removes the constraints\n"
"that might otherwise be imposed by the underlying hardware."
msgstr ""
"<p>\n"
"Lisp делает эти же средства доступными, но устраняет ограничения, которые "
"в \n"
"противном случае могли бы быть наложены базовым оборудованием."

#: in/chapter18.html:83
msgid ""
"<p>Sixteen bitwise boolean operations are available in Lisp through\n"
"the <code>BOOLE</code> function. <code>BOOLE</code> is a\n"
"three-argument functions expecting an operation designator plus two\n"
"integer arguments and producing an integer result. Remember that\n"
"Lisp has infinite precision integers (bignums), so these bitwise\n"
"boolean operations are exempt from machine limitations (except for\n"
"available memory)."
msgstr ""
"<p>Шестнадцать логических побитовых операций доступно в Лиспе через \n"
"булеву функцию <code>BOOLE</code>. <code>BOOLE</code> - это функция \n"
"с тремя аргументами, ожидающая обозначение операции и два целочисленных \n"
"аргумента и производящая целочисленный результат. Помните, что Lisp \n"
"работает с целыми числами бесконечной точности (bignums), поэтому \n"
"эти побитовые булевы операции свободны от ограничений машины \n"
"(за исключением доступной памяти)."

#: in/chapter18.html:87
msgid ""
"<p>The operation designator is a constant value having a name from the\n"
"following list. The actual values of these constants is specific to\n"
"the Lisp implementation."
msgstr ""
"<p>\n"
"Обозначение операции - это постоянное значение, имеющее имя из следующего \n"
"списка. Фактические значения этих констант специфичны для реализации Lisp."

#: in/chapter18.html:106
msgid ""
"<ol>\n"
"<li><code>BOOLE-1</code> <i>; returns arg1</i> \n"
"<li><code>BOOLE-2</code> <i>; returns arg2</i> \n"
"<li><code>BOOLE-ANDC1</code> <i>; and complement of arg1 with arg2</i> \n"
"<li><code>BOOLE-ANDC2</code> <i>; and arg1 with complement of arg2</i> \n"
"<li><code>BOOLE-AND</code> <i>; and arg1 with arg2</i> \n"
"<li><code>BOOLE-C1</code> <i>; complement of arg1</i> \n"
"<li><code>BOOLE-C2</code> <i>; complement of arg2</i> \n"
"<li><code>BOOLE-CLR</code> <i>; always all zeroes</i> \n"
"<li><code>BOOLE-EQV</code> <i>; exclusive-nor of arg1 with arg2 "
"(equivalence)</i> \n"
"<li><code>BOOLE-IOR</code> <i>; inclusive-or of arg1 with arg2</i> \n"
"<li><code>BOOLE-NAND</code> <i>; not-and of arg1 with arg2</i> \n"
"<li><code>BOOLE-NOR</code> <i>; not-or of arg1 with arg2</i> \n"
"<li><code>BOOLE-ORC1</code> <i>; or complement of arg1 with arg2</i> \n"
"<li><code>BOOLE-ORC2</code> <i>; or arg1 with complement of arg2</i> \n"
"<li><code>BOOLE-SET</code> <i>; always all ones</i> \n"
"<li><code>BOOLE-XOR</code> <i>; exclusive-or of arg1 with arg2</i> \n"
"</ol> "
msgstr ""

#: in/chapter18.html:117
msgid ""
"<pre>\n"
"? (boole boole-and 15 7)\n"
"7\n"
"? (boole boole-ior 2 3)\n"
"3\n"
"? (boole boole-set 99 55)\n"
"-1\n"
"? (boole boole-andc2 7 4)\n"
"3\n"
"</pre> "
msgstr ""

#: in/chapter18.html:123
msgid ""
"<p>There are also eleven bitwise logical functions; these\n"
"are similiar to the <code>BOOLE</code> operations, except that the constant\n"
"and identity operations are not present in this group, and the complement\n"
"function takes only one argument. (Except for <code>LOGNOT</code>, all of\n"
"the following functions expect two arguments.)"
msgstr ""
"<p>\n"
"Существует также одиннадцать побитовых логических функций; они аналогичны \n"
"операциям Буля(<code>BOOLE</code>), за исключением того, что операции \n"
"constant(константы) и identity(тождества) не присутствуют в этой группе, \n"
"а функция complement(дополнения) принимает только один аргумент. \n"
"(За исключением <code>LOGNOT</code>, все следующие функции принимают \n"
"два аргумента.)"

#: in/chapter18.html:137
msgid ""
"<ol>\n"
"<li><code>LOGAND</code> \n"
"<li><code>LOGANDC1</code> \n"
"<li><code>LOGANDC2</code> \n"
"<li><code>LOGEQV</code> \n"
"<li><code>LOGIOR</code> \n"
"<li><code>LOGNAND</code> \n"
"<li><code>LOGNOR</code> \n"
"<li><code>LOGNOT</code> \n"
"<li><code>LOGORC1</code> \n"
"<li><code>LOGORC2</code>\n"
"<li><code>LOGXOR</code>\n"
"</ol> "
msgstr ""

#: in/chapter18.html:140
msgid ""
"<p><code>LOGTEST</code> returns true if any of the corresponding bits in "
"its\n"
"two arguments are both ones."
msgstr ""
"<p><code>LOGTEST</code> возвращает true, если любой из соответствующих \n"
"битов в его двух аргументах является единицей."

#: in/chapter18.html:147
msgid ""
"<pre>\n"
"? (logtest 7 16)\n"
"NIL\n"
"? (logtest 15 5)\n"
"T\n"
"</pre> "
msgstr ""

#: in/chapter18.html:151
msgid ""
"<p><code>LOGBITP</code> tests one bit in the two's complement "
"representation\n"
"of an integer, returning <code>T</code> if the bit is 1 and <code>NIL</"
"code> \n"
"if the bit is 0.  The least significant (rightmost) bit is bit 0."
msgstr ""
"<p><code>LOGBITP</code> проверяет один бит в дополнительном представлении \n"
"двух целых чисел, возвращая <code>T</code>, если бит равен 1, и <code>NIL</"
"code>, \n"
"если бит равен 0. Наименее значимым (крайним правым) битом является бит 0."

#: in/chapter18.html:162
msgid ""
"<pre>\n"
"? (logbitp 0 16)\n"
"NIL\n"
"? (logbitp 4 16)\n"
"T\n"
"? (logbitp 0 -2)\n"
"NIL\n"
"? (logbitp 77 -2)\n"
"T\n"
"</pre> "
msgstr ""

#: in/chapter18.html:166
msgid ""
"<p><code>LOGCOUNT</code> counts 1 bits in the binary representation\n"
"of a positive integer, and 0 bits in the two's complement binary\n"
"representation of a negative number."
msgstr ""
"<p>\n"
"<code>LOGCOUNT</code>  подсчитывает 1 бит в двоичном представлении \n"
"положительного целого числа и 0 бит в дополнительном двоичном \n"
"представлении отрицательного числа."

#: in/chapter18.html:173
msgid ""
"<pre>\n"
"? (logcount 35)\n"
"3\n"
"? (logcount -2)\n"
"1\n"
"</pre> "
msgstr ""

#: in/chapter18.html:175
msgid "<h2>Bit vectors can go on forever</h2>"
msgstr "<h2>Битовые векторы могут продолжаться вечно</h2>"

#: in/chapter18.html:183
msgid ""
"<p>A vector composed of only 1s and 0s has a compact representation\n"
"as a <em>bit vector</em>, a special representation for printing and\n"
"reading, and a set of logical operations. Like all vectors (and\n"
"arrays) in Common Lisp, the size of a bit vector is limited by the\n"
"constant <code>ARRAY-TOTAL-SIZE-LIMIT</code>; this can be as small\n"
"as 1,024, but is typically large enough that the size of memory sets\n"
"a practical limit on the size of bit-vectors."
msgstr ""
"<p>\n"
"Вектор, состоящий только из 1 и 0, имеет компактное представление в \n"
"виде битового вектора(<em>bit vector</em>), специальное представление \n"
"для печати и чтения и набор логических операций. Как и все векторы \n"
"(и массивы) в Common Lisp, размер битового вектора ограничен константой \n"
"<code>ARRAY-TOTAL-SIZE-LIMIT</code>; это может быть всего лишь 1,024, но \n"
"обычно достаточно большой, чтобы размер памяти устанавливал практическое \n"
"ограничение на размер битовых векторов."

#: in/chapter18.html:189
msgid ""
"<p>The printed representation of a bit vector begins with the\n"
"<code>#*</code> reader macro, followed by 1s and 0s. The bit\n"
"vector's length is determined by the 1s and 0s that make up its\n"
"elements. (The printed representation of an empty bit vector is\n"
"<code>#*</code>.)"
msgstr ""
"<p>\n"
"Печатное представление битового вектора начинается с макроса \n"
"чтения <code>#*</code>, за которым следуют единицы(1) и \n"
"нули(0). длина битового вектора определяется 1 и 0, составляющими \n"
"его элементы. (Печатное представление пустого битового вектора \n"
"равно <code>#*</code>.)"

#: in/chapter18.html:196
msgid ""
"<pre>\n"
"? #*0010101\n"
"#*0010101\n"
"? (length #*0010101)\n"
"7\n"
"</pre> "
msgstr ""

#: in/chapter18.html:202
msgid ""
"<p>There are eleven bitwise logical operations available for bit vectors.\n"
"With the exception of <code>BIT-NOT</code>, these are all functions of\n"
"two arguments.  Unlike the corresponding bitwise logical operations on\n"
"integers, the bit vector logical operations expect their arguments to\n"
"be of the same size."
msgstr ""
"<p>\n"
"Существует одиннадцать побитовых логических операций, доступных для "
"битовых \n"
"векторов. За исключением <code>BIT-NOT</code>, все они являются функциями \n"
"двух аргументов. В отличие от соответствующих побитовых логических "
"операций \n"
"над целыми числами, логические операции битового вектора ожидают, что их \n"
"аргументы будут иметь одинаковый размер."

#: in/chapter18.html:216
msgid ""
"<ol>\n"
"<li><code>BIT-AND</code> \n"
"<li><code>BIT-ANDC1</code> \n"
"<li><code>BIT-ANDC2</code> \n"
"<li><code>BIT-EQV</code> \n"
"<li><code>BIT-IOR</code> \n"
"<li><code>BIT-NAND</code> \n"
"<li><code>BIT-NOR</code> \n"
"<li><code>BIT-NOT</code> \n"
"<li><code>BIT-ORC1</code> \n"
"<li><code>BIT-ORC2</code>\n"
"<li><code>BIT-XOR</code>\n"
"</ol> "
msgstr ""

#: in/chapter18.html:227
msgid ""
"<p>These functions will destructively update a result bit vector if\n"
"you provide an optional third (second in the case of\n"
"<code>BIT-NOT</code>) argument. If the optional argument is\n"
"<code>T</code>, then the first argument will be updated with the\n"
"result bits. If the optional argument is a bit vector, it will be\n"
"updated with the result bits and the input arguments will be\n"
"unchanged. (This in-place update is not available for bitwise\n"
"operations on integers; destructive bit vector operations\n"
"may be more efficient once the number of bits exceeds the size of a\n"
"fixnum.)"
msgstr ""
"<p>\n"
"Эти функции будут разрушающе обновлять результирующий битовый вектор, \n"
"если вы предоставите необязательный третий (второй в случае<code>BIT-NOT</"
"code>) \n"
"аргумент. Если необязательный аргумент равен <code>T</code>, то  будет "
"обновлен\n"
"первый аргумент битами результата. Если необязательным аргументом является \n"
"битовый вектор, то он будет обновлен с помощью результирующих битов, а \n"
"входные аргументы останутся неизменными. (Это обновление на месте "
"недоступно \n"
"для побитовых операций над целыми числами; разрушающие операции с битовыми \n"
"векторами могут быть более эффективными, если число битов не превышает "
"размер \n"
"фиксированного числа/fixnum.)"

#: in/chapter18.html:236
msgid ""
"<pre>\n"
"? (bit-and #*00110100 #*10101010)\n"
"#*00100000\n"
"? (bit-ior #*00110100 #*10101010)\n"
"#*10111110\n"
"? (bit-not #*00110100)\n"
"#*11001011\n"
"</pre> "
msgstr ""

#: in/chapter18.html:241
msgid ""
"<p>You can access an individual element of a bit vector using\n"
"<code>BIT</code>. This is a vector accessor, and not a boolean test,\n"
"so it returns 0 or 1. <code>BIT</code> can also be used in a\n"
"<code>SETF</code> form to alter an element of a bit vector."
msgstr ""
"<p>\n"
"Вы можете получить доступ к отдельному элементу битового вектора \n"
"с помощью <code>BIT</code>. Это  метод доступа к вектору, а не логический \n"
"тест, поэтому он возвращает 0 или 1. <code>BIT</code> также может быть \n"
"использован в форме <code>SETF</code> для изменения элемента битового "
"вектора."

#: in/chapter18.html:250
msgid ""
"<pre>\n"
"? (bit #*01001 1)\n"
"1\n"
"? (let ((bv (copy-seq #*00000)))\n"
"    (setf (bit bv 3) 1)\n"
"    bv)\n"
"#*00010\n"
"</pre> "
msgstr ""

#: in/chapter18.html:252
msgid "<h2>Chunks of bits make bytes</h2>"
msgstr "<h2>Куски(Chunks) битов создают байты</h2>"

#: in/chapter18.html:256
msgid ""
"<p>Getting back to integer manipulation as we wrap up this chapter, \n"
"we'll see how to manipulate fields of adjacent bits within an integer\n"
"value."
msgstr ""
"<p>\n"
"Возвращаясь к манипулированию целыми числами, когда мы завершим эту главу, \n"
"мы посмотрим, как манипулировать полями соседних битов в \n"
"целочисленном значении."

#: in/chapter18.html:263
msgid ""
"<p>The first thing we need when manipulating a field of bits (called a\n"
"<em>byte</em> in Common Lisp) is a way of specifying its bounds. \n"
"The <code>BYTE</code> function constructs a byte specifier from a\n"
"size (number of bits) and a position (the number of the rightmost bit\n"
"of the byte within the containing integer, where the LSB is bit 0).\n"
"The representation of a byte specifier depends upon the Lisp implementation."
msgstr ""
"<p>\n"
"Первое, что нам нужно, когда мы манипулируем полем битов (называемым "
"байтом \n"
"в Common Lisp), - это способ определения его границ. Функция <code>BYTE</"
"code> \n"
"строит спецификатор байта из размера (числа битов) и позиции (числа самого \n"
"правого бита байта внутри содержащего целого числа, где LSB - бит 0). \n"
"Представление спецификатора байтов зависит от реализации Lisp.\n"

#: in/chapter18.html:266
msgid ""
"<p>The functions <code>BYTE-SIZE</code> and <code>BYTE-POSITION</code> \n"
"extract the size and position values from a byte specifier."
msgstr ""
"<p>\n"
"Функции <code>BYTE-SIZE</code> и <code>BYTE-POSITION</code> извлекают \n"
"значения размера и позиции из спецификатора байтов."

#: in/chapter18.html:275
msgid ""
"<pre>\n"
"? (setq bs (byte 5 3)) <code>; 5 bits, rightmost has weight 2^3 in source</"
"code> \n"
"248 <i>; implementation-dependent</i> \n"
"? (byte-size bs)\n"
"5\n"
"? (byte-position bs)\n"
"3\n"
"</pre> "
msgstr ""

#: in/chapter18.html:278
msgid ""
"<p>You can extract and replace bytes from an integer using the functions\n"
"<code>LDB</code> (load byte) and <code>DPB</code> (deposit byte)."
msgstr ""
"<p>\n"
"Вы можете извлечь и заменить байты из целого числа с помощью функций \n"
"<code>LDB</code> (load byte) и <code>DPB</code> (deposit byte)."

#: in/chapter18.html:289
msgid ""
"<pre>\n"
"? (ldb (byte 8 8) 258)\n"
"1\n"
"? (ldb (byte 8 0) 258)\n"
"2\n"
"? (dpb 3 (byte 8 8) 0)\n"
"768\n"
"? (dpb 1 (byte 1 5) 1)\n"
"33\n"
"</pre> "
msgstr ""

#: in/chapter18.html:292
msgid ""
"<p><code>LDB-TEST</code> returns true if any of the bits are 1 in a\n"
"specified byte."
msgstr ""
"<p><code>LDB-TEST</code>  возвращает true, если некоторый из битов, \n"
"в указанном байте, равен 1 "

#: in/chapter18.html:301
msgid ""
"<pre>\n"
"? (ldb-test (byte 3 2) 3)\n"
"NIL\n"
"? (ldb-test (byte 3 2) 9)\n"
"T\n"
"? (ldb-test (byte 3 2) 34)\n"
"NIL\n"
"</pre> "
msgstr ""

#: in/chapter18.html:308
msgid ""
"<p><code>INTEGER-LENGTH</code> tells you how many bits are necessary\n"
"to represent an integer in two's complement form. A positive integer\n"
"will always have an unsigned representation using the number of bits\n"
"determined by <code>INTEGER-LENGTH</code>. A negative integer has a\n"
"signed binary representation that requires one bit more than the\n"
"number of bits determined by <code>INTEGER-LENGTH</code>."
msgstr ""
"<p>\n"
"<code>INTEGER-LENGTH</code>  говорит вам, сколько битов необходимо для \n"
"представления целого числа в форме дополнения до двух. Положительное целое \n"
"число всегда будет иметь представление без знака, используя число битов, \n"
"определяемое <code>INTEGER-LENGTH</code>. Отрицательное целое число имеет \n"
"знаковое двоичное представление, которое требует на один бит больше, \n"
"чем число битов, определяемое  <code>INTEGER-LENGTH</code>."

#: in/chapter18.html:321
msgid ""
"<pre>\n"
"? (integer-length 69) <i>; 1000101</i> \n"
"7\n"
"? (integer-length 4) <i>; 100</i> \n"
"3\n"
"? (integer-length -1) <i>; 1</i> \n"
"0\n"
"? (integer-length 0)\n"
"0\n"
"? (integer-length -5) <i>; 1011</i> \n"
"3\n"
"</pre> "
msgstr ""

#: in/chapter18.html:328
msgid ""
"<p>You can shift the bits in an integer using the <code>ASH</code> "
"function.\n"
"This is an <em>arithmetic</em> shift; it treats the integer as a two's\n"
"complement binary number and preserves the sign (leftmost) bit as the rest\n"
"of the bits are shifted. A left shift shifts bits to the left, replacing\n"
"them with zeroes (and preserving the sign bit). A right shift shifts bits\n"
"to the right, replacing them with zeroes (and preserving the sign bit)."
msgstr ""
"<p>\n"
"Вы можете сдвинуть биты в целом числе, используя функцию <code>ASH</code>. \n"
"Это арифметический сдвиг; он рассматривает целое число в форме дополнения\n"
"до двух двоичное число и сохраняет знак (крайний левый) бит, когда "
"остальные \n"
"биты сдвигаются. Сдвиг влево сдвигает биты влево, заменяя их нулями \n"
"(и сохраняя знаковый бит). Сдвиг вправо сдвигает биты вправо, заменяя их "
"нулями \n"
"(и сохраняя знаковый бит)."

#: in/chapter18.html:333
msgid ""
"<p><code>ASH</code> expects two arguments, an integer to be shifted,\n"
"and a shift count. A shift count of 0 returns the integer unchanged.\n"
"A positive count shifts bits to the left by the specified number of\n"
"positions. A negative count shifts bits to the right."
msgstr ""
"<p>\n"
"<code>ASH</code>  ожидает два аргумента, целое число, которое должно \n"
"быть сдвинуто, и количество сдвигов. Число сдвигов, равное 0, возвращает \n"
"целое число без изменений. Положительный счетчик сдвигает биты влево на \n"
"заданное количество позиций. Отрицательное число сдвигает биты вправо."

#: in/chapter18.html:354
msgid ""
"<pre>\n"
"? (ash 75 0)\n"
"75\n"
"? (ash 31 1)\n"
"62\n"
"? (ash -7 1)\n"
"-14\n"
"? (ash 32 8)\n"
"8192\n"
"? (ash -1 8)\n"
"-256\n"
"? (ash 16 -1)\n"
"8\n"
"? (ash 11 -1)\n"
"5\n"
"? (ash 32 -8)\n"
"0 <i>; all one bits shifted out</i> \n"
"? (ash -99 -2)\n"
"-25\n"
"</pre> "
msgstr ""

#: in/chapter18.html:367
msgid ""
"<hr>\n"
"<div align=\"center\">\n"
"<a href=\"contents.html\">Contents</a> | <a href=\"cover.html\">Cover</a> "
"<br> \n"
"<a href=\"chapter17.html\">Chapter 17</a> | Chapter 18 | <a href=\"chapter19."
"html\">Chapter 19</a> \n"
"</div>\n"
"<hr>\n"
"<address>\n"
"Copyright &copy; 1995-2001, David B. Lamkins<br>\n"
"All Rights Reserved Worldwide<br>\n"
"<br>\n"
"This book may not be reproduced without the written consent of its author.  "
"Online distribution is restricted to the author's site.\n"
"</address> \n"
"</body> </html> "
msgstr ""
