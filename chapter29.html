<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Successful Lisp - Chapter 29</title>
</head> 

<body bgcolor="white" text="black">
<h1>Глава 29 - Я думал, что теперь твоя очередь выносить
мусор</h1> 

<P>
Цель главы: опишисать преимущества и затраты на сбор мусора. Показать, 
как улучшить производительность программы, уменьшив количество мусора, 
который она генерирует.
</P>

<h2>Что такое мусор(garbage)?</h2>

<p>
Проще говоря, мусор - это любое хранилище, которое ваша программа когда-то 
использовала, но больше не использует. Вот простой пример:

<pre>
(let ((x (list 1 2 3 4 5)))
  (print x))
</pre> 

<p>
Когда вы вычисляете эту форму, список  <code>'(1 2 3 4 5 6)</code> сначала 
привязывается к <code>X</code>, а затем печатается. Как только элемент управления 
покидает форму <code>LET</code>, список, привязанный к <code>X</code>, больше не 
доступен; его хранилище может быть восстановлено(возвращено для дальнейшего
использования) сборщиком мусора.

<blockquote> 
На самом деле, есть небольшое осложнение, о котором вы должны знать. 
Когда вы вычисляете форму в прослушивателе Lisp, сама форма присваивается 
символу <code>+</code>, а значение присваивается символу <code>*</code>. 
Предыдущая форма и значение присваиваются соответственно <code>++</code> и 
<code>**</code>, а форма и значение перед этим присваиваются <code>+++</code>
и <code>***</code>. Поскольку эти три пары переменных дают вам возможность 
получить доступ к формам и результатам, форма и ее результат не могут 
действительно стать мусором, пока вы не вычислили дополнительные формы, 
чтобы очистить эти шесть переменных.

<p>
Обычно вам не придется беспокоиться об этом, если вы не сделали что-то 
в прослушивателе, чтобы исчерпать всю доступную память в Lisp; если вы 
можете вычислить простое выражение (например, <code>T</code>) три раза, 
вы освободите любое хранилище, содержащееся в <code>+</code>,
<code>*</code> и их друзьях.
</blockquote> 

<h2>Почему сбор мусора так важен?</h2>

<p>
Lisp выделяет хранилище по мере необходимости для данных вашей программы. 
У вас нет прямого контроля над тем, как и когда выделяется хранилище; 
компилятор может сделать все возможное, чтобы удовлетворить размещение
значений вашей программы.

<p>
Lisp не предоставляет вашей программе возможности явного освобождения 
хранилища. Это важная особенность, потому что вы никогда не сможете 
написать программу, чтобы ошибочно освободить место хранения, которое 
все еще необходимо в другом месте программы. Это устраняет целый класс 
ошибок, иногда называемых "ошибками убитого указателя(dead pointer)" 
в языках, которые поддерживают явное выделение и освобождение хранилища.

<p>
С другой стороны, ваша программа может в конечном итоге исчерпать память, 
если она никогда не освобождает место хранения. Таким образом, язык 
(например, Lisp), который не поддерживает явное освобождение, по-прежнему 
должен обеспечивать механизм автоматического освобождения хранилища, 
когда оно больше не требуется. Задача сборщика мусора состоит в том, 
чтобы выяснить, какое хранилище больше не может быть доступно вашей 
программе, а затем переработать эти недоступные блоки хранения для 
последующего использования.

<h2>Как работает сборщик мусора?</h2>

<p>
Lisp компилирует вашу программу таким образом, что все выделенные ей хранилища
можно найти, следуя указателям из небольшого числа известных <em>корневых</em>
указателей. Компилятор и система выполнения обеспечивают сохранение информации 
о типах в вашей программе во время выполнения; это сочетается со знанием макетов 
хранения во время компиляции для кодирования знаний о расположении указателей 
в структурах данных.

<p>
Сборщик мусора следует за каждым указателем в каждой доступной структуре данных, 
начиная с корневого набора. При этом он помечает доступные структуры данных. 
После того, как каждый указатель был прослежен и его ссылочная структура данных 
помечена, любой блок памяти, который не помечен, становится недоступным для вашей
программы. Затем сборщик мусора восстанавливает эти немаркированные блоки для 
дальнейшего использования распределителем хранилища.


<blockquote> 
Фактический алгоритм маркировки, используемый сборщиком мусора, 
должен учитывать циклы в доступных структурах данных и должен выполняться 
в ограниченном пространстве и времени; эти детали усложняют реализацию 
сборщика мусора. Кроме того, большинство сборщиков перемещают помеченные 
данные (и соответственно корректируют ссылки). [
<a href="chapter33.html#jones96">[Jones96]</a> предоставляет превосходный 
обзор и анализ различных методов сбора мусора.
</blockquote> 

<h2>Какое влияние мусор оказывает на мою программу?</h2>

<p>
Мусор заставляет вашу программу работать медленнее. Чем больше мусора 
создает ваша программа, тем больше времени сборщику мусора нужно будет 
потратить на переработку мусора. Современные сборщики мусора очень 
эффективны; маловероятно, что вы заметите заметную паузу в выполнении 
вашей программы по мере запуска сборщика мусора. Однако совокупный эффект 
многих небольших пауз приведет к заметному ухудшению общей 
производительности.


<p>
Хорошая новость заключается в том, что сбор мусора гарантирует, 
что ваша программа никогда не будет страдать от утечек памяти 
или мертвых указателей.

<p>
Кроме того, поскольку многие реализации сборщика мусора перестраивают 
хранилище по мере выполнения вашей программы, фрагментация кучи сводится 
к минимуму; таким образом, производительность большой программы Lisp не 
будет ухудшаться с течением времени, как у программы C или C++, которая 
выполняет сопоставимое распределение хранилища (обычно от 25 до 50 процентов 
деградации для программы C или C++, в зависимости от размера кучи, реализации 
malloc/free и шаблонов распределения/освобождения).

<blockquote> 
Следует отметить, что явное распределение и освобождение хранилища имеет 
накладные расходы, которые не являются строго предсказуемыми. В типичных 
реализациях malloc и free выделение блоков включает поиск, а освобождение 
включает дополнительную работу по объединению свободных блоков; обе эти 
операции имеют фактически неопределенную продолжительность, зависящую от 
размера и фрагментации кучи.
</blockquote> 

<h2>Как я могу уменьшить паузы сбора мусора в моей программе?</h2>

<p>
Вы можете уменьшить накладные расходы на сборку мусора, уменьшив его 
генерацию. Используйте соответствующие структуры данных; манипулирование 
списками является наиболее распространенной причиной создания мусора 
в плохо написанных программах Lisp. Обратите внимание на то, возвращает 
ли операция свежую копию или (возможно, измененную) существующую 
копию данных.

<p>
Если у вас есть профилировщик, доступный в вашей системе Lisp, 
используйте его, чтобы найти горячие точки вашей программы для 
выделения хранилища.

<p>
Используйте разрушающие операции осторожно; они могут уменьшить 
образование мусора, но вызовут тонкие ошибки, если деструктивно 
измененные данные будут совместно использоваться другой частью 
вашей программы.

<hr>
<div align="center">
<a href="contents.html">Contents</a> | <a href="cover.html">Cover</a> <br> 
<a href="chapter28.html">Chapter 28</a> | Chapter 29 | <a href="chapter30.html">Chapter 30</a> 
</div>
<hr>
<address>
Copyright &copy; 1995-2001, David B. Lamkins<br>
All Rights Reserved Worldwide<br>
<br>
This book may not be reproduced without the written consent of its author.  Online distribution is restricted to the author's site.
</address> 
</body> </html>