#
# NuINu <don't@send.my>, 2020.
#
#. extracted from in/chapter11.html
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-04-19 13:50+0300\n"
"PO-Revision-Date: 2020-06-12 19:53+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter11.html:5
msgid ""
"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/"
"html4/strict.dtd\">\n"
"<html><head>\n"
"<title>Successful Lisp - Chapter 11</title>\n"
"</head> "
msgstr ""
"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/"
"html4/strict.dtd\">\n"
"<html><head>\n"
"<META http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n"
"<title>Successful Lisp - Chapter 11</title>\n"
"</head> "

#: in/chapter11.html:8
msgid ""
"<body bgcolor=\"white\" text=\"black\">\n"
"<h1>Chapter 11 - Destructive Modification</h1> "
msgstr ""
"<body bgcolor=\"white\" text=\"black\">\n"
"<h1>Глава 11 - Разрушающее Изменение</h1> "

#: in/chapter11.html:15
msgid ""
"<p>Assignment is very different from binding, and in many cases\n"
"results in programs that are harder to understand. Despite this,\n"
"there are (sometimes) reasons to prefer assignment. In this chapter,\n"
"we'll explore assignment and its relationship to destructive\n"
"modification of data. We'll also explore several Lisp functions that\n"
"implement destructive modification."
msgstr ""
"<p>Присваивание сильно отличается от привязки, и во многих случаях \n"
"приводит к программам, которые труднее понять. Несмотря на это, \n"
"есть (иногда) причины предпочесть присваивание. В этой главе мы \n"
"рассмотрим присваивание и его связь с разрушающей модификацией \n"
"данных. Мы также рассмотрим несколько функций Lisp, реализующих \n"
"разрушающую модификацию."

#: in/chapter11.html:17
msgid "<h2>Simple assignment is destructive modification</h2>"
msgstr "<h2>Простое присваивание это разрушающее изменение</h2>"

#: in/chapter11.html:25
msgid ""
"<p>Any time your program invokes <code>SETQ</code> or\n"
"<code>SETF</code>, it is assigning a new value to an existing\n"
"storage location, destroying the value that was previously in that\n"
"location. As we'll see in this chapter, there are both risks and\n"
"benefits to the use of assignment; you need to understand the\n"
"tradeoffs in order to write Lisp code that is both correct and \n"
"efficient."
msgstr ""
"<p>Каждый раз, когда ваша программа вызывает <code>SETQ</code> или\n"
"<code>SETF</code>, она присваивает новое значение существующему \n"
"хранилищу, уничтожая значение, которое ранее было в этом расположении. \n"
"Как мы увидим в этой главе, использование присваивания сопряжено \n"
"как с рисками, так и с выгодами; вы должны понимать компромиссы, \n"
"чтобы написать Лисп-код, который является одновременно правильным \n"
"и эффективным."

#: in/chapter11.html:27
msgid "<h2>The risk of assignment</h2>"
msgstr "<h2>Риски присваивания</h2>"

#: in/chapter11.html:35
msgid ""
"<p>Any time you define a function that uses variables, the variables\n"
"are either <code>bound</code> or <code>free</code>. A bound variable\n"
"occurs within a binding form that occurs within the function\n"
"definition. A binding form is just a form that creates a new\n"
"association between the name of a variable and a place to store its\n"
"value; the most common binding forms are <code>LET</code> and the\n"
"argument list of a <code>DEFUN</code> or <code>LAMBDA</code>."
msgstr ""
"<p>\n"
"Каждый раз, когда вы определяете функцию, использующую переменные, \n"
"эти переменные либо связанны(<code>bound</code>), либо свободны(\n"
"<code>free</code>). Связанная переменная возникает в форме привязки, \n"
"которая возникает в определении функции. Форма привязки- это просто форма,\n"
"которая создает новую ассоциацию(связь) между именем переменной и местом "
"хранения\n"
"ее значения; наиболее распространенными формами привязки являются \n"
"<code>LET</code> и список аргументов в <code>DEFUN</code> или \n"
"<code>LAMBDA</code>.\n"

#: in/chapter11.html:43
msgid ""
"<blockquote> There's a slight terminology clash in the use of the\n"
"word <em>bound</em>. The clash is always resolved by the context of\n"
"the word's use, but you need to be aware of the two meanings. In\n"
"this chapter we're talking exclusively about a variable\n"
"<em>name</em> being bound to a place to store its value; when we say\n"
"that Lisp creates a binding for a variable, we mean that it creates\n"
"a <em>new</em> place to store a value under a given name."
msgstr ""
"<blockquote> Есть небольшое терминологическое противоречие в \n"
"использовании слова \"связанный\"(<em>bound</em>). Конфликт всегда \n"
"разрешается контекстом употребления слова, но вы должны быть \n"
"осведомлены о двух значениях. В этой главе мы говорим исключительно \n"
"о том, что имя переменной привязано к месту хранения ее значения; \n"
"когда мы говорим, что Lisp создает привязку для переменной, \n"
"мы имеем в виду, что он создает <em>новое</em> место для хранения \n"
"значения под заданным именем."

#: in/chapter11.html:48
msgid ""
"<p>The other sense of <em>bound</em> -- not otherwise discussed in this\n"
"chapter -- is the binding of a <em>value</em> to a storage location; Lisp\n"
"supports the notion of an unbound -- or nonexistent -- value.\n"
"</blockquote> "
msgstr ""
"<p>Другой смысл привязки(<em>bound</em>)-не обсуждавшийся ранее \n"
"в этой главе - это привязка <em>значения</em> к месту хранения; \n"
"Lisp поддерживает понятие несвязанного - или несуществующего -\n"
"значения.\n"
"</blockquote> "

#: in/chapter11.html:54
msgid ""
"<a name=\"closures\"></a> \n"
"<p>A variable is <em>free</em> within a function if the function\n"
"provides no binding form for the variable's name. In the following\n"
"example, the variable <code>E</code> is free in both functions\n"
"<code>CLOSURE-1</code> and <code>CLOSURE-2</code>."
msgstr ""
"<a name=\"closures\"></a> \n"
"<p>Переменная является <em>свободной</em> внутри функции, если \n"
"функция не предоставляет формы привязки для имени переменной. \n"
"В следующем примере переменная <code>E</code> свободна в обеих \n"
"функциях <code>CLOSURE-1</code> и <code>CLOSURE-2</code>."

#: in/chapter11.html:64
msgid ""
"<pre>\n"
"? (let ((e 1))\n"
"    (defun closure-1 () e))\n"
"CLOSURE-1\n"
"? (closure-1)\n"
"1\n"
"? e\n"
"Error: unbound variable\n"
"</pre> "
msgstr ""

#: in/chapter11.html:72
msgid ""
"<p>So, what happens when a function has to reference a free\n"
"variable? Lisp creates a <em>closure</em> that captures the bindings\n"
"of free variables for the function. Variables that are free within a\n"
"function really do have bindings, but the bindings are outside of\n"
"the function definition. When Lisp executes the function, it finds \n"
"free variables in the closure. (We'll examine closures in greater\n"
"detail in <a href=\"chapter15.html\">Chapter 15</a>.)"
msgstr ""
"<p>Итак, что же происходит, когда функция должна ссылаться \n"
"на свободную переменную? Lisp создает замыкание(<em>closure</em>), которое \n"
"захватывает привязки свободных переменных для функции. Переменные, "
"свободные\n"
"в пределах функции, на само деле имеют привязки, но привязки находятся \n"
"вне определения функции. Когда Lisp выполняет функцию, он находит \n"
"свободные переменные в замыкании. (Более подробно мы рассмотрим замыкания \n"
"в <a href=\"chapter15.html\">главе 15</a>.)"

#: in/chapter11.html:79
msgid ""
"<p>Closures are important because they let a function\n"
"<code>capture</code> and retain lexical bindings. Take another look\n"
"at the example above. When we evaluated <code>(CLOSURE-1)</code>,\n"
"the variable <code>E</code> was no longer visible at the top level\n"
"prompt. But because the function had a closure for that variable, it\n"
"still has access to its binding."
msgstr ""
"<p>Замыкания важны, потому что они позволяют функции захватывать\n"
"(<code>capture</code>) и сохранять лексические привязки. Взгляните \n"
"еще раз на приведенный выше пример. Когда мы вычисляли \n"
"<code>(CLOSURE-1)</code>, переменная <code>E</code> больше не была \n"
"видна в приглашении верхнего уровня. Но поскольку функция имела \n"
"замыкание для этой переменной, она все еще имела доступ к ее привязке."

#: in/chapter11.html:81
msgid "<p>Let's extend the previous example just a little."
msgstr "<p>Давайте немного расширим предыдущий пример."

#: in/chapter11.html:93
msgid ""
"<pre>\n"
"? (let ((e 1))\n"
"    (defun closure-1 () e)\n"
"    (setq e 7)\n"
"    (defun closure-2 () e))\n"
"CLOSURE-2\n"
"? (closure-1)\n"
"7\n"
"? (closure-2)\n"
"7\n"
"</pre> "
msgstr ""

#: in/chapter11.html:104
msgid ""
"<p>Do you understand why <code>(CLOSURE-1)</code> returned 7 rather\n"
"than 1? We created a binding for the variable <code>E</code> and\n"
"gave it an initial value of 1. Even though <code>CLOSURE-1</code>\n"
"was defined when <code>E</code>'s value was 1, this doesn't matter:\n"
"the closure captures the binding -- the association between the name\n"
"and the storage location. When we assigned 7 as the value of\n"
"<code>E</code> (just before defining <code>CLOSURE-2</code>), we\n"
"changed only the one storage location for that binding. Since both\n"
"functions' free variable <code>E</code> is closed over the same\n"
"binding, they must retrieve the same value."
msgstr ""
"<p>Вы понимаете, почему <code>(CLOSURE-1)</code> вернуло 7, а не 1? \n"
"Мы создали привязку для переменной <code>E</code> и дали ей начальное \n"
"значение 1. Даже если <code>CLOSURE-1</code> был определен, когда\n"
"значение <code>E</code> было равно 1,это не имеет значения: замыкание\n"
"захватывает привязку - связь между именем и местом хранения. Когда \n"
"мы присвоили 7 в качестве значения <code>E</code> (непосредственно перед\n"
"определением <code>CLOSURE-2</code>), мы изменили только одно место \n"
"хранения для этой привязки. Поскольку свободная переменная <code>E</code>\n"
"обеих функций замкнута на одну и ту же привязку, они должны получить одно \n"
"и то же значение."

#: in/chapter11.html:106
msgid "<p>This behavior can be used to good effect."
msgstr "<p>Это поведение может быть использовано с хорошим эффектом."

#: in/chapter11.html:127
msgid ""
"<pre>\n"
"? (let ((counter 0))\n"
"    (defun counter-next ()\n"
"      (incf counter))\n"
"    (defun counter-reset ()\n"
"      (setq counter 0)))\n"
"COUNTER-RESET\n"
"? (counter-next)\n"
"1\n"
"? (counter-next)\n"
"2\n"
"? (counter-next)\n"
"3\n"
"? (counter-next)\n"
"4\n"
"? (counter-reset)\n"
"0\n"
"? (counter-next)\n"
"1\n"
"</pre> "
msgstr ""

#: in/chapter11.html:138
msgid ""
"<p>However, some Lisp iteration forms bind their iteration variables\n"
"just once, then assign new values on subsequent iterations.\n"
"<code>DO</code> and <code>DO*</code> assign to their iteration\n"
"variables. <code>DOLIST</code> and <code>DOTIMES</code> are allowed\n"
"to assign to their iteration variables (and probably will in any\n"
"implementation, because it is more efficient). You need to keep this\n"
"in mind if you write code that creates a closure for an iteration\n"
"variable. This example illustrates the point (see <a\n"
"href=\"chapter12.html\">Chapter 12</a> if you want to read about\n"
"<code>MAPCAR</code>):"
msgstr ""
"<p>\n"
"Однако некоторые формы итераций Lisp связывают свои переменные итерации \n"
"только один раз, а затем присваивают новые значения на последующих \n"
"итерациях. <code>DO</code> и <code>DO*</code> присваивают своим переменным\n"
"итерации. <code>DOLIST</code> и <code>DOTIMES</code> могут присвоить своим\n"
"итерационным переменным (и, вероятно, будут присваивать в любой реализации,\n"
"потому что это более эффективно). Вы должны иметь это в виду, если пишете \n"
"код, который создает замыкание для переменной итерации. Этот пример\n"
"иллюстрирует этот момент (см. <a href=\"chapter12.html\">Главу 12</a>, \n"
"Если вы хотите прочитать <code>MAPCAR</code>):"

#: in/chapter11.html:154
msgid ""
"<pre>\n"
"<i>; Closure captures assigned variable -- probably wrong</i> \n"
"? (let ((fns ()))\n"
"    (dotimes (i 3)\n"
"      (push #'(lambda () i) fns))\n"
"    (mapcar #'funcall fns))\n"
"(3 3 3)\n"
"<i>; New bindind created for each captured variable</i> \n"
"? (let ((fns ()))\n"
"    (dotimes (i 3)\n"
"      (let ((i i))\n"
"        (push #'(lambda () i) fns)))\n"
"    (mapcar #'funcall fns))\n"
"(2 1 0)\n"
"</pre> "
msgstr ""

#: in/chapter11.html:158
msgid ""
"<p>We've seen that assignment can cause unexpected behavior in the presence\n"
"of closures. Assignment can also cause problems when shared data is\n"
"involved."
msgstr ""
"<p>Мы видели, что присваивание может вызвать неожиданное поведение \n"
"при наличии замыканий. Присваивание также может вызвать проблемы при\n"
"использовании разделяемых(общих) данных."

#: in/chapter11.html:172
msgid ""
"<pre>\n"
"? (defun nil-nth (n l)\n"
"    \"Set nth element of list to nil and return modified list.\"\n"
"    (setf (nth n l) nil)\n"
"    l)\n"
"NIL-NTH\n"
"? (defparameter *my-list* (list 1 2 3 4))\n"
"*MY-LIST*\n"
"? (nil-nth 1 *my-list*)\n"
"(1 NIL 3 4)\n"
"? *MY-LIST*\n"
"(1 NIL 3 4)\n"
"</pre> "
msgstr ""

#: in/chapter11.html:180
msgid ""
"<blockquote> <em>WARNING:</em> If you're accustomed to programming\n"
"in a language that allows by-reference modification of function\n"
"parameters, the previous code snippet may seem very tantalizing to\n"
"you. My advice is to put aside all thoughts of using this to emulate\n"
"by-reference parameters, and use multiple values (<a\n"
"href=\"chapter03-09.html\">Chapter 3, Lesson 9</a>) to safely and\n"
"efficiently return multiple results from a function. </blockquote> "
msgstr ""
"<blockquote> \n"
"Предупреждение: Если вы привыкли программировать на языке, который \n"
"позволяет изменять параметры функции по ссылке, предыдущий фрагмент \n"
"кода может показаться вам очень соблазнительным. Мой совет заключается \n"
"в том, чтобы отбросить все мысли об использовании этого метода для \n"
"эмуляции параметров по ссылкам и использовать множественные значения \n"
"(<a href=\"chapter03-09.html\">Глава 3, Урок 9</a>), чтобы безопасно и \n"
"эффективно возвращать несколько результатов из функции.\n"
" </blockquote> "

#: in/chapter11.html:190
msgid ""
"<p>The above example is not wrong, but it is dangerous. Except in\n"
"very special situations, we'd like our functions to accept arguments\n"
"and return values. The problem with <code>NIL-NTH</code> is that it\n"
"assigns a new value within the list passed as a parameter. In our\n"
"example, this list is global, and may be shared by other parts of the\n"
"program. If all we really wanted to do was to get a copy of the\n"
"argument list with the Nth element set to <code>NIL</code>, then we\n"
"shouldn't have altered the passed argument.  Here's a better way\n"
"to implement <code>NIL-NTH</code>:"
msgstr ""
"<p>Приведенный выше пример не является ошибочным, но он опасен. \n"
"За исключением очень особых ситуаций, мы хотели бы, чтобы наши \n"
"функции принимали Аргументы и возвращали значения. Проблема с \n"
"<code>NIL-NTH</code> заключается в том, что он присваивает новое \n"
"значение в списке, передаваемом в качестве параметра. В нашем \n"
"примере этот список является глобальным и может быть раздяем с\n"
"другими частями программы. Если все, что мы действительно хотели \n"
"сделать, это получить копию списка аргументов с N-м элементом, \n"
"равным <code>NIL</code>, то мы не должны были изменять переданный \n"
"аргумент. Вот лучший способ реализовать <code>NIL-NTH</code>:"

#: in/chapter11.html:205
msgid ""
"<pre>\n"
"? (defun nil-nth (n l)\n"
"    \"Return list with nth element set to nil.\"\n"
"    (if (zerop n)\n"
"      (cons nil (rest l))\n"
"      (cons (car l) (nil-nth (1- n) (rest l)))))\n"
"NIL-NTH\n"
"? (defparameter *my-list* (list 1 2 3 4))\n"
"*MY-LIST*\n"
"? (nil-nth 1 *my-list*)\n"
"(1 NIL 3 4)\n"
"? *MY-LIST*\n"
"(1 2 3 4)\n"
"</pre> "
msgstr ""

#: in/chapter11.html:207
msgid "<h2>Changing vs. copying: an issue of efficiency</h2>"
msgstr "<h2>Изменение против копирования: проблема эффективности</h2>"

#: in/chapter11.html:215
msgid ""
"<p>If assignment is so fraught with peril, why not just omit it from\n"
"the language? There are two reasons: expressiveness and efficiency.\n"
"Assignment is the clearest way to alter shared data. And assignment\n"
"is more efficient than binding. Binding creates a new storage\n"
"location, which allocates storage, which consumes additional memory\n"
"(if the binding never goes out of scope) or taxes the garbage\n"
"collector (if the binding eventually does go out of scope)."
msgstr ""
"<p>Если присваивание чревато опасностью, то почему бы просто не убрать\n"
"его из языка? Есть две причины: выразительность и оперативность. \n"
"Присваивание-это самый простой способ изменить общие(разделяемые) данные. \n"
"И присваивание более эффективно, чем привязка. Привязка создает новое \n"
"место хранения, которое выделяет хранилище, которое использует \n"
"дополнительную память (если привязка никогда не выходит за пределы области\n"
"действия) или добавляет нагрузку сборщику мусора (если привязка в конечном \n"
"итоге выходит за пределы области действия)."

#: in/chapter11.html:217
msgid "<h2>Modifying lists with destructive functions</h2>"
msgstr "<h2>Изменение списков с помощью разрушающих функций</h2>"

#: in/chapter11.html:221
msgid ""
"<p>Some operations on lists (and sequences -- see <a\n"
"href=\"chapter12.html\">Chapter 12</a>) have both destructive and\n"
"nondestructive counterparts."
msgstr ""
"<p>\n"
"Некоторые операции над списками (и последовательностями-см. \n"
"<a href=\"chapter12.html\">Главу 12</a>) имеют как разрушающие,\n"
"так и неразрушающие аналоги."

#: in/chapter11.html:236
msgid ""
"<pre>\n"
"Nondestructive    Destructive\n"
"--------------    -----------\n"
"SUBLIS            NSUBLIS\n"
"SUBST             NSUBST\n"
"SUBST-IF          NSUBST-IF\n"
"SUBST-IF-NOT      NSUBST-IF-NOT\n"
"APPEND            NCONC\n"
"REVAPPEND         NRECONC\n"
"BUTLAST           NBUTLAST\n"
"INTERSECTION      NINTERSECTION\n"
"SET-DIFFERENCE    NSET-DIFFERENCE\n"
"SET-EXCLUSIVE-OR  NSET-EXCLUSIVE-OR\n"
"UNION             NUNION"
msgstr ""

#: in/chapter11.html:246
msgid ""
"REVERSE           NREVERSE\n"
"REMOVE            DELETE\n"
"REMOVE-IF         DELETE-IF\n"
"REMOVE-IF-NOT     DELETE-IF-NOT\n"
"SUBSTITUTE        NSUBSTITUTE\n"
"SUBSTITUTE-IF     NSUBSTITUTE-IF\n"
"SUBSTITUTE-IF-NOT NSUBSTITUTE-IF-NOT\n"
"REMOVE-DUPLICATES DELETE-DUPLICATES\n"
"</pre> "
msgstr ""

#: in/chapter11.html:251
msgid ""
"<p>All of these pairings have the same relationship: the destructive\n"
"version may be faster, but may also alter shared structure.  Consider,\n"
"for example, <code>APPEND</code> and <code>NCONC</code>. Both append\n"
"the lists supplied as their arguments. "
msgstr ""
"<p>Все эти пары имеют одно и то же отношение: разрушающая версия может \n"
"быть быстрее, но также может изменить общую структуру. Рассмотрим, "
"например,\n"
"<code>APPEND</code> и <code>NCONC</code>. Оба они добавляют списки,\n"
"предоставленные в качестве своих аргументов."

#: in/chapter11.html:258
msgid ""
"<pre>\n"
"? (append (list 1 2 3) (list 4 5 6))\n"
"(1 2 3 4 5 6)\n"
"? (nconc (list 1 2 3) (list 4 5 6))\n"
"(1 2 3 4 5 6)\n"
"</pre> "
msgstr ""

#: in/chapter11.html:262
msgid ""
"<p>But <code>NCONC</code> may destructively modify all but the final\n"
"list; it may change the tail of each list to point to the head of\n"
"the next list. "
msgstr ""
"<p>Но <code>NCONC</code> может разрушающе изменить все, кроме конечного\n"
"(последнего) списка; он может изменить хвост каждого списка, чтобы указать \n"
"на начало следующего списка.. "

#: in/chapter11.html:281
msgid ""
"<pre>\n"
"? (defparameter list1 (list 1 2 3))\n"
"LIST1\n"
"? (defparameter list2 (list 4 5 6))\n"
"LIST2\n"
"? (append list1 list2)\n"
"(1 2 3 4 5 6)\n"
"? list1\n"
"(1 2 3)\n"
"? list2\n"
"(4 5 6)\n"
"? (nconc list1 list2)\n"
"(1 2 3 4 5 6)\n"
"? list1\n"
"(1 2 3 4 5 6) <i>; Oops - compare to previous result!</i> \n"
"? list2\n"
"(4 5 6)\n"
"</pre> "
msgstr ""

#: in/chapter11.html:283
msgid "<h2>RPLACA, RPLACD, SETF ...; circularity</h2>"
msgstr "<h2>RPLACA, RPLACD, SETF ...; (круговые списки)circularity</h2>"

#: in/chapter11.html:289
msgid ""
"<p>A list is constructed of <code>CONS</code> cells. Each CONS has\n"
"two parts, a <code>CAR</code> and a <code>CDR</code> (review <a\n"
"href=\"chapter03-04.html\">Chapter 3, Lesson 4</a>). The CAR holds the\n"
"data for one element of the list, and the CDR holds the CONS that\n"
"makes up the head of the rest of the list."
msgstr ""
"<p>Список строится из  <code>CONS</code> ячеек. Каждый  CONS состоит \n"
"из двух частей, <code>CAR</code> и <code>CDR</code> (см \n"
"<a href=\"chapter03-04.html\">Глава 3, Урок 4</a>). CAR содержит данные \n"
"для одного элемента списка, а CDR содержит CONS, которые составляют \n"
"голову/начало оставшейся части списка(rest)."

#: in/chapter11.html:291
msgid "<p><img src=\"gifs/list-box-and-arrow.gif\">"
msgstr ""

#: in/chapter11.html:296
msgid ""
"<p>By using <code>RPLACA</code> and <code>RPLACD</code> to change\n"
"the two fields of a CONS, we can (destructively) alter the normal\n"
"structure of a list. For example, we could splice out the second\n"
"element of a list like this:"
msgstr ""
"<p>\n"
"Используя <code>RPLACA</code> и <code>RPLACD</code> для изменения \n"
"двух полей CONS, мы можем (разрушающе)изменить нормальную структуру \n"
"списка. Например, мы могли бы вырезать второй элемент списка следующим "
"образом:"

#: in/chapter11.html:305
msgid ""
"<pre>\n"
"? (defparameter *my-list* (list 1 2 3 4))\n"
"*MY-LIST*\n"
"? (rplacd *my-list* (cdr (cdr *my-list*)))\n"
"(1 3 4)\n"
"? *my-list*\n"
"(1 3 4)\n"
"</pre> "
msgstr ""

#: in/chapter11.html:308
msgid ""
"<p>We can also use these \"list surgery operators\" to create circular\n"
"lists."
msgstr ""
"<p>Мы также можем использовать эти \"операторы препарирования списков\" \n"
"для создания круговых списков."

#: in/chapter11.html:319
msgid ""
"<pre>\n"
"? (let ((l (list 1)))\n"
"    (rplacd l l)\n"
"    l)\n"
"(1 1 1 1 1 1 1 1 ... <i>; Continues until interrupt or stack overflow</i> \n"
"? (let ((l (list 2)))\n"
"    (rplaca l l)\n"
"    l)\n"
"(((((((((((((((( ... <i>; Continues until interrupt or stack overflow</i> \n"
"</pre> "
msgstr ""

#: in/chapter11.html:321
msgid "<p><img src=\"gifs/rplaca-rplacd.gif\">"
msgstr ""

#: in/chapter11.html:325
msgid ""
"<p>We can get the same effect using <code>(SETF CAR)</code> in place\n"
"of <code>RPLACA</code> and <code>(SETF CDR)</code> in place of\n"
"<code>RPLACD</code>. "
msgstr ""
"<p>Мы можем получить тот же эффект, используя <code>(SETF CAR)</code> \n"
"вместо <code>RPLACA</code> и <code>(SETF CDR)</code> вместо \n"
"<code>RPLACD</code>. "

#: in/chapter11.html:330
msgid ""
"<pre>\n"
"(rplaca cons object) <i>is</i> (setf (car cons) object)\n"
"(rplacd cons object) <i>is</i> (setf (cdr cons) object)\n"
"</pre> "
msgstr ""

#: in/chapter11.html:335
msgid ""
"<p>The nice thing about the <code>SETF</code> notation is that it\n"
"readily generalizes to other list accessors, such as\n"
"<code>NTH</code>, <code>LAST</code>, <code>NTHCDR</code>, and\n"
"<code>FOURTH</code>."
msgstr ""
"<p>Хорошая вещь в нотации <code>SETF</code> заключается в том, \n"
"что он легко обобщается на другие методы доступа к списку, такие как, \n"
"<code>NTH</code>, <code>LAST</code>, <code>NTHCDR</code>, и\n"
"<code>FOURTH</code>."

#: in/chapter11.html:337
msgid ""
"<h2>Places vs. values: destructive functions don't always have the desired "
"side-effect</h2>"
msgstr ""
"<h2>Место против значения: разрушающие функции не всегда имеют\n"
"желаемый побочный эффект</h2>"

#: in/chapter11.html:349
msgid ""
"<p>A nondestructive function such as <code>REVERSE</code> always\n"
"returns a freshly constructed result, so there's never any question\n"
"but that you need to pay attention to the result. But a destructive\n"
"function such as <code>NREVERSE</code> <em>sometimes</em> modifies\n"
"its argument in such a way that the changed argument is identical to\n"
"the function result. This leads some programmers to assume that\n"
"destructive functions <em>always</em> modify the argument to match\n"
"the result. Unfortunately, this is not true; leading to the second\n"
"important point about the use of destructive functions: you should\n"
"use the result of a destructive function the same way that you would\n"
"use the result of its nondestructive counterpart."
msgstr ""
"<p>\n"
"Неразрушающая функция, такая как <code>REVERSE</code>, всегда \n"
"возвращает только что построенный результат, поэтому никогда не \n"
"возникает никаких вопросов, кроме того, что вам нужно обратить \n"
"внимание на результат. Но разрушающая функция, такая как \n"
"<code>NREVERSE</code>, иногда изменяет свой аргумент таким образом, \n"
"что измененный аргумент идентичен результату функции. Это приводит \n"
"некоторых программистов к предположению, что разрушающие функции \n"
"<em>всегда</em> изменяют аргумент, чтобы соответствовать результату. \n"
"К сожалению, это не так; переходим ко второму важному пункту об \n"
"использовании разрушающих функций: вы должны использовать результат\n"
"разрушающей функции так же, как вы использовали бы результат ее \n"
"неразрушающего аналога."

#: in/chapter11.html:353
msgid ""
"<blockquote> This also applies to <code>SORT</code> and\n"
"<code>STABLE-SORT</code>, which are destructive and do not have a\n"
"nondestructive counterpart. </blockquote> "
msgstr ""
"<blockquote> Это также относится к <code>SORT</code> и\n"
"<code>STABLE-SORT</code>, которые являются разрушающими и \n"
"не имеют неразрушающего аналога. </blockquote> "

#: in/chapter11.html:355
msgid "<h2>Contrast e.g. PUSH and DELETE</h2>"
msgstr "<h2>Разница/контраст, например между PUSH и DELETE</h2>"

#: in/chapter11.html:358
msgid ""
"<p>Here's an example showing why you should not depend upon\n"
"<code>DELETE</code>'s side-effects."
msgstr ""
"<p>Вот пример, показывающий, почему вы не должны зависеть от \n"
"побочных эффектов <code>DELETE</code>."

#: in/chapter11.html:371
msgid ""
"<pre>\n"
"? (defparameter *my-list (list 1 2 3 4))\n"
"*MY-LIST*\n"
"? (delete 3 *my-list*)\n"
"(1 2 4)\n"
"? *my-list*\n"
"(1 2 4)\n"
"? (delete 1 *my-list*)\n"
"(2 4)\n"
"? *my-list*\n"
"(1 2 4) <i>; Not the same as function result</i> \n"
"</pre> "
msgstr ""

#: in/chapter11.html:375
msgid ""
"<p>But some macros, for example <code>PUSH</code> and <code>POP</code>, "
"take\n"
"a <em>place</em> as an argument and arrange to update the place with the\n"
"correct value."
msgstr ""
"<p>Но некоторые макросы, например <code>PUSH</code> и <code>POP</code>,\n"
"принимают место в качестве аргумента и организуют обновление места \n"
"с правильным значением."

#: in/chapter11.html:392
msgid ""
"<pre>\n"
"? (defparameter *stack* ())\n"
"*STACK*\n"
"? (push 3 *stack*)\n"
"(3)\n"
"? (push 2 *stack*)\n"
"(2 3)\n"
"? (push 1 *stack*)\n"
"(1 2 3)\n"
"? *stack*\n"
"(1 2 3)\n"
"? (pop *stack*)\n"
"1\n"
"? *stack*\n"
"(2 3)\n"
"</pre> "
msgstr ""

#: in/chapter11.html:394
msgid "<h2>Shared and constant data: Dangers of destructive changes</h2>"
msgstr ""
"<h2>Разделяемые(Shared) и постоянные(constant) данные: \n"
"Опасность разрушающих изменений</h2>"

#: in/chapter11.html:399
msgid ""
"<p>When you use destructive functions you should be sure to only\n"
"modify data that your program has constructed at runtime. Here's an\n"
"example of what can happen if you destructively modify a constant\n"
"list."
msgstr ""
"<p>Когда вы используете разрушающие функции, вы должны быть уверены, \n"
"что изменяете только те данные, которые ваша программа создала во \n"
"время выполнения. Вот пример того, что может произойти, если вы \n"
"разрушающе измените постоянный список."

#: in/chapter11.html:414
msgid ""
"<pre>\n"
"? (defun stomp-a-constant ()\n"
"    (let ((l '(1 2 3))) <i>; compile-time constant data</i> \n"
"      (print l)\n"
"      (setf (second l) nil) <i>; destructive modification</i> \n"
"      l))\n"
"STOMP-A-CONSTANT\n"
"? (stomp-a-constant)\n"
"(1 2 3)\n"
"(1 NIL 3)\n"
"? (stomp-a-constant)\n"
"(1 NIL 3)\n"
"(1 NIL 3)\n"
"</pre> "
msgstr ""

#: in/chapter11.html:419
msgid ""
"<p>This function is effectively modifying itself, as it changes the\n"
"constant data which is bound to the variable <code>L</code>. The\n"
"effects of this change show up in the first line of output on the\n"
"second run (and all subsequent runs)."
msgstr ""
"<p>Эта функция эффективно модифицирует себя, поскольку она \n"
"изменяет постоянные данные, которые привязаны к переменной <code>L</code>.\n"
"Эффекты этого изменения проявляются в первой строке вывода \n"
"при втором запуске (и во всех последующих запусках).\n"

#: in/chapter11.html:424
msgid ""
"<p>If you replace <code>'(1 2 3)</code> (which may be compiled into\n"
"constant data) with <code>(list 1 2 3)</code> (which always creates\n"
"a fresh list at run time) then the function's behavior will be\n"
"identical on the first and all subsequent runs."
msgstr ""
"<p>Если вы замените <code>'(1 2 3)</code> (который может быть \n"
"скомпилирован в постоянные данные) на <code>(list 1 2 3)</code> \n"
"(который всегда создает свежий список во время выполнения), \n"
"то поведение функции будет идентичным как при первом, так и при\n"
"всех  последующих запусках."

#: in/chapter11.html:437
msgid ""
"<hr>\n"
"<div align=\"center\">\n"
"<a href=\"contents.html\">Contents</a> | <a href=\"cover.html\">Cover</a> "
"<br> \n"
"<a href=\"chapter10.html\">Chapter 10</a> | Chapter 11 | <a href=\"chapter12."
"html\">Chapter 12</a> \n"
"</div>\n"
"<hr>\n"
"<address>\n"
"Copyright &copy; 1995-2001, David B. Lamkins<br>\n"
"All Rights Reserved Worldwide<br>\n"
"<br>\n"
"This book may not be reproduced without the written consent of its author.  "
"Online distribution is restricted to the author's site.\n"
"</address> \n"
"</body> </html> "
msgstr ""
