#
# NuINu <don't@send.my>, 2020.
#
#. extracted from in/chapter12.html
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-04-19 13:50+0300\n"
"PO-Revision-Date: 2020-06-12 19:53+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter12.html:5
msgid ""
"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/"
"html4/strict.dtd\">\n"
"<html><head>\n"
"<title>Successful Lisp - Chapter 12</title>\n"
"</head> "
msgstr ""
"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/"
"html4/strict.dtd\">\n"
"<html><head>\n"
"<META http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n"
"<title>Successful Lisp - Chapter 12</title>\n"
"</head> "

#: in/chapter12.html:8
msgid ""
"<body bgcolor=\"white\" text=\"black\">\n"
"<h1>Chapter 12 - Mapping Instead of Iteration</h1> "
msgstr ""
"<body bgcolor=\"white\" text=\"black\">\n"
"<h1>Глава 12 - Отображение(Mapping) вместо Итерации</h1> "

#: in/chapter12.html:15
msgid ""
"<p>In this chapter we'll survey of a group of functions collectively\n"
"known as mapping functions. You can think of a mapping function as a\n"
"kind of special purpose iterator. Every mapping function expects you\n"
"to supply a function. A typical mapping function applies your\n"
"function to every element of the supplied list(s). One variation on\n"
"this theme applies your function to successive sublists."
msgstr ""
"<p>В этой главе мы рассмотрим группу функций, которые в совокупности \n"
"называются функциями отображения. Вы можете представить себе функцию \n"
"отображения как своего рода итератор специального назначения. Каждая \n"
"функция отображения ожидает, что вы предоставите ей функцию. Типичная \n"
"функция отображения применяет вашу функцию к каждому элементу \n"
"предоставленного ей списка(списков). Один из вариантов этой темы \n"
"применяет вашу функцию к последовательности подсписков."

#: in/chapter12.html:20
msgid ""
"<p>A sequence is a generalization of the list data type. Vectors\n"
"(one-dimensional arrays) and lists are specializations of the\n"
"sequence data type. Some mapping functions work only with lists as\n"
"inputs, while others accept sequences."
msgstr ""
"<p>Последовательность-это обобщение типа данных списка. \n"
"Векторы (одномерные массивы) и списки являются специализациями типа \n"
"данных последовательности(sequence). Некоторые функции отображения \n"
"работают только со списками в качестве входных данных, в то время \n"
"как другие принимают последовательности"

#: in/chapter12.html:22
msgid "<h2>MAPCAR, MAPC, and MAPCAN process successive list elements</h2>"
msgstr ""
"<h2>MAPCAR, MAPC, и MAPCAN обрабатывают последовательные элементы списка</h2>"

#: in/chapter12.html:26
msgid ""
"<p>The first group of mapping functions processes successive elements\n"
"of lists. The mapping functions in this group differ in how they\n"
"construct a return value."
msgstr ""
"<p>Первая группа функций отображения обрабатывает последовательные \n"
"элементы списков. Функции отображения в этой группе отличаются тем, \n"
"как они строят возвращаемое значение."

#: in/chapter12.html:35
msgid ""
"<p><code>MAPCAR</code> processes successive elements of one or more\n"
"supplied lists. You must supply a function that accepts as many\n"
"arguments as the number of lists you supply to <code>MAPCAR</code>,\n"
"which applies your function to successive elements and combines the\n"
"function's results into a freshly constructed list. The mapping\n"
"stops upon reaching the end of the shortest list;\n"
"<code>MAPCAR</code>'s result has as many elements as the shortest\n"
"input list."
msgstr ""
"<p><code>MAPCAR</code> обрабатывает последовательные элементы \n"
"одного или нескольких предоставленных списков. Вы должны предоставить \n"
"функцию, которая принимает столько же аргументов, равное количеству "
"списков, \n"
"которые вы предоставляете <code>MAPCAR</code>, который применяет вашу \n"
"функцию к последовательным элементам и объединяет результаты функции в \n"
"только что созданный список. Отображение останавливается по достижении \n"
"конца самого короткого списка; результат <code>MAPCAR</code> имеет столько \n"
"же элементов, сколько и самый короткий входной список."

#: in/chapter12.html:40
msgid ""
"<p><code>MAPC</code> does not combine the results of applying your\n"
"function to successive elements of the input list(s). Instead, it\n"
"processes the inputs just for effect, and returns the first input\n"
"list as the result of <code>MAPC</code>."
msgstr ""
"<p><code>MAPC</code> не объединяет результаты применения вашей функции \n"
"к последовательным элементам входного списка(ов). Вместо этого он \n"
"обрабатывает входные данные только ради эффекта и возвращает первый \n"
"список входных данных в качестве результата <code>MAPC</code>."

#: in/chapter12.html:46
msgid ""
"<p><code>MAPCAN</code> combines results using the destructive\n"
"function <code>NCONC</code>. Since <code>NCONC</code> -- like its\n"
"nondestructive counterpart <code>APPEND</code> -- expects its\n"
"arguments to be lists, the function you supply to\n"
"<code>MAPCAN</code> must always return a list."
msgstr ""
"<p>\n"
"<code>MAPCAN</code> объединяет результаты, используя разрушающую \n"
"функцию <code>NCONC</code>. Поскольку <code>NCONC</code> - как и его\n"
"неразрушающий аналог <code>APPEND</code>-ожидает, что его аргументы будут\n"
"списками, функция, которую вы предоставляете <code>MAPCAN</code>, всегда \n"
"должна возвращать список."

#: in/chapter12.html:53
msgid ""
"<pre>\n"
"? (mapcar #'atom (list 1 '(2) \"foo\" nil))\n"
"(T NIL T T)\n"
"? (mapcar #'+ (list 1 2 3) (list 4 5 6))\n"
"(5 7 9)\n"
"? (mapc #'(lambda (x y) (print (* x y))) (list 1 0 2) (list 3 4 5))"
msgstr ""

#: in/chapter12.html:63
msgid ""
"3\n"
"0\n"
"10\n"
"(1 0 2)\n"
"? (mapcan #'list (list 1 2 3) (list 4 5 6))\n"
"(1 4 2 5 3 6)\n"
"? (mapcan #'(lambda (a b) (list (cons a b))) (list 1 2 3) (list 4 5 6))\n"
"((1 . 4) (2 . 5) (3 . 6))\n"
"</pre> "
msgstr ""

#: in/chapter12.html:65
msgid "<h2>MAPLIST, MAPL, and MAPCON process successive sublists</h2>"
msgstr ""
"<h2>MAPLIST, MAPL, и MAPCON обрабатывают последовательные подсписки</h2>"

#: in/chapter12.html:74
msgid ""
"<p><code>MAPLIST</code> processes successive sublists of one or more\n"
"supplied lists. You must supply a function that accepts as many\n"
"arguments as the number of lists you supply to <code>MAPLIST</code>,\n"
"which applies your function to successive sublists and combines the\n"
"function's results into a freshly constructed list. The mapping\n"
"stops upon reaching the end of the shortest list;\n"
"<code>MAPLIST</code>'s result has as many elements as the shortest\n"
"input list."
msgstr ""
"<p><code>MAPLIST</code> обрабатывает последовательные подсписки одного \n"
"или нескольких предоставленных списков. Вы должны предоставить функцию, \n"
"которая принимает столько же аргументов, сколько количество списков, \n"
"которые вы предоставляете <code>MAPLIST</code>, который применяет вашу\n"
"функцию к последовательным подспискам и объединяет результаты функции в \n"
"только что созданный список. Отображение останавливается по достижении \n"
"конца самого короткого списка; результат <code>MAPLIST</code> имеет "
"столько \n"
"же элементов, сколько и самый короткий входной список."

#: in/chapter12.html:79
msgid ""
"<p><code>MAPL</code> does not combine the results of applying your\n"
"function to successive sublists of the input list(s). Instead, it\n"
"processes the inputs just for effect, and returns the first input\n"
"list as the result of <code>MAPL</code>."
msgstr ""
"<p><code>MAPL</code> не объединяет результаты применения вашей \n"
"функции к последовательным подспискам входного списка(ов). Вместо \n"
"этого он обрабатывает входные данные только ради сторонних эффектов \n"
"и возвращает первый список входных данных в результате <code>MAPL</code>."

#: in/chapter12.html:85
msgid ""
"<p><code>MAPCON</code> combines results using the destructive\n"
"function <code>NCONC</code>. Since <code>NCONC</code> -- like its\n"
"nondestructive counterpart <code>APPEND</code> -- expects its\n"
"arguments to be lists, the function you supply to\n"
"<code>MAPCON</code> must always return a list."
msgstr ""
"<p><code>MAPCON</code>  объединяет результаты, используя \n"
"разрушающую функцию <code>NCONC</code>. Поскольку <code>NCONC</code>\n"
"- как и его неразрушающий аналог <code>APPEND</code> - ожидает, что е\n"
"го аргументы будут списками, функция, которую вы предоставляете \n"
"<code>MAPCON</code>, всегда должна возвращать список."

#: in/chapter12.html:90
msgid ""
"<pre>\n"
"? (maplist #'list (list 1 2 3) (list 4 5 6))\n"
"(((1 2 3) (4 5 6)) ((2 3) (5 6)) ((3) (6)))\n"
"? (mapl #'(lambda (x y) (print (append x y))) (list 1 0 2) (list 3 4 5))"
msgstr ""

#: in/chapter12.html:98
msgid ""
"(1 0 2 3 4 5) \n"
"(0 2 4 5) \n"
"(2 5) \n"
"(1 0 2)\n"
"? (mapcon #'list (list 1 2 3) (list 4 5 6))\n"
"((1 2 3) (4 5 6) (2 3) (5 6) (3) (6))\n"
"</pre> "
msgstr ""

#: in/chapter12.html:100
msgid "<h2>MAP and MAP-INTO work on sequences, not just lists</h2>"
msgstr ""
"<h2>MAP и MAP-INTO работают с последовательностями,\n"
"а не только со списками</h2>"

#: in/chapter12.html:106
msgid ""
"<p>A sequence is either a list or a vector (a one-dimensional array).\n"
"The previous group of mapping functions (<code>MAPCAR</code> et al)\n"
"processes successive CARs or CDRs of their input lists. <code>MAP</code> \n"
"and <code>MAP-INTO</code> process successive elements of their input\n"
"sequences."
msgstr ""
"<p>\n"
"Последовательность - это либо список, либо вектор (одномерный массив). \n"
"Предыдущая группа  функций отображения (MAPCAR и иже с ним) обрабатывали "
"последовательные CAR или CDRs их входных списков. <code>MAP</code> \n"
"и  <code>MAP-INTO</code> обрабатывают последовательные элементы входной\n"
"последовательности.\n"

#: in/chapter12.html:109
msgid ""
"<p><code>MAP</code> requires that you specify the type of its result\n"
"using one of the following designators:"
msgstr ""
"<p><code>MAP</code> требует, чтобы вы указали тип ее результата, \n"
"используя одно из следующих обозначений:"

#: in/chapter12.html:117
msgid ""
"<pre>\n"
"Designator   Result\n"
"----------   ------\n"
"NIL          NIL\n"
"'LIST        a list\n"
"'VECTOR      a vector\n"
"</pre> "
msgstr ""

#: in/chapter12.html:121
msgid ""
"<p>Note that you can also specify subtypes of <code>LIST</code> or\n"
"<code>VECTOR</code> -- your Lisp implementation may be able to optimize\n"
"the storage of the result based on the type you specify."
msgstr ""
"<p>\n"
"Обратите внимание, что вы также можете указать подтипы <code>LIST</code>\n"
"или <code>VECTOR</code> - ваша реализация Lisp может оптимизировать \n"
"хранение результата на основе указанного типа."

#: in/chapter12.html:132
msgid ""
"<pre>\n"
"? (map nil #'+ (list 1 2 3) (list 4 5 6))\n"
"NIL\n"
"? (map 'list #'+ (list 1 2 3) (list 4 5 6))\n"
"(5 7 9)\n"
"? (map 'vector #'+ (list 1 2 3) (list 4 5 6))\n"
"#(5 7 9)\n"
"? (map '(vector number 3) #'+ (list 1 2 3) (list 4 5 6))\n"
"#(5 7 9)\n"
"</pre> "
msgstr ""

#: in/chapter12.html:141
msgid ""
"<p><code>MAP-INTO</code> is a destructive version of\n"
"<code>MAP</code>. The first argument is a sequence that receives the\n"
"results of the mapping. Mapping stops upon reaching the end of the\n"
"result sequence or any of the input sequences. (Therefore, if you\n"
"specify <code>NIL</code> as the result sequence, no mapping is\n"
"performed since <code>NIL</code> is a list of length zero.)  The \n"
"input sequences are not modified.  The modified result sequence is\n"
"returned as the value of <code>MAP-INTO</code>."
msgstr ""
"<p><code>MAP-INTO</code> - это разрушающая версия <code>MAP</code>.\n"
"Первый аргумент - это последовательность, которая получает результаты "
"сопоставления. Отображение останавливается по достижении конца \n"
"результирующей последовательности или любой из входных последовательностей.\n"
"(Поэтому, если в качестве результирующей последовательности указать \n"
"<code>NIL</code>, сопоставление не выполняется, так как <code>NIL</code> -\n"
"это список нулевой длины.) Входные последовательности не изменяются. \n"
"Измененная последовательность результатов возвращается в виде значения \n"
"<code>MAP-INTO</code>."

#: in/chapter12.html:147
msgid ""
"<pre>\n"
"? (let ((a (make-sequence 'list 3)))\n"
"    (print a)\n"
"    (map-into a #'+ (list 1 2 3) (list 4 5 6))\n"
"    a)"
msgstr ""

#: in/chapter12.html:154
msgid ""
"(NIL NIL NIL)\n"
"(5 7 9)\n"
"? (let ((a (make-sequence 'vector 3)))\n"
"    (print a)\n"
"    (map-into a #'+ (list 1 2 3) (list 4 5 6))\n"
"    a)"
msgstr ""

#: in/chapter12.html:158
msgid ""
"#(0 0 0)\n"
"#(5 7 9)\n"
"</pre> "
msgstr ""

#: in/chapter12.html:163
msgid ""
"<p>Your Lisp implementation may print different initial values for\n"
"the unmodified sequences in the above examples.  If you need to specify\n"
"a certain initial value for <code>MAKE-SEQUENCE</code>, use the \n"
"<code>:INITIAL-ELEMENT</code> keyword argument:"
msgstr ""
"<p>\n"
"Ваша реализация Lisp может печатать различные начальные значения для\n"
"немодифицированных последовательностей в приведенных выше примерах. \n"
"Если вам необходимо задать некоторое начальное значение для \n"
"<code>MAKE-SEQUENCE</code>, используйте ключевое слово\n"
"<code>:INITIAL-ELEMENT</code>"

#: in/chapter12.html:169
msgid ""
"<pre>\n"
"? (let ((a (make-sequence 'list 3 :initial-element 0)))\n"
"    (print a)\n"
"    (map-into a #'+ (list 1 2 3) (list 4 5 6))\n"
"    a)"
msgstr ""

#: in/chapter12.html:173
msgid ""
"(0 0 0)\n"
"(5 7 9)\n"
"</pre> "
msgstr ""

#: in/chapter12.html:175
msgid "<h2>Mapping functions are good for filtering</h2>"
msgstr "<h2>Функции отображения хороши для фильтрации</h2>"

#: in/chapter12.html:179
msgid ""
"<p>A filter passes some of its inputs through to its output, and drops\n"
"others.  We can use mapping functions to implement filters by taking note\n"
"of the behavior of <code>APPEND</code>:"
msgstr ""
"<p>\n"
"Фильтр пропускает некоторые из своих входных вещей через свой выход,\n"
"и отбрасывает другие. Мы можем использовать функции отображения для \n"
"реализации фильтров, принимая во внимание поведение <code>APPEND</code>:"

#: in/chapter12.html:184
msgid ""
"<pre>\n"
"? (append '(1) nil '(3) '(4))\n"
"(1 3 4)\n"
"</pre> "
msgstr ""

#: in/chapter12.html:189
msgid ""
"<p>The <code>NIL</code> argument (which is equivalent to the empty list)\n"
"simply \"disappears\" from the result. This is the key observation that we\n"
"need to construct a filter. We'll use <code>MAPCAN</code> to map over our\n"
"input list(s) and supply a mapping function that:"
msgstr ""
"<p>\n"
"Аргумент <code>NIL</code> (который эквивалентен пустому списку) просто \n"
"\"исчезает\" из результата. Это ключевое наблюдение, которое нам "
"необходимо \n"
"для построения фильтра. Мы будем использовать <code>MAPCAN</code> для \n"
"отображения нашего входного списка(ов) и предоставления функции отображения, "
"которая:"

#: in/chapter12.html:195
msgid ""
"<ul>\n"
"<li>makes a list of each result we wish to retain in the output, or\n"
"<li>returns <code>NIL</code> in place of each input we wish to \n"
"    exclude from the output.\n"
"</ul> "
msgstr ""
"<ul>\n"
"<li>делает список каждого результата, который мы хотим сохранить в выходных "
"данных, или\n"
"<li>возвращает NIL вместо каждого входа, который мы хотим исключить из "
"выходных данных.\n"
"</ul> "

#: in/chapter12.html:203
msgid ""
"<pre>\n"
"? (defun filter-even-numbers (numbers)\n"
"    (mapcan #'(lambda (n) (when (evenp n) (list n))) numbers))\n"
"FILTER-EVEN-NUMBERS\n"
"? (filter-even-numbers (list 1 2 3 4 5 6 7 8))\n"
"(2 4 6 8)\n"
"</pre> "
msgstr ""

#: in/chapter12.html:207
msgid ""
"<blockquote> <code>WHEN</code> returns <code>NIL</code> if the\n"
"condition is <code>NIL</code>. We could have written <code>(if\n"
"(evenp n) (list n) nil)</code> instead. </blockquote> "
msgstr ""
"<blockquote> \n"
"<code>WHEN</code> возвращает NIL, если условие равно <code>NIL</code>.\n"
"Вместо этого мы могли бы написать \n"
" <code>(if (evenp n) (list n) nil)</code> . </blockquote> "

#: in/chapter12.html:210
msgid ""
"<p>Here's a slightly more complex filter that returns a list of \n"
"evenly divisible pairs of numerators and denominators:"
msgstr ""
"<p>\n"
"Вот немного более сложный фильтр, который возвращает список нацело \n"
"делимых пар числителей и знаменателей:"

#: in/chapter12.html:222
msgid ""
"<pre>\n"
"? (defun filter-evenly-divisible (numerators denominators)\n"
"    (mapcan #'(lambda (n d)\n"
"                (if (zerop (mod n d))\n"
"                  (list (list n d))\n"
"                  nil))\n"
"            numerators denominators))\n"
"? (filter-evenly-divisible (list 7 8 9 10 11 12)\n"
"                           (list 1 4 5  5  2  3))\n"
"((7 1) (8 4) (10 5) (12 3))\n"
"</pre> "
msgstr ""

#: in/chapter12.html:230
msgid ""
"<p>The functions <code>REMOVE-IF</code> and\n"
"<code>REMOVE-IF-NOT</code> (and their destructive counterparts,\n"
"<code>DELETE-IF</code> and <code>DELETE-IF-NOT</code>) filter a\n"
"single sequence, but can't be used for multiple sequences (as in the\n"
"example above). Use <code>REMOVE-IF</code> and the like if it will\n"
"make your code clearer. See <a href=\"chapter13.html\">Chapter 13</a>\n"
"for further details."
msgstr ""
"<p>\n"
"Функции <code>REMOVE-IF</code> и <code>REMOVE-IF-NOT</code>\n"
"(а также их разрушающие аналоги, <code>DELETE-IF</code> и \n"
"<code>DELETE-IF-NOT</code>) фильтруют одну последовательность, но \n"
"не могут использоваться для нескольких последовательностей \n"
"(как в приведенном выше примере). Используйте <code>REMOVE-IF</code> \n"
"и тому подобное, если это сделает ваш код более понятным. \n"
"Дополнительную информацию см. В <a href=\"chapter13.html\">Главу 13</a>."

#: in/chapter12.html:232
msgid "<h2>It's better to avoid mapping if you care about efficiency</h2>"
msgstr ""
"<h2>Лучше избегать отображения, если вы заботитесь об эффективности</h2>"

#: in/chapter12.html:240
msgid ""
"<p>Most Lisp systems will generate more efficient code to call\n"
"a function that is known during compilation than a function that can\n"
"change at run time.  Mapping functions accept a functional argument,\n"
"and most compilers will generate code that supports run time function\n"
"binding -- even if you specify a \"constant\" function, such as <code>#'+</"
"code>.\n"
"Also, the run time call may incur extra overhead to generate a list of\n"
"arguments for the function's application."
msgstr ""
"<p>\n"
"Большинство систем Lisp генерируют более эффективный код для вызова "
"функции,\n"
"которая известна во время компиляции, чем функция, которая может "
"изменяться \n"
"во время выполнения. Функции отображения принимают функциональный "
"аргумент, \n"
"и большинство компиляторов генерируют код, поддерживающий привязку функций\n"
"времени выполнения - даже если вы задаете \"постоянную\" функцию, такую как\n"
"<code>#'+</code>. Кроме того, вызов времени выполнения может потребовать\n"
"дополнительных накладных расходов для создания списка аргументов для \n"
"применения функции."

#: in/chapter12.html:247
msgid ""
"<p>Therefore, if you are concerned about efficiency you should write\n"
"map-like functions using iteration instead of mapping functions. But\n"
"do this only when you are sure that efficiency is an issue for the\n"
"portion of the program you intend to rewrite. See <a\n"
"href=\"chapter28.html\">Chapter 28</a> for a discussion of profiling,\n"
"which can help you find your program's performance bottlenecks."
msgstr ""
"<p>\n"
"Поэтому, если вы беспокоитесь об эффективности, вам следует писать\n"
"функции подобные отображению, используя итерацию вместо  функций\n"
"отображения. Но делайте это только тогда, когда вы уверены, что \n"
"эффективность является проблемой для той части программы, которую \n"
"вы собираетесь переписать. См. <a href=\"chapter28.html\">Главу 28</a> \n"
"для обсуждения профилирования, которое может помочь вам найти \n"
"узкие места производительности вашей программы."

#: in/chapter12.html:249
msgid "<h2>Predicate mapping functions test sequences</h2>"
msgstr ""
"<h2>Проверка последовательностей с помощью функций отображения предикатов</"
"h2>"

#: in/chapter12.html:258
msgid ""
"<p>Sometimes you may need to apply a test to some input sequences\n"
"and return a truth value based upon what the test returned for all\n"
"of the inputs. For example, you might want to know whether any\n"
"number in a sequence is outside of a specified range, or whether\n"
"every word is at least five letters long. You could construct these\n"
"tests from the mapping functions described above, but that would be\n"
"more verbose (and less efficient) than using the predicate mapping\n"
"functions provided by Lisp."
msgstr ""
"<p>\n"
"Иногда вам может потребоваться применить тест к некоторым входным\n"
"последовательностям и вернуть истинное значение, основанное на том, \n"
"что тест вернул для всех входных данных. Например, вы можете узнать, \n"
"находится ли какое-либо число в последовательности вне указанного "
"диапазона \n"
"или что каждое слово имеет длину не менее пяти букв. Вы можете построить \n"
"эти тесты из функций отображения, описанных выше, но это будет более \n"
"многословный код (и менее эффективный), чем использование функций "
"отображения \n"
"предикатов, предоставляемых Lisp."

#: in/chapter12.html:260
msgid "<h2>SOME, EVERY, NOTANY, NOTEVERY</h2>"
msgstr "<h2>SOME, EVERY, NOTANY, NOTEVERY</h2>"

#: in/chapter12.html:266
msgid ""
"<p>The built in predicate mapping functions expect you to supply a\n"
"test function (a.k.a. predicate) and one or more input sequences.\n"
"The predicate is applied to successive elements of the input\n"
"sequences until the the result of the mapping function can be\n"
"determined."
msgstr ""
"<p>\n"
"Встроенные функции отображения предикатов ожидают, что вы предоставите \n"
"тестовую функцию (она же предикат) и одну или несколько входных\n"
"последовательностей. Предикат применяется к последовательным элементам \n"
"входных последовательностей до тех пор, пока не будет определен результат \n"
"функции отображения."

#: in/chapter12.html:275
msgid ""
"<pre>\n"
"Function   Condition\n"
"--------   ---------\n"
"SOME       user-supplied predicate succeeds on at least one input\n"
"EVERY      user-supplied predicate succeeds on every input\n"
"NOTANY     complement of SOME\n"
"NOTEVERY   complement of EVERY\n"
"</pre> "
msgstr ""

#: in/chapter12.html:281
msgid ""
"<p>For example, <code>SOME</code> examines inputs so long as the\n"
"predicate is false; the tests stop -- and <code>SOME</code> returns\n"
"a true value -- as soon as the predicate is true for some input(s).\n"
"If the predicate is false for every input, <code>SOME</code> returns\n"
"a false value."
msgstr ""
"<p>Например, <code>SOME</code>(некоторые) проверяет входные данные до тех "
"пор, \n"
"пока предикат ложен; тесты останавливаются - и <code>SOME</code> возвращает\n"
"истинное значение - как только предикат станет истинен для некоторых "
"входных\n"
"данных. Если предикат имеет значение false для всех входных данных, то \n"
"<code>SOME</code> из них возвращает ложное значение."

#: in/chapter12.html:287
msgid ""
"<p>Similarly, <code>EVERY</code> examines inputs so long as the\n"
"predicate is true; the tests stop -- and <code>EVERY</code> returns\n"
"a false value -- as soon as the predicate is false for some\n"
"input(s). If the predicate is true for every input,\n"
"<code>EVERY</code> returns a true value."
msgstr ""
"<p>\n"
"Аналогично, <code>EVERY</code>(каждый) проверяет входные данные до тех "
"пор, \n"
"пока предикат истинен; тесты останавливаются - и <code>EVERY</code> \n"
"возвращает ложное значение - как только предикат станет ложен для некоторых\n"
"входных данных. Если предикат истинен для каждого входного сигнала, то \n"
"<code>EVERY</code> возвращает истинное значение."

#: in/chapter12.html:298
msgid ""
"<pre>\n"
"? (some #'(lambda (n) (or (&lt; n 0) (&gt; n 100))) (list 0 1 99 100))\n"
"NIL\n"
"? (some #'(lambda (n) (or (&lt; n 0) (&gt; n 100))) (list -1 0 1 99 100))\n"
"T\n"
"? (every #'(lambda (w) (&gt;= (length w) 5)) (list \"bears\" \"bulls\" "
"\"racoon\"))\n"
"T\n"
"? (every #'(lambda (w) (&gt;= (length w) 5)) (list \"bears\" \"cat\" \"racoon"
"\"))\n"
"NIL\n"
"</pre> "
msgstr ""

#: in/chapter12.html:301
msgid ""
"<p>And of course, the predicate mapping functions handle multiple\n"
"sequences as you'd expect."
msgstr ""
"<p>\n"
"И конечно, функции отображения предикатов обрабатывают несколько\n"
"последовательностей, как и следовало ожидать."

#: in/chapter12.html:306
msgid ""
"<pre>\n"
"? (some #'&gt; (list 0 1 2 3 4 5) (list 0 0 3 2 6))\n"
"T\n"
"</pre> "
msgstr ""

#: in/chapter12.html:308
msgid "<h2>REDUCE combines sequence elements</h2>"
msgstr "<h2>REDUCE объединяет элементы последовательности</h2>"

#: in/chapter12.html:315
msgid ""
"<p>While we're on the subject of mapping, wouldn't it be nice to be\n"
"able to combine all of the elements of a sequence using some function?\n"
"<code>REDUCE</code> does just that, accepting a function (of two or zero\n"
"arguments) and a sequence.  If the sequence is longer than one element,\n"
"<code>REDUCE</code> combines the results of applying the function to \n"
"successive elements of the sequence.  For example:"
msgstr ""
"<p>Раз уж мы заговорили о отображениях, разве не было бы здорово иметь\n"
"возможность объединить все элементы последовательности с помощью какой-то\n"
"функции? <code>REDUCE</code> делает именно это, принимая функцию (с двумя \n"
"или нулевыми аргументами) и последовательность. Если последовательность "
"длиннее\n"
"одного элемента, то <code>REDUCE</code> объединяет результаты применения "
"функции\n"
"к последовательным элементам последовательности. Например:"

#: in/chapter12.html:322
msgid ""
"<pre>\n"
"? (reduce #'* (list 1 2 3 4 5)) <i>(* (* (* (* 1 2) 3) 4) 5)</i> \n"
"120\n"
"? (reduce #'- (list 10 2 3 1)) <i>; (- (- (- 10 2) 3) 1)</i> \n"
"4\n"
"</pre> "
msgstr ""

#: in/chapter12.html:329
msgid ""
"<p>If the sequence is of length one, <code>REDUCE</code> returns the\n"
"sequence and the function is not applied. If the sequence is of\n"
"length zero, <code>REDUCE</code> applies the function with no\n"
"arguments and returns the value returned by the function. (In the\n"
"case of arithmetic functions, this is the identity value for the\n"
"operation.)"
msgstr ""
"<p>\n"
"Если последовательность имеет длину один, <code>REDUCE</code>\n"
"возвращает последовательность, и функция не применяется. Если \n"
"последовательность имеет нулевую длину, <code>REDUCE</code> применяет \n"
"функцию без аргументов и возвращает значение, возвращаемое функцией. \n"
"(В случае арифметических функций это значение тождества для операции.)\n"

#: in/chapter12.html:334
msgid ""
"<p>Various keyword arguments let you specify a subsequence for\n"
"<code>REDUCE</code>, or that <code>REDUCE</code> should combine\n"
"elements in a right-associative manner (i.e. from the end of the\n"
"sequence, rather than from the beginning)."
msgstr ""
"<p>\n"
"Различные аргументы ключевые слова позволяют указать подпоследовательность \n"
"для <code>REDUCE</code>, или что <code>REDUCE</code> должен объединять \n"
"элементы в правой ассоциативной манере (т. е. с конца последовательности, \n"
"а не с начала)."

#: in/chapter12.html:347
msgid ""
"<hr>\n"
"<div align=\"center\">\n"
"<a href=\"contents.html\">Contents</a> | <a href=\"cover.html\">Cover</a> "
"<br> \n"
"<a href=\"chapter11.html\">Chapter 11</a> | Chapter 12 | <a href=\"chapter13."
"html\">Chapter 13</a> \n"
"</div>\n"
"<hr>\n"
"<address>\n"
"Copyright &copy; 1995-2001, David B. Lamkins<br>\n"
"All Rights Reserved Worldwide<br>\n"
"<br>\n"
"This book may not be reproduced without the written consent of its author.  "
"Online distribution is restricted to the author's site.\n"
"</address> \n"
"</body> </html> "
msgstr ""
