#
# NuINu <don't@send.my>, 2020.
#
#. extracted from in/chapter20.html
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-04-19 13:51+0300\n"
"PO-Revision-Date: 2020-06-03 15:39+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter20.html:5
msgid ""
"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/"
"html4/strict.dtd\">\n"
"<html><head>\n"
"<title>Successful Lisp - Chapter 20</title>\n"
"</head> "
msgstr ""

#: in/chapter20.html:8
msgid ""
"<body bgcolor=\"white\" text=\"black\">\n"
"<h1>Chapter 20 - Macro Etiquette</h1> "
msgstr ""
"<body bgcolor=\"white\" text=\"black\">\n"
"<h1>Глава 20 - Этикет(свод правил правильных действий) Макросов</h1> "

#: in/chapter20.html:15
msgid ""
"<P>Macros in Lisp are much more capable than macros in other\n"
"programming languages. Rather than just providing a simple shorthand\n"
"notation, Lisp macros give you the capability to truly extend the\n"
"language. In this chapter we'll learn about the program transforming\n"
"capabilities of macros as we see how to properly construct macros\n"
"to solve a wide variety of problems."
msgstr ""
"<P>\n"
"Макросы в Lisp гораздо более эффективны, чем макросы в других языках "
"программирования. \n"
"Вместо того, чтобы просто предоставлять простую стенографическую нотацию, "
"макросы Lisp \n"
"дают вам возможность действительно расширить язык. В этой главе мы "
"познакомимся с \n"
"возможностями макросов по преобразованию программы, так как увидим, как "
"правильно \n"
"строить макросы для решения самых разнообразных задач."

#: in/chapter20.html:17
msgid "<h2>Macros are programs that generate programs</h2>"
msgstr "<h2>Макросы это программы, которые генерируют программы</h2>"

#: in/chapter20.html:25
msgid ""
"<p>Mention macros to most programmers, perhaps even you, and the\n"
"first image that comes to mind is string substitution -- you use a\n"
"macro to glue together a few parameters in a new way, maybe with a\n"
"bit of compile-time decision making thrown in. And because of the\n"
"typical (in languages other than Lisp) disparity between the macro\n"
"language and the programming language, the difficulty of writing a\n"
"macro increases much faster than its complexity."
msgstr ""
"<p>\n"
"Упомяните макросы большинству программистов, возможно даже вам, \n"
"и первое, что приходит на ум, - это подстановка строк - вы используете \n"
"макрос, чтобы склеить несколько параметров по-новому, возможно, с "
"небольшим \n"
"количеством принятий решений во время компиляции. А из-за типичного (в "
"других \n"
"языках, кроме Lisp) несоответствия между макроязыком и языком "
"программирования \n"
"сложность написания макроса возрастает гораздо быстрее, чем его сложность."

#: in/chapter20.html:36
msgid ""
"<p>Lisp macros are Lisp programs that generate other Lisp programs.\n"
"The generated Lisp code has a fully-parenthesized notation, as does\n"
"the macro that generates the code. In the simplest case, a macro\n"
"substitutes forms within a template, clearly establishing a visual\n"
"correspondence between the generating code and the generated code.\n"
"Complex macros can use the full power of the Lisp language to\n"
"generate code according to the macro parameters; often a template\n"
"form is wrapped in code that constructs appropriate subforms, but\n"
"even this approach is just a typical use pattern and not a\n"
"requirement (or restriction) of the Lisp macro facility."
msgstr ""
"<p>\n"
"На Лиспе макросы это Lisp программы, которые порождают другие программы \n"
"на Лиспе. Сгенерированный код Lisp имеет полностью заключенную в скобки "
"нотацию, \n"
"как и макрос, который генерирует код. В простейшем случае макрос заменяет \n"
"формы внутри шаблона, четко устанавливая визуальное соответствие между \n"
"генерирующим и генерируемым кодом. Сложные макросы могут использовать \n"
"всю мощь языка Lisp для генерации кода в соответствии с параметрами "
"макросов; \n"
"часто шаблонная форма оборачивается в код, который создает соответствующие "
"подформы, \n"
"но даже этот подход является всего лишь типичным шаблоном использования, а "
"не \n"
"требованием (или ограничением) макросреды Lisp."

#: in/chapter20.html:42
msgid ""
"<p>In the following sections, we'll examine the mechanism by which\n"
"the Lisp system translates code generated by a macro, then we'll see\n"
"several increasingly sophisticated examples of macros. We'll finish\n"
"this chapter with a comparison of macros versus the use of inline\n"
"function declarations."
msgstr ""
"<p>\n"
"В следующих разделах мы рассмотрим механизм, с помощью которого система \n"
"Lisp преобразует код, созданный макросом, а затем рассмотрим несколько \n"
"все более сложных примеров макросов. Мы закончим эту главу сравнением \n"
"макросов с использованием встроенных объявлений функций.\n"
"\n"

#: in/chapter20.html:44
msgid "<h2>Close up: how macros work</h2>"
msgstr "<h2>Крупным планом: как работают макросы</h2>"

#: in/chapter20.html:46
msgid "<p>You define a macro with a <code>DEFMACRO</code> form, like this:"
msgstr ""
"<p>\n"
"Вы определяете макрос с помощью формы <code>DEFMACRO</code>, например:"

#: in/chapter20.html:51
msgid ""
"<pre>\n"
"(defmacro <i>name</i> (<i>arguments</i> ...)\n"
"  <i>body</i>)\n"
"</pre> "
msgstr ""

#: in/chapter20.html:57
msgid ""
"<p><code>DEFMACRO</code> is like <code>DEFUN</code>, but instead of\n"
"returning values, the body of the <code>DEFMACRO</code> returns a\n"
"Lisp form. (As we'll see shortly, there's a very simple way to generate\n"
"this form with selected subforms replaced by parameters from the macro\n"
"call or computed by the macro's program.)"
msgstr ""
"<p>\n"
"<code>DEFMACRO</code>  похож на <code>DEFUN</code>, но вместо того, чтобы \n"
"возвращать значения, тело <code>DEFMACRO</code> возвращает форму Lisp. \n"
"(Как мы вскоре увидим, существует очень простой способ генерировать эту "
"форму \n"
"с выбранными подформами, замененными параметрами из вызова макроса или \n"
"вычисленными программой макроса.)"

#: in/chapter20.html:65
msgid ""
"<p>Your program \"calls\" a macro the same way it calls a function,\n"
"but the behavior is quite different. First, none of the macro's\n"
"parameters are evaluated. Ever. Macro parameters are bound literally\n"
"to the corresponding arguments in the macro definition. If you pass\n"
"<code>(* 7 (+ 3 2))</code> to a macro, the argument in the body of\n"
"the macro definition is bound to the literal list <code>(* 7 (+ 3\n"
"2))</code>, and <em>not</em> the value 35."
msgstr ""
"<p>\n"
"Ваша программа \"вызывает\" макрос точно так же, как она вызывает функцию, \n"
"но поведение совершенно другое. Во-первых, ни один из параметров макроса \n"
"не вычисляется. Никогда. Параметры макроса буквально привязаны к "
"соответствующим \n"
"аргументам в определении макроса. Если вы передадите <code>(* 7 (+ 3 2))</"
"code> \n"
"в макрос, аргумент в теле определения макроса будет привязан к списку "
"литералов \n"
"<code>(* 7 (+ 3 2))</code>, а не значению 35."

#: in/chapter20.html:72
msgid ""
"<p>Next, the <em>macro expander</em> is invoked, receiving all of\n"
"the actual parameters bound to their corresponding arguments as\n"
"named by the <code>DEFMACRO</code> form. The macro expander is just\n"
"the body of the <code>DEFMACRO</code> form, which is just Lisp code;\n"
"the only catch is that the Lisp system expects the macro expander to\n"
"return a Lisp form."
msgstr ""
"<p>\n"
"Затем вызывается <em>macro expander</em>(расширитель макроса), который \n"
"получает все фактические параметры, привязанные к их соответствующим "
"аргументам, \n"
"как указано в форме <code>DEFMACRO</code>. Расширитель макроса - это "
"просто \n"
"тело формы <code>DEFMACRO</code>, которая является просто кодом Lisp; \n"
"единственная загвоздка заключается в том, что система Lisp ожидает, что \n"
"расширитель макроса вернет форму Lisp."

#: in/chapter20.html:77
msgid ""
"<p>The Lisp system then evaluates whatever form the macro expander\n"
"returns. If the returned form is a macro, it gets expanded.\n"
"Otherwise, the form is evaluated by the rules we first learned in <a\n"
"href=\"chapter03-02.html\">Chapter 3, Lesson 2</a>."
msgstr ""
"<p>\n"
"Затем система Lisp вычисляет некоторую форму, которую возвращает расширитель "
"макроса. \n"
"Если возвращаемая форма является макросом, она также расширяется. В "
"противном случае \n"
"форма вычисляется по правилам, которые мы впервые изучили в  \n"
"<a href=\"chapter03-02.html\">главе 3, Урок 2</a>."

#: in/chapter20.html:87
msgid ""
"<blockquote>\n"
"The preceding paragraph is conceptually correct. However, a Lisp \n"
"implementation may expand macros at different times. A macro could be\n"
"expanded just once, when your program is compiled. Or it could be \n"
"expanded on first use as your program runs, and the expansion could\n"
"be cached for subsequent reuse. Or the macro could be expanded every\n"
"time it's used. A properly written macro will behave the same under\n"
"all of these implementations.\n"
"</blockquote> "
msgstr ""
"<blockquote>\n"
"Предыдущий абзац является концептуально правильным. Однако реализация \n"
"Lisp может расширять макросы в разное время. Макрос может быть расширен \n"
"только один раз, когда ваша программа компилируется. Или же он может быть \n"
"расширен при первом использовании по мере запуска вашей программы, и \n"
"расширение может быть кэшировано для последующего повторного "
"использования. \n"
"Или макрос может быть расширен каждый раз, когда он используется. "
"Правильно \n"
"написанный макрос будет вести себя одинаково во всех этих реализациях..\n"
"</blockquote> "

#: in/chapter20.html:90
msgid ""
"<p>In <a href=\"chapter21.html\">Chapter 21</a> we'll expand upon some\n"
"of the things you can express with argument lists."
msgstr ""
"<p>В <a href=\"chapter21.html\">Главе 21</a> мы подробно остановимся на \n"
"некоторых вещах, которые вы можете выразить с помощью списков аргументов."

#: in/chapter20.html:92
msgid "<h2>Backquote looks like a substitution template</h2>"
msgstr ""
"<h2>Цитирование(Backquote) обратной кавычкой выглядит как шаблон "
"подстановки</h2>"

#: in/chapter20.html:98
msgid ""
"<p>The simplest way to generate a form in the body of your macro\n"
"expander is to use the <em>backquote</em> (<code>`</code>) reader\n"
"macro. This behaves like the <em>quote</em> (<code>'</code>) reader\n"
"macro, except for when a comma (<code>,</code>) appears in the\n"
"backquoted form."
msgstr ""
"<p>\n"
"Самый простой способ создать форму в теле вашего расширителя макросов \n"
"- это использовать макрос чтения <em>backquote</em> (<code>`</code>). \n"
"Он ведет себя как макрос чтения <em>quote</em> (<code>'</code>), \n"
"за исключением тех случаев, когда в форме обратной кавычки\n"
"появляется запятая (<code>,</code>)."

#: in/chapter20.html:103
msgid ""
"<blockquote>\n"
"A comma is only permitted in a backquoted form. If you use a comma\n"
"in a quoted form, Lisp will signal an error when it reads the form.\n"
"</blockquote> "
msgstr ""
"<blockquote>\n"
"Запятая допускается только в форме обратной кавычки. Если вы используете \n"
"запятую в форме кавычек, Lisp будет сигнализировать об ошибке при \n"
"чтении формы.\n"
"</blockquote> "

#: in/chapter20.html:107
msgid ""
"<p>Like quote, backquote suppresses evaluation. But a comma within a\n"
"backquoted form \"unsuppresses\" evaluation for just the following\n"
"subform."
msgstr ""
"<p>\n"
"Как и quote, backquote(обратная цитата) подавляет вычисления. Но запятая в \n"
"форме с backquote(обратными кавычками) \"разрешает\" вычисление \n"
"только для последущей подформы."

#: in/chapter20.html:112
msgid ""
"<pre>\n"
"? `(The sum of 17 and 83 is ,(+ 17 83))\n"
"(THE SUM OF 17 AND 83 IS 100)\n"
"</pre> "
msgstr ""

#: in/chapter20.html:115
msgid ""
"<p>Compare the preceding example, which used backquote, with the\n"
"similar form using quote (and omitting the comma)."
msgstr ""
"<p>\n"
"Сравните предыдущий пример, в котором использовалась backquote(обратная "
"кавычка),\n"
"с аналогичной формой, использующей quote(кавычку) (и опуская запятую)."

#: in/chapter20.html:120
msgid ""
"<pre>\n"
"? '(The sum of 17 and 83 is (+ 17 83))\n"
"(THE SUM OF 17 AND 83 IS (+ 17 83))\n"
"</pre> "
msgstr ""

#: in/chapter20.html:124
msgid ""
"<p>You can probably imagine how backquote and comma provide a template\n"
"with substitution capabilities. This is just what we need for our\n"
"macro expander. Here are a couple of simple examples."
msgstr ""
"<p>\n"
"Вы, вероятно, можете себе представить, как backquote и comma(запятая) "
"предоставляют \n"
"шаблону возможности подстановки. Это как раз то, что нам нужно для нашего "
"макрорасширителя. \n"
"Вот несколько простых примеров."

#: in/chapter20.html:132
msgid ""
"<pre>\n"
"<i>; Define the macro</i> \n"
"? (defmacro swap (a b) <i>; NOTE: This is a restricted version of ROTATEF</"
"i> \n"
"    `(let ((temp ,a))\n"
"       (setf ,a ,b)\n"
"       (setf ,b temp)))\n"
"SWAP"
msgstr ""

#: in/chapter20.html:141
msgid ""
"<i>; First invocation</i> \n"
"? (let ((x 3)\n"
"        (y 7))\n"
"    (swap x y) <i>; macro call</i> \n"
"    (list x y))\n"
"(7 3)\n"
"<i>; Let's see the form generated by SWAP:</i> \n"
"? (pprint (macroexpand-1 '(swap x y)))"
msgstr ""

#: in/chapter20.html:145
msgid ""
"(LET ((TEMP X))\n"
"  (SETF X Y)\n"
"  (SETF Y TEMP))"
msgstr ""

#: in/chapter20.html:153
msgid ""
"<i>; Second invocation</i> \n"
"? (let ((c (cons 2 9))) <i>; (2 . 9)</i> \n"
"    (swap (car c) (cdr c))\n"
"    c)\n"
"(9 . 2)\n"
"<i>; And the expansion of its macro call</i> \n"
"? (pprint (macroexpand-1 '(swap (car c) (cdr c))))"
msgstr ""

#: in/chapter20.html:157
msgid ""
"(LET ((TEMP (CAR C)))\n"
"  (SETF (CAR C) (CDR C))\n"
"  (SETF (CDR C) TEMP))"
msgstr ""

#: in/chapter20.html:166
msgid ""
"<i>; Here's the second invocation again, \"macroexpanded\" by hand.</i> \n"
"? (let ((c (cons 2 9)))\n"
"    (LET ((TEMP (CAR C)))\n"
"      (SETF (CAR C) (CDR C))\n"
"      (SETF (CDR C) TEMP))\n"
"    c)\n"
"(9 . 2)\n"
"</pre> "
msgstr ""

#: in/chapter20.html:171
msgid ""
"<p><code>(PPRINT (MACROEXPAND-1 '<i>macro-call</i>))</code> is a very\n"
"handy tool to see what form your macro expander generates. (Don't worry\n"
"if the output from your Lisp system looks exactly as shown here; there\n"
"may be some differences in layout.)"
msgstr ""
"<p>\n"
"<code>(PPRINT (MACROEXPAND-1 '<i>macro-call</i>))</code>  - это очень \n"
"удобный инструмент для просмотра того, какую форму генерирует ваш "
"расширитель макросов. \n"
"(Не волнуйтесь, если вывод из вашей системы Lisp выглядит не совсем так, как "
"показано здесь; \n"
"могут быть некоторые различия в компоновке.)"

#: in/chapter20.html:173
msgid ""
"<p>As you look at these examples, the important things to note are that:"
msgstr ""
"<p>\n"
"Когда вы смотрите на эти примеры, важно отметить, что:"

#: in/chapter20.html:177
msgid ""
"<ol>\n"
"<li>the macro arguments receive the literal representation of their actual\n"
"parameters from the macro call, and"
msgstr ""
"<ol>\n"
"<li>аргументы макроса получают буквальное представление своих фактических \n"
"параметров из вызова макроса, и"

#: in/chapter20.html:182
msgid ""
"<li>macro arguments that are preceded by a comma within a backquoted form\n"
"are substituted with the literal representation of the parameter from the\n"
"macro call.\n"
"</ol> "
msgstr ""
"<li>аргументы макроса, которым предшествует запятая в форме обратной "
"кавычки, \n"
"заменяются литеральным представлением параметра из вызова макроса.\n"
"</ol> "

#: in/chapter20.html:185
msgid ""
"<p>Here are some more macro definitions. Experiment with these in your\n"
"Lisp system to see what they do."
msgstr ""
"<p>\n"
"Вот еще несколько определений макросов. Поэкспериментируйте с ними в вашей "
"системе Lisp, \n"
"чтобы увидеть, что они делают."

#: in/chapter20.html:189
msgid ""
"<pre>\n"
"(defmacro sortf (place)\n"
"  `(setf ,place (sort ,place)))"
msgstr ""

#: in/chapter20.html:192
msgid ""
"(defmacro togglef (place)\n"
"  `(setf ,place (not ,place)))"
msgstr ""

#: in/chapter20.html:197
msgid ""
"(defmacro either (form1 form2)\n"
"  <i>; (random 2) returns 0 or 1</i> \n"
"  `(if (zerop (random 2)) ,form1 ,form2))\n"
"</pre> "
msgstr ""

#: in/chapter20.html:199
msgid "<h2>Beyond the obvious, part 1: compute, then generate</h2>"
msgstr "<h2>Не очевидное, часть 1: вычислить, а затем сгенерировать</h2>"

#: in/chapter20.html:208
msgid ""
"<p>Macros start to get interesting when they do more than a simple\n"
"textual substitution. In this section, we'll explore a real-world\n"
"example of using a macro to extend Lisp into the problem domain. In\n"
"addition to providing a macro expander, our new macro will\n"
"automatically generate an environment that will be referenced by the\n"
"expander. Our example will show how to move computations from\n"
"run-time to compile-time, and how to share information computed at\n"
"compile-time."
msgstr ""
"<p>\n"
"Макросы начинают становиться интересными, когда они делают больше, \n"
"чем простая текстовая подстановка. В этом разделе мы рассмотрим реальный \n"
"пример использования макроса для расширения Lisp в проблемной области. \n"
"В дополнение к предоставлению расширителя макросов, наш новый макрос \n"
"автоматически создаст среду/окружение, на которую будет ссылаться "
"расширитель. \n"
"В нашем примере будет показано, как перемещать вычисления из среды "
"выполнения на\n"
"время компиляции и как обмениваться информацией, вычисленной во время "
"компиляции."

#: in/chapter20.html:219
msgid ""
"<p>Let's say you're working on an interactive game that makes heavy\n"
"use of the trigonometric function <em>sine r</em> in computing player\n"
"motion and interaction. You've already determined that calling the\n"
"Lisp function <code>SIN</code> is too time-consuming; you also know\n"
"that your program will work just fine with approximate results for\n"
"the computation of <em>sine r</em>. You'd like to define a\n"
"<code>LOOKUP-SIN</code> macro to do the table lookup at runtime;\n"
"you'd also like to hide the details of table generation, an\n"
"implementation detail with which you'd rather not clutter your\n"
"program's source code."
msgstr ""
"<p>\n"
"Предположим, вы работаете над интерактивной игрой, которая широко \n"
"использует тригонометрическую функцию <em>sine r</em> в вычислении \n"
"движения и взаимодействия игроков. Вы уже определили, что вызов функции \n"
"Lisp <code>SIN</code> занимает слишком много времени; вы также знаете, \n"
"что ваша программа будет работать просто отлично с приблизительными "
"результатами \n"
"для вычисления <em>sine r</em>. вы хотели бы определить макрос <code>LOOKUP-"
"SIN</code>\n"
"для выполнения поиска в таблице во время выполнения; вы также хотели бы "
"скрыть детали \n"
"генерации таблиц, детали реализации, с которыми вы предпочли бы не "
"загромождать \n"
"исходный код вашей программы."

#: in/chapter20.html:230
msgid ""
"<p>Your macro will be invoked as <code>(LOOKUP-SIN</code>\n"
"<var>radians</var> <var>divisions</var><code>)</code>, where\n"
"<var>radians</var> is always in the range of zero to one-quarter pi,\n"
"and <var>divisions</var> is the number of discrete values available\n"
"as the result of <code>LOOKUP-SIN</code>. At runtime, the macro\n"
"expander will just compute the index into a lookup table, and return\n"
"the value from the table. The table will be generated at\n"
"compile-time (on most Lisp systems). Furthermore, only one table\n"
"will ever be generated for a given value of <var>divisions</var> in\n"
"the macro call."
msgstr ""
"<p>\n"
"Ваш макрос будет вызваный как \n"
"<code>(LOOKUP-SIN</code> <var>radians</var> <var>divisions</var><code>)</"
"code>, \n"
"где <var>radians</var> всегда находится в диапазоне от нуля до одной "
"четверти pi, \n"
"а <var>divisions</var>-это количество дискретных значений, доступных как "
"результат\n"
"<code>LOOKUP-SIN</code>. Во время выполнения расширитель макросов просто "
"вычислит \n"
"индекс в таблице подстановки и вернет значение из этой таблицы. Таблица "
"будет сгенерирована \n"
"во время компиляции (в большинстве систем Lisp). Кроме того, для заданного "
"значения \n"
"делений(<var>divisions</var>) в вызове макроса будет сгенерирована только "
"одна таблица."

#: in/chapter20.html:234
msgid ""
"<p>Here's the code. The comments and documentation strings should\n"
"help you to understand the code as you read it. I'll provide further\n"
"explanation below."
msgstr ""
"<p>\n"
"Вот вам и код. Комментарии и строки документации должны помочь вам понять "
"код, \n"
"когда вы его читаете. Я приведу дальнейшие объяснения ниже."

#: in/chapter20.html:242
msgid ""
"<pre>\n"
"<i>;; This is where we cache all of the sine tables generated</i> \n"
"<i>;; during compilation. The tables stay around at runtime</i> \n"
"<i>;; so they can be used for lookups.</i> \n"
"(defvar *sin-tables* (make-hash-table)\n"
"  \"A hash table of tables of sine values. The hash is keyed\n"
"by the number of entries in each sine table.\")"
msgstr ""

#: in/chapter20.html:261
msgid ""
"<i>;; This is a helper function for the LOOKUP-SIN macro.</i> \n"
"<i>;; It is used only at compile time.</i> \n"
"(defun get-sin-table-and-increment (divisions)\n"
"  \"Returns a sine lookup table and the number of radians quantized\n"
"by each entry in the table. Tables of a given size are reused.\n"
"A table covers angles from zero to pi/4 radians.\"\n"
"  (let ((table (gethash divisions *sin-tables* :none))\n"
"        (increment (/ pi 2 divisions)))\n"
"    (when (eq table :none)\n"
"      <i>;; Uncomment the next line to see when a table gets created.</i> \n"
"      <i>;;(print '|Making new table|)</i> \n"
"      (setq table\n"
"            (setf (gethash divisions *sin-tables*)\n"
"                  (make-array (1+ divisions) :initial-element 1.0)))\n"
"      (dotimes (i divisions)\n"
"        (setf (aref table i)\n"
"              (sin (* increment i)))))\n"
"    (values table increment)))"
msgstr ""

#: in/chapter20.html:270
msgid ""
"<i>;; Macro calls the helper at compile time, and returns an</i> \n"
"<i>;; AREF form to do the lookup at runtime.</i> \n"
"(defmacro lookup-sin (radians divisions)\n"
"  \"Return a sine value via table lookup.\"\n"
"  (multiple-value-bind (table increment)\n"
"                       (get-sin-table-and-increment divisions)\n"
"    `(aref ,table (round ,radians ,increment))))\n"
"</pre> "
msgstr ""

#: in/chapter20.html:276
msgid ""
"<p>If you still don't see the point of all this code after having\n"
"read the introduction to this section and the comments in the code,\n"
"here it is: when your program runs, it executes <em>just</em>\n"
"<code>AREF</code> (and associated <code>ROUND</code>) to look up the\n"
"<em>sin r</em> value."
msgstr ""
"<p>\n"
"Если вы все еще не видите смысла всего этого кода после прочтения\n"
"введения к этому разделу и комментариев в коде, вот он: \n"
"когда ваша программа запускается, она выполняет только <code>AREF</code> \n"
"(и связанный с ним <code>ROUND</code>), чтобы найти значение <em>sin r</em>."

#: in/chapter20.html:279
msgid ""
"<pre>\n"
"? (pprint (macroexpand-1 '(lookup-sin (/ pi 4) 50)))"
msgstr ""

#: in/chapter20.html:289
msgid ""
"(AREF #(0.0 0.0314107590781283 0.06279051952931337 \n"
"        <i>[additional entries not shown]</i> \n"
"        0.9980267284282716 0.9995065603657316 1.0)\n"
"      (ROUND (/ PI 4) 0.031415926535897934))\n"
"<i>;; Note that the macro call makes no mention of a lookup table.</i> \n"
"<i>;; Tables are generated as-needed by (and for) the compiler.</i> \n"
"? (lookup-sin (/ pi 4) 50)\n"
"0.7071067811865476\n"
"</pre> "
msgstr ""

#: in/chapter20.html:298
msgid ""
"<p>In the macroexpansion, the <code>#(...)</code> is the printed\n"
"representation of the lookup table for 50 divisions of the quarter\n"
"circle. This table is stored in the <code>*SIN-TABLES*</code> hash\n"
"table, where it is shared by <em>every</em> macro call to\n"
"<code>(LOOKUP-SIN</code> <var>angle</var> <code>50)</code>. We don't\n"
"even have to do a hash lookup at runtime, because the macro expander\n"
"has captured the free variable <code>TABLE</code> from the\n"
"<code>MULTIPLE-VALUE-BIND</code> form in <code>LOOKUP-SIN</code>."
msgstr ""
"<p>В макрорасширении <code>#(...)</code>- это печатное представление таблицы "
"поиска \n"
"для 50 делений четверти круга. Эта таблица хранится в хэш-таблице <code>*SIN-"
"TABLES*</code>,\n"
"где она совместно используется каждым вызовом макроса \n"
"<code>(LOOKUP-SIN</code> <var>angle</var> <code>50)</code>. Нам даже не "
"нужно делать хэш-поиск во время выполнения, потому что расширитель макросов "
"захватил свободную \n"
"<code>TABLE</code> из формы  <code>MULTIPLE-VALUE-BIND</code> в \n"
"<code>LOOKUP-SIN</code>."

#: in/chapter20.html:300
msgid "<h2>Beyond the obvious, part 2: macros that define macros</h2>"
msgstr "<h2>Не очевидное, часть 2: макросы, которые определяют макросы</h2>"

#: in/chapter20.html:307
msgid ""
"<p>Macros that define macros are used infrequently, partly because\n"
"it's hard to think of a good use for this technique and partly\n"
"because it's difficult to get right. The following macro, based upon\n"
"an example in <a href=\"chapter33.html#graham94\">Paul Graham's \"On\n"
"Lisp\"</a> book, can be used to define synonyms for the names of Lisp\n"
"functions, macros, and special forms."
msgstr ""
"<p>\n"
"Макросы, которые определяют макросы, используются нечасто, отчасти потому, \n"
"что трудно придумать хорошее применение для этой техники, а отчасти "
"потому, \n"
"что ее трудно использовать правильно. Следующий макрос, основанный на "
"примере \n"
"книги <a href=\"chapter33.html#graham94\">Пола Грэма \"On Lisp\"</a> , может "
"быть \n"
"использован для определения синонимов имен функций Lisp, макросов и \n"
"специальных форм."

#: in/chapter20.html:320
msgid ""
"<pre>\n"
"? (defmacro defsynonym (old-name new-name)\n"
"    \"Define OLD-NAME to be equivalent to NEW-NAME when used in\n"
"the first position of a Lisp form.\"\n"
"    `(defmacro ,new-name (&amp;rest args)\n"
"       `(,',old-name ,@args)))\n"
"DEFSYNONYM\n"
"? (defsynonym make-pair cons)\n"
"MAKE-PAIR\n"
"? (make-pair 'a 'b)\n"
"(A . B)\n"
"</pre> "
msgstr ""

#: in/chapter20.html:326
msgid ""
"<p>Macros are always a little bit dangerous because code containing a macro\n"
"call does not automatically get updated if you change the definition of the\n"
"macro. You can always establish your own convention to help you remember\n"
"that you need to recompile certain code after you change a macro "
"definition.\n"
"But there's always the possibility that you'll forget, or make a mistake."
msgstr ""
"<p>\n"
"Макросы всегда немного опасны, потому что код, содержащий вызов макроса, \n"
"не обновляется автоматически при изменении определения макроса. Вы всегда \n"
"можете установить свое собственное соглашение, чтобы помочь вам помнить, \n"
"что вам нужно перекомпилировать определенный код после изменения "
"определения \n"
"макроса. Но всегда есть вероятность, что вы забудете или совершите ошибку."

#: in/chapter20.html:337
msgid ""
"<p>Ultimately, the likelihood that you'll inadvertently end up with\n"
"code that was compiled with an old version of a macro is directly\n"
"proportional to how often you're likely to change the macro. I'll\n"
"probably never need to change the <code>LOOKUP-SIN</code> macro from\n"
"the previous section once it's defined and working. On the other\n"
"hand, a macro like <code>DEFSYNONYM</code> practically begs to be\n"
"used again and again as you generate new code. If you change your\n"
"mind about the <em>old name</em> to associate with a given <em>new\n"
"name</em>, all of your previously compiled code will still refer to\n"
"the <code>old name</code> that you had decided upon previously."
msgstr ""
"<p>\n"
"В конечном счете, вероятность того, что вы случайно получите код, \n"
"который был скомпилирован со старой версией макроса, прямо пропорциональна "
"тому, \n"
"как часто вы будете менять макрос. Мне, вероятно, никогда не придется "
"менять \n"
"макрос <code>LOOKUP-SIN</code> из предыдущего раздела, Как только он будет \n"
"определен и заработает. С другой стороны, такой макрос, как "
"<code>DEFSYNONYM</code>, \n"
"практически напрашивается на повторное использование при создании нового "
"кода. \n"
"Если вы измените свое мнение о старом имени, чтобы связать его с заданным "
"новым \n"
"именем, весь ваш ранее скомпилированный код будет по-прежнему ссылаться на\n"
" старое имя, которое вы выбрали ранее."

#: in/chapter20.html:340
msgid ""
"<pre>\n"
"<i>;; WARNING: This example illustrates a practice to avoid!</i> "
msgstr ""

#: in/chapter20.html:344
msgid ""
"<i>;; Here's some core algorithm</i> \n"
"? (defun process-blah-using-algorithm-zark (...) ...)\n"
"PROCESS-BLAH-USING-ALGORITHM-ZARK"
msgstr ""

#: in/chapter20.html:369
msgid ""
"<i>;; And here's where I use the algorithm, perhaps calling it</i> \n"
"<i>;; from many other places in DO-STUFF besides the one I've shown.</i> \n"
"? (defun do-stuff (...)\n"
"    ...\n"
"    (process-blah-using-algorithm-zark ...)\n"
"    ...)\n"
"DO-STUFF\n"
"<i>;; Try it out...</i> \n"
"? (do-stuff ...)\n"
"[results based upon process-blah-using-algorithm-zark]\n"
"<i>;; OK, this looks good.  But I think I'll clean up the</i> \n"
"<i>;; appearance of DO-STUFF by defining an abbreviation</i> \n"
"<i>;; for that really long core algorithm name.</i> \n"
"? (defsynonym process-blah-using-algorithm-zark proc)\n"
"PROC\n"
"<i>;; Now I'll rewrite DO-STUFF to use the abbreviation.</i> \n"
"? (defun do-stuff (...)\n"
"    ...\n"
"    (proc ...)\n"
"    ...)\n"
"DO-STUFF\n"
"<i>;; And make sure it still works.</i> \n"
"? (do-stuff ...)\n"
"[results based upon process-blah-using-algorithm-zark]"
msgstr ""

#: in/chapter20.html:371
msgctxt "in/chapter20.html:371"
msgid "<i>... Some time later ...</i> "
msgstr ""

#: in/chapter20.html:378
msgid ""
"<i>;; Oh, here's a better core algorithm.</i> \n"
"? (defun process-blah-using-algorithm-glonkfarkle (...) ...)\n"
"PROCESS-BLAH-USING-ALGORITHM-GLONKFARKLE\n"
"<i>;; I'll change the synonym for PROC to 'be' the new algorithm.</i> \n"
"? (defsynonym process-blah-using-algorithm-glonkfarkle proc)\n"
"PROC"
msgstr ""

#: in/chapter20.html:380
msgctxt "in/chapter20.html:380"
msgid "<i>... Some time later ...</i> "
msgstr ""

#: in/chapter20.html:387
msgid ""
"<i>;; Time to use DO-STUFF again...</i> \n"
"? (do-stuff ...)\n"
"[results based upon process-blah-using-algorithm-zark]\n"
"<i>;; Hey!! These results don't seem to use the new algorithm.</i> \n"
"<i>;; What could be wrong?  The code LOOKS right...</i> \n"
"</pre> "
msgstr ""

#: in/chapter20.html:392
msgid ""
"<p>The problem, of course, is that the second use of\n"
"<code>DEFSYNONYM</code> redefined the <code>PROC</code> macro, and I\n"
"didn't notice that <code>DO-STUFF</code> needed to be recompiled to\n"
"pick up the changed definition."
msgstr ""
"<p>Проблема, конечно, заключается в том, что второе использование "
"<code>DEFSYNONYM</code> \n"
"переопределило макрос <code>PROC</code>, и я не заметил, что <code>DO-STUFF</"
"code> нужно было\n"
"перекомпилировать, чтобы подхватить измененное определение."

#: in/chapter20.html:399
msgid ""
"<blockquote> My advice: Don't try to be clever by using macros like\n"
"<code>DEFSYNONYM</code>. Stick with descriptive names that are as\n"
"long as necessary, and use an editor that supports symbol completion\n"
"(see <a href=\"chapter27.html\">Chapter 27</a>). Remember, there's\n"
"only one way to <em>not</em> abbreviate a name; using abbreviations\n"
"increases the chance that you'll use the wrong one. </blockquote> "
msgstr ""
"<blockquote> \n"
"Мой совет: не пытайтесь быть умным, используя макросы, такие как "
"<code>DEFSYNONYM</code>. \n"
"Придерживайтесь описательных имен настолько длинных, насколько это "
"необходимо, и \n"
"используйте редактор, поддерживающий завершение символов (см. \n"
"<a href=\"chapter27.html\">Главу 27</a>). Помните, что есть только один "
"способ не \n"
"сокращать имя; использование сокращений увеличивает вероятность того, что вы "
"будете \n"
"использовать неправильное имя.\n"
"</blockquote> "

#: in/chapter20.html:401
msgid "<h2>Tricks of the trade: elude capture using GENSYM</h2>"
msgstr ""
"<h2>Хитрости торговли: избежать захвата с помощью исопользования GENSYM</h2>"

#: in/chapter20.html:406
msgid ""
"<p>You have to be be careful when you define a macro that introduces\n"
"new variables in its expansion. The <code>REPEAT</code> macro, below,\n"
"offers us a shorthand way of repeating a body of code a certain number\n"
"of times."
msgstr ""
"<p>\n"
"Вы должны быть осторожны, когда определяете макрос, который вводит новые "
"переменные \n"
"в его расширении. Макрос <code>REPEAT</code>, приведенный ниже, предлагает "
"нам сокращенный \n"
"способ повторения тела кода определенное количество раз."

#: in/chapter20.html:413
msgid ""
"<pre>\n"
"? (defmacro repeat (times &amp;body body)\n"
"    `(dotimes (x ,times)\n"
"       ,@body))\n"
"REPEAT\n"
"? (repeat 3 (print 'hi))"
msgstr ""

#: in/chapter20.html:419
msgctxt "in/chapter20.html:419"
msgid ""
"HI\n"
"HI\n"
"HI\n"
"NIL\n"
"</pre> "
msgstr ""

#: in/chapter20.html:423
msgid ""
"<p>This seems to do the right thing, but the variable <code>X</code> is\n"
"going to cause problems.  The following example <em>should</em> give us\n"
"the same results as the last example."
msgstr ""
"<p>\n"
"Этот код, кажется, делает правильные вещи, но переменная <code>X</code> "
"будет \n"
"вызывать проблемы. Следующий пример <em>должен</em> дать нам те же "
"результаты, \n"
"что и предыдущий."

#: in/chapter20.html:430
msgid ""
"<pre>\n"
"? (setq x 'hi)\n"
"HI\n"
"? x\n"
"HI\n"
"? (repeat 3 (print x))"
msgstr ""

#: in/chapter20.html:436
msgid ""
"0\n"
"1\n"
"2\n"
"NIL\n"
"</pre> "
msgstr ""

#: in/chapter20.html:444
msgid ""
"<p>The variable <code>X</code> in the macro expander\n"
"<code>shadowed</code> the global <code>X</code> that we tried to\n"
"reference in the body. Another way to say this is that\n"
"<code>X</code> is <em>free</em> in the body of the\n"
"<code>REPEAT</code> form, but it was <em>captured</em> by the\n"
"definition of <code>X</code> in the macro expander; this prevents\n"
"the body form from reaching the intended variable <code>X</code>."
msgstr ""
"<p>\n"
"Переменная <code>X</code> в расширителе макросов затеняет\n"
"глобальный <code>X</code>, на который мы пытались ссылаться в теле. \n"
"Другой способ сказать это состоит в том, что <code>X</code> свободен \n"
"в теле формы <code>REPEAT</code>, но он был захвачен определением <code>X</"
"code>\n"
"в макрорасширителе; это препятствует тому, чтобы тело формы достигло \n"
"предполагаемой переменной <code>X</code>."

#: in/chapter20.html:451
msgid ""
"<p>The obvious solution is to use a different variable name in the\n"
"macro expander -- one that won't conflict with any name we'll ever\n"
"use in our code that calls the <code>REPEAT</code> macro. You might\n"
"think that some kind of naming convention would work, but there's \n"
"always the chance that some programmer will come along later and\n"
"violate the convention.  We need a foolproof approach."
msgstr ""
"<p>\n"
"Очевидным решением является использование другого имени переменной \n"
"в расширителе макросов - такого, которое не будет конфликтовать с \n"
"любым именем, которое мы когда-либо будем использовать в нашем коде, \n"
"вызывающем макрос <code>REPEAT</code>. Вы можете подумать, что какое-то \n"
"соглашение об именовании будет работать, но всегда есть шанс, что какой-то \n"
"программист придет позже и нарушит это соглашение. Нам нужен надежный "
"подход.\n"

#: in/chapter20.html:458
msgid ""
"<p>Lisp provides a <code>GENSYM</code> function to generate symbols\n"
"that are <em>guaranteed</em> to be unique. No programmer can ever\n"
"write a symbol name that conflicts with a symbol created by\n"
"<code>GENSYM</code>. Here is how we use <code>GENSYM</code> to\n"
"create a name for the variable needed in the macro expander for the\n"
"<code>REPEAT</code> macro."
msgstr ""
"<p>\n"
"Lisp предоставляет функцию <code>GENSYM</code> для генерации символов, \n"
"которые <em>гарантированно</em> будут уникальными. Ни один программист \n"
"никогда не сможет написать имя символа, которое конфликтует с символом, \n"
"созданным <code>GENSYM</code>. Вот как мы используем <code>GENSYM</code>\n"
"для создания имени переменной, необходимой в расширителе макросов для \n"
"макроса <code>REPEAT</code>."

#: in/chapter20.html:468
msgid ""
"<pre>\n"
"? (defmacro repeat (times &amp;body body)\n"
"    (let ((x (gensym)))\n"
"      `(dotimes (,x ,times)\n"
"         ,@body)))\n"
"REPEAT\n"
"? x\n"
"HI\n"
"? (repeat 3 (print x))"
msgstr ""

#: in/chapter20.html:474
msgctxt "in/chapter20.html:474"
msgid ""
"HI\n"
"HI\n"
"HI\n"
"NIL\n"
"</pre> "
msgstr ""

#: in/chapter20.html:478
msgid ""
"<p>With this new <code>REPEAT</code> macro, we compute a new symbol\n"
"in the <code>LET</code> form, and substitute this symbol in the\n"
"macro expander form. To see why this works, let's look at an expansion:"
msgstr ""
"<p>\n"
"С помощью этого нового макроса <code>REPEAT</code> мы вычисляем новый \n"
"символ в форме <code>LET</code> и подставляем этот символ в форме \n"
"расширения макроса. Чтобы понять, почему это работает, давайте рассмотрим \n"
"расширение:"

#: in/chapter20.html:483
msgid ""
"<pre>\n"
"? (macroexpand-1 '(repeat 5 (print x))\n"
"(DOTIMES (#:G8524 5) (PRINT X))\n"
"</pre> "
msgstr ""

#: in/chapter20.html:489
msgid ""
"<p><code>#:G8524</code> is a unique <em>uninterned</em> symbol.  You can\n"
"see that it's uninterned by the <code>#:</code> prefix. But how does Lisp\n"
"guarantee the uniqueness of this symbol?  The Lisp reader guarantees that\n"
"any symbol it reads with the <code>#:</code> prefix is unique.  Compare\n"
"the following:"
msgstr ""
"<p>\n"
"<code>#:G8524</code> это уникальный неинтернированный(<em>uninterned</em>) "
"символ. \n"
"Вы можете видеть, что он неинтернирован по префиксу <code>#:</code>. Но как "
"Лисп \n"
"гарантирует уникальность этого символа? Считыватель Lisp гарантирует, что "
"любой \n"
"символ, который он читает с префиксом <code>#:</code>, уникален. \n"
"Сравните следующее:"

#: in/chapter20.html:496
msgid ""
"<pre>\n"
"? (eq 'a 'a)\n"
"T\n"
"? (eq '#:a '#:a)\n"
"NIL\n"
"</pre> "
msgstr ""

#: in/chapter20.html:499
msgid ""
"<p>Even though the <code>#:A</code> symbols print the same, they are\n"
"different."
msgstr ""
"<p>\n"
"Несмотря на то, что символы <code>#:A</code> печатаются одинаково, \n"
"они отличаются."

#: in/chapter20.html:502
msgid ""
"<p>Generating variable names to be used in macro expanders has another \n"
"application. This next macro definition has a subtle problem:"
msgstr ""
"<p>\n"
"Генерация имен переменных для использования в расширителях макросов имеет \n"
"другое применение. Следующее определение макроса имеет тонкую проблему:"

#: in/chapter20.html:513
msgid ""
"<pre>\n"
"? (defmacro cube (n)\n"
"    `(* ,n ,n ,n))\n"
"CUBE\n"
"? (cube 3)\n"
"27\n"
"? (let ((n 2))\n"
"    (cube (incf n)))\n"
"60\n"
"</pre> "
msgstr ""

#: in/chapter20.html:518
msgid ""
"<p>In the second case, <code>(INCF N)</code> should have provided the \n"
"value 3 to <code>CUBE</code> and the result should have been identical\n"
"to the first test. Let's take a look at the expansion again, to see\n"
"what happened."
msgstr ""
"<p>\n"
"Во втором случае <code>(INCF N)</code> должен был предоставить <code>CUBE</"
"code>\n"
"значение 3, и результат должен был быть идентичен первому тесту. Давайте еще "
"раз \n"
"взглянем на расширение, чтобы увидеть, что произошло."

#: in/chapter20.html:523
msgid ""
"<pre>\n"
"? (macroexpand-1 '(cube (incf n)))\n"
"(* (INCF N) (INCF N) (INCF N))\n"
"</pre> "
msgstr ""

#: in/chapter20.html:529
msgid ""
"<p>The problem is obvious: <code>CUBE</code>'s argument, <code>(INCF\n"
"N)</code> is being evaluated multiple times. As a rule, this is a bad\n"
"thing to do, because it violates our assumptions about the way Lisp\n"
"evaluates forms. We fix this problem by arranging for the macro expander\n"
"to evaluate <code>CUBE</code>'s argument just once."
msgstr ""
"<p>\n"
"Проблема очевидна: аргумент <code>CUBE</code>  \n"
"<code>(INCF N)</code> вычисляется несколько раз. Как правило, это плохо, \n"
"потому что это нарушает наши предположения о том, как Lisp вычисляет "
"формы. \n"
"Мы исправляем эту проблему, организуя для расширителя макросов вычисление \n"
"аргумента <code>CUBE</code> только один раз.\n"

#: in/chapter20.html:540
msgid ""
"<pre>\n"
"? (defmacro cube (n)\n"
"    (let ((x (gensym)))\n"
"      `(let ((,x ,n))\n"
"         (* ,x ,x ,x))))\n"
"CUBE\n"
"? (let ((n 2))\n"
"    (cube (incf n)))\n"
"27\n"
"</pre> "
msgstr ""

#: in/chapter20.html:547
msgid ""
"<p>We created a unique symbol outside of the macro expander, then\n"
"used this symbol in the expander as the name of a variable to hold\n"
"the result of evaluating <code>CUBE</code>'s argument. The\n"
"<code>LET</code> form in the macro expander is the <em>only</em>\n"
"place where <code>CUBE</code>'s argument is referenced, so it gets\n"
"evaluated exactly once for each call to <code>CUBE</code>."
msgstr ""
"<p>\n"
"Мы создали уникальный символ вне расширителя макросов, а затем "
"использовали \n"
"этот символ в расширителе в качестве имени переменной для хранения "
"результата \n"
"вычисления аргумента <code>CUBE</code>. Форма <code>LET</code> в расширителе "
"макросов - \n"
"это единственное место, где ссылаются на аргумент <code>CUBE</code>, поэтому "
"он \n"
"вычисляется ровно один раз для каждого вызова <code>CUBE</code>."

#: in/chapter20.html:549
msgid "<h2>Macros vs. inlining</h2>"
msgstr "<h2>Макросы против встраивания(inlining)</h2>"

#: in/chapter20.html:556
msgid ""
"<p>Lisp allows functions to be inlined by the compiler. In other words,\n"
"rather than compiling a call to the function, the compiler may substitute\n"
"the function's body, thus saving the overhead of a function call.\n"
"Substituting the function's body is generally expensive in terms of space,\n"
"since a function body's code is usually longer than the code of its \n"
"calling sequence."
msgstr ""
"<p>\n"
"Lisp позволяет встраивать функции с помощью компилятора. Другими словами, \n"
"вместо компиляции вызова функции компилятор может заменить его на тело "
"функции, \n"
"тем самым экономя накладные расходы на вызов функции. Замена тела функции "
"обычно \n"
"обходится дорого с точки зрения пространства, так как код тела функции "
"обычно длиннее \n"
"кода ее вызывающей последовательности."

#: in/chapter20.html:561
msgid ""
"<p>It's important to understand that Lisp <em>allows</em> functions to\n"
"be inlined. Like all other declarations -- save the <code>SPECIAL</code> \n"
"declaration -- an <code>INLINE</code> declaration may be treated as\n"
"advisory or ignored entirely by the compiler."
msgstr ""
"<p>\n"
"Важно понимать, что Lisp <em>позволяет</em> функциям быть встраиваемыми. \n"
"Как и все другие объявления - за исключением объявления <code>SPECIAL</"
"code>  -\n"
"<code>INLINE</code>(встроенное) объявление может рассматриваться "
"компилятором \n"
"как рекомендательное или полностью игнорироваться."

#: in/chapter20.html:567
msgid ""
"<p>Here are some examples of how to inline a function.  In the first case, \n"
"function <code>F</code> is inlined everywhere it is used (assuming that\n"
"the compiler supports inlining).  In the second case, function <code>P</"
"code> \n"
"is compiled with information to support inlining, but is only inlined\n"
"in the presence of a declaration, as in function <code>Q</code>."
msgstr ""
"<p>\n"
"Вот несколько примеров того, как встроить функцию. В первом случае функция "
"<code>F</code>\n"
"встроена везде, где она используется (при условии, что компилятор "
"поддерживает встраивание функций). \n"
"Во втором случае функция <code>P</code> компилируется с информацией для "
"поддержки встраивания, но\n"
"встраивается только при наличии объявления, как в функции <code>Q</code>."

#: in/chapter20.html:572
msgid ""
"<pre>\n"
"<i>; Case 1 -- F may always be inlined</i> \n"
"(declaim (inline f))\n"
"(defun f (...) ...)"
msgstr ""

#: in/chapter20.html:576
msgid ""
"(defun g (...)\n"
"  (f ...)\n"
"  ...)"
msgstr ""

#: in/chapter20.html:580
msgid ""
"(defun h (...)\n"
"  (f ...)\n"
"  ...)"
msgstr ""

#: in/chapter20.html:585
msgid ""
"<i>; Case 2 - P may be inlined only following a declaration</i> \n"
"(declaim (inline p))\n"
"(defun p (...) ...)\n"
"(declaim (notinline p))"
msgstr ""

#: in/chapter20.html:590
msgid ""
"(defun q (...) \n"
"  (declare (inline p))\n"
"  (p ...) <i>; inlined</i> \n"
"  ...)"
msgstr ""

#: in/chapter20.html:595
msgid ""
"(defun r (...)\n"
"  (p ...) <i>; not inlined</i> \n"
"  ...)\n"
"</pre> "
msgstr ""

#: in/chapter20.html:599
msgid ""
"<p>Macros may be used in place of <code>INLINE</code> declarations for\n"
"cases where code absolutely <em>must</em> be inlined despite the presence\n"
"(or absence) of compiler support for inlining. "
msgstr ""
"<p>\n"
"Макросы могут использоваться вместо <code>INLINE</code> деклараций \n"
"в тех случаях, когда код обязательно <em>должен</em> быть встроен, \n"
"несмотря на наличие (или отсутствие) поддержки функции встраивания\n"
"у компилятора."

#: in/chapter20.html:604
msgid ""
"<p>In general, though, you should use macros for language extension,\n"
"and not for efficiency hacks. The risk of forgetting to recompile\n"
"after having changed a macro definition can cause hard-to-find bugs\n"
"that will waste a lot of your development effort."
msgstr ""
"<p>\n"
"В целом, однако, вы должны использовать макросы для расширения языка, \n"
"а не для взлома эффективности. Риск того, что вы забудете выполнить "
"перекомпиляцию \n"
"после изменения определения макроса, может привести к трудноопределяемым "
"ошибкам, \n"
"которые приведут к затратам многих усилий по разработке."

#: in/chapter20.html:613
msgid ""
"<blockquote> My advice: Don't use macros as a substitute for\n"
"inlining unless you can find no other way to achieve desired\n"
"performance; of course, such efforts should be guided by the results\n"
"of profiling your code (see <a href=\"chapter28.html\"> Chapter\n"
"28</a>) and preferably only when your code is already stable and\n"
"debugged. You should also reexamine your decision with each new\n"
"release of your Lisp compiler, and whenever you port your program to\n"
"another Lisp platform. </blockquote> "
msgstr ""
"<blockquote> \n"
"Мой совет: не используйте макросы в качестве замены встраивания, \n"
"если вы не можете найти другого способа достичь желаемой "
"производительности; \n"
"конечно, такие усилия должны основываться на результатах профилирования \n"
"вашего кода (см. <a href=\"chapter28.html\">Главу 28</a>) и "
"предпочтительно \n"
"только тогда, когда ваш код уже стабилен и отлажен. Вы также должны \n"
"пересмотреть свое решение с каждым новым выпуском вашего компилятора Lisp "
"и \n"
"всякий раз, когда вы переносите свою программу на другую платформу Lisp.\n"
" </blockquote> "

#: in/chapter20.html:626
msgid ""
"<hr>\n"
"<div align=\"center\">\n"
"<a href=\"contents.html\">Contents</a> | <a href=\"cover.html\">Cover</a> "
"<br> \n"
"<a href=\"chapter19.html\">Chapter 19</a> | Chapter 20 | <a href=\"chapter21."
"html\">Chapter 21</a> \n"
"</div>\n"
"<hr>\n"
"<address>\n"
"Copyright &copy; 1995-2001, David B. Lamkins<br>\n"
"All Rights Reserved Worldwide<br>\n"
"<br>\n"
"This book may not be reproduced without the written consent of its author.  "
"Online distribution is restricted to the author's site.\n"
"</address> \n"
"</body> </html> "
msgstr ""
