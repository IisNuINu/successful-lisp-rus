<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Successful Lisp - Chapter 28</title>
</head> 

<body bgcolor="white" text="black">
<h1>Глава 28 - Практические приемы программирования</h1> 

<P>
В этой главе мы изучим некоторые краткие, но полезные рекомендации по 
стилю Lisp, а затем дадим практические советы по компромиссам между 
отладкой, производительностью и удобочитаемостью.
</P>

<h2>Элементы стиля Лисп</h2>

<p>
Искусство Лисп стиля проще и плодотворнее, чем в большинстве других языков. 
Простой, последовательный синтаксис Lisp устраняет необходимость в правилах 
стиля, которые мешают более сложным языкам. А прямая стандартизированная 
доступность сложных функциональных возможностей в рамках Lisp помогает 
уменьшить размер программ, тем самым обеспечивая улучшенную читаемость 
за счет краткости. (По моему опыту, размер Лисп-программы может 
варьироваться от 5 до 20 процентов от размера эквивалентной программы 
на языке C++.)

<p>
Кроме того, универсальная доступность инструментов редактирования программ 
с поддержкой Lisp, таких как Emacs или его эквивалент, встроенный во многие 
идентификаторы Lisp, означает, что вы можете позволить компьютеру обрабатывать 
детали отступов, которые так важны для способности человека понять структуру 
программы Lisp. Я уже говорил это раньше,но стоит повторить: вы не должны 
программировать на Лиспе без помощи редактора, знающего Лисп.

<p>
Итак, если нам не нужно беспокоиться о условностях написания, заглавных 
буквах, отступах и других таких обыденных деталях, то что же нам остается 
обсуждать про элементы стиля Lisp? А как насчет того, что действительно 
важно? Стиль программирования Lisp - это выбор правильных абстракций и 
общение не только с компилятором, но и с другими людьми, которые в 
конечном итоге прочитают вашу программу. (Если уж на то пошло, хороший 
стиль поможет вам прочитать вашу собственную программу через несколько 
месяцев или лет в будущем.)

<h2>Списки свойств удобны для небольших (очень маленьких) специальных баз данных</h2>

<p>
Давным-давно возможности типичной реализации Lisp были намного меньше, 
чем то, что вы найдете в любой обычной системе Lisp сегодня. В конце 
концов, Лисп существует уже более сорока лет, с тех пор как Джон Маккарти 
впервые изобрел эти обозначения (см. <a href="chapter34.html">Главу 34</a>). 
Как ни странно, когда Лисп вообще преподается в учебных программах по 
информатике, он преподается с использованием представления о состоянии 
реализаций Лиспа примерно в 1965 году: интерпретируемое выполнение, 
ограниченные структуры данных и отсутствие реального применения, кроме 
манипулирования символами.

<p>
К сожалению, авторы и издатели учебников по Лиспу мало что сделали, 
чтобы исправить эти ошибочные представления, игнорируя Common Lisp 
(и действительно, многие из его недавних предшественников) в настоятельно
рекомендованных учебниках по Лиспу, опубликованных совсем недавно, в 
1989 году.

<p>
В старые недобрые времена -- когда в Lisp не было массивов, векторов, 
хэш-таблиц, структур или CLOS -- программисты научились в значительной 
степени полагаться на списки свойств(property lists) как на важный механизм
структурирования данных. Вы все еще найдете -- в книжных магазинах и на полках
университетских библиотек -- книги Lisp и AI, которые рекомендуют использовать 
списки свойств в качестве базовой основы для поиска значений, идентифицируемых
символическим ключом.


<p>
Список свойств - это список чередующихся ключей и значений. Например: 
список <code>(SEX MALE PARENTS (BOB JANE) OCCUPATION MUSICIAN)</code> 
устанавливает эти отношения:

<pre>
relation   value
---------- ----------
sex        male
parents    (bob jane)
occupation musician
</pre> 

Когда вы прикрепляете эти отношения к символу, скажем <code>JAMES</code>, 
тогда у вас есть способ получить информацию, связанную с символом code>JAMES</code>,
а именно свойства, имеющие имена пол(<code>SEX</code>), родители(<code>PARENTS</code>)
 и род занятий(<code>OCCUPATION</code>)

<p>
В Common Lisp вы можете получить значение свойства символа через 
<code>(GET</code> <i>symbol</i> <i>property-name</i><code>)</code>
и установить значение свойства, используя <code>(SETF (GET</code> <i>symbol</i>
<code>property-name</code><code>)</code> <i>property-value</i><code>)</code>. 

<p>
На то время  списки свойств были полезными заменителями более эффективных 
структур данных в древних реализациях Lisp, они находят мало применения 
в современных программах Lisp. Одна из проблем - это эффективность. Каждый раз, 
когда вы просите Lisp получить значение свойства, он должен найти список 
свойств символа, а затем выполнить поиск в списке соответствующего ключа. 
Если у вас есть пять или шесть свойств для символа, поиск может быть или 
не быть быстрее, чем с помощью хэш-таблицы; точная точка пересечения будет 
зависеть от вашей конкретной реализации Lisp. Другая проблема заключается 
в том, что свойства являются общими для всех частей вашей программы. 
Нетрудно представить себе двух программистов, использующих свойство <code>COLOR</code>
двумя разными способами в двух частях одной и той же программы. Представьте 
себе их удивление, когда они обнаружат конфликт...

<p>
Во всяком случае, вы должны ознакомиться со всеми возможностями Common Lisp и 
научиться распознавать ту информацию о более старой реализации Lisp, которая 
все еще преследует нас сквозь туманы истории.



<h2>Объявления помогают компилятору, иногда</h2>

<p>Common Lisp определяет следующие объявления:

<dl>
<dt>special
<dd>объявляет переменную с динамической (не лексической) областью видимости
<dt>optimize
<dd>Инструктирует компилятор, как взвешивать относительную важность
 <ul>
  <li>speed
  <li>safety
  <li>space
  <li>debug
  <li>compilation-speed
 </ul> 
<dt>dynamic-extent
<dd>объявляет, что программист ожидает, что время жизни функции или 
    переменной закончится, когда управление покинет заключающую форму
<dt>type
<dd>dобъявляет, что переменная всегда будет иметь значения заданного типа
<dt>ftype
<dd>объявляет, что функция должна ожидать аргументы указанных типов и что 
    функция будет возвращать значения или заданные типы
<dt>ignore
<dd>объявляет, что на переменную не ссылаются
<dt>ignorable
<dd>объявляет, что на переменную нельзя ссылаться
<dt>inline
<dd>объявляет, что программист хотел бы, чтобы функция была скомпилирована как 
встроенный код
<dt>notinline
<dd>объявляет, что программист не хочет, чтобы функция компилировалась как 
встроенный код
</dl> 

<p>
Из них только первое и последнее должно быть реализовано. Остальные 
рекомендации носят рекомендательный характер; в зависимости от реализации 
компилятор может выполнять или не выполнять данный совет. Если вы 
программировали на других языках, вам может показаться странным, 
что большинство объявлений Lisp носят рекомендательный, а не 
обязательный характер. Поэтому давайте копнем немного глубже 
и посмотрим, что это действительно значит для вас.

<p>
Lisp по умолчанию должен иметь возможность определять тип каждой 
переменной во время выполнения. Это не означает, что достаточно 
умный компилятор не может сделать вывод во время компиляции, что 
переменная всегда будет иметь определенный тип и генерировать код, 
который не нуждается в проверке типов во время выполнения. Однако
 настоящий "достаточно умный компилятор" остается неуловимым существом, 
очень похожим на Йети, снежного человека и Лох-Несское чудовище.

<p>
Объявления позволяют программисту передавать компилятору метаинформацию. 
Это не часть программы, а скорее информация о программе. Объявления могут 
помочь компилятору создать лучший код, предоставляя информацию о 
намерениях программиста.

<p>
Например, если вы объявите, что переменная всегда будет <code>FIXNUM</code>
(целочисленное значение, которое помещается в одно машинное слово), 
то компилятор может выдать код для загрузки этой переменной непосредственно 
в регистр при подготовке к следующей операции. Если вы объявите результат 
операции также фиксированным числом, то компилятор может сгенерировать 
код для выполнения операции и сохранить результат, используя простые 
машинные инструкции, без предварительной проверки фактического(<code>actual</code>)
типа значения. Учитывая такие объявления, хороший компилятор Lisp может 
генерировать код, сравнимый с низкоуровневым языком, в котором операции и 
типы в языке сопоставляются непосредственно с базовой машиной.

<p>
Но тут есть определенный риск. Если вы объявляете определенные типы, 
и компилятор выдает код, который оптимизирует программу в соответствии 
с вашими объявлениями, а затем программа противоречит этим объявлениям, 
предоставляя значение другого типа во время выполнения, то  будут происходить
плохие вещи. Скажите компилятору, чтобы он ожидал сложения двух чисел, 
затем передайте ему число и символ, и вас ждет крах.

<p>
К счастью, объявления, которыми руководствуется компилятор, сами 
модерируются(управляются) объявлением <code>OPTIMIZE</code>. Объявление 
<code>OPTIMIZE</code> позволяет проинструктировать компилятор об относительной 
важности определенных свойств программы. Вы можете указать относительную 
важность <code>SPEED</code>, <code>SPACE</code>, и <code>SIZE</code>  
сгенерированного кода. Вы можете 
указать, хотите ли вы позволить компилятору тратить дополнительное время 
на выполнение лучшей работы или подчеркнуть <code>COMPILATION-SPEED</code>. 
Вы можете 
указать важность возможности отладки(<code>DEBUG</code>) вашей программы, что может привести к тому, что компилятор будет создавать код, который является более простым 
или хорошо взаимодействует с отладчиком.

<blockquote>
Значения варьируются от 0 до 3 для деклараций оптимизации(<code>OPTIMIZE</code>), 
причем 0 означает "совершенно неважный", а 3 - "самый важный". Значение по 
умолчанию равно 1, Что означает "нормальной важности". Имейте в виду, что 
для того, чтобы что-то было относительно более важным, что-то другое должно 
быть менее важным; это не даст компилятору никаких полезных указаний по 
указанию значений 3 для всех объявлений <code>OPTIMIZE</code>
</blockquote> 

<p>
Из всех объявлений <code>OPTIMIZE</code> наиболее важным является безопасность
(<code>SAFETY</code>), поскольку это влияет на степень доверия, которое 
компилятор готов распространить на ваши объявления типов. Высокое значение 
безопасности(<code>SAFETY</code>) обычно заставляет компилятор проверять 
тип каждого значения, которое он не может полностью определить во время компиляции. 
Более низкие значения безопасности(<code>SAFETY</code>) придают все больший вес 
вашим способностям программиста, гарантируя, что объявления типов верны, границы 
массива всегда находятся в диапазоне и т. д.

<p>
Точный эффект деклараций (за исключением <code>SPECIAL</code> и 
<code>NOTINLINE</code>) варьируется в зависимости от реализаций Lisp; 
обратитесь к вашему справочному руководству для получения подробной 
информации.

<h2>DEFVAR против DEFPARAMETER</h2>

<p>
Хотя стандарт Common Lisp этого не требует, почти все реализации требуют 
загрузки кода из файла. (Единственное исключение, о котором я знаю, - 
это окружение Venue Medley, которое обычно спасает весь мир Lisp, когда вы 
заканчиваете сеанс. Medley также отслеживает новые определения, созданные в 
прослушивателе, и позволяет сохранять только эти определения в файл.)

<p>
В файловой среде Lisp вы обычно добавляете определения в файл исходного кода. 
Одна из причин этого заключается в том, чтобы периодически сохранять свою работу; 
если вы не отлаживаете FFI-код или не запускаете глючный Lisp-код с низким 
значением оптимизации для обеспечения безопасности, ваша среда Lisp почти 
никогда не будет аварийно завершаться. Однако могут произойти и другие 
катастрофы - другое приложение может разбиться и вывести из строя систему 
в незащищенной операционной системе, такой как Mac OS или Windows, питание 
может выйти из строя, или ваша кошка может ходить по клавиатуре, когда вы 
уходите, чтобы наполнить свой кофе.

<p>
По мере того как ваша программа становится больше, вы можете обнаружить, 
что полезно перезагрузить весь исходный файл после внесения ряда изменений. 
Большинство сред Lisp также позволяют вычислять одно определение за один 
раз в любом открытом окне. Это очень полезно, потому что вы можете редактировать, 
а затем перекомпилировать одно определение за раз. Но иногда вы забываете, и 
тогда проще просто перезагрузить весь файл, чем тратить время на выяснение того, 
какое определение вы, возможно, забыли перекомпилировать после последнего изменения 
его определения.

<p>
Но вы также можете быть в середине отладки вашей программы, когда вы 
захотите перезагрузить ее исходный код. Если ваша программа использует 
какие-либо глобальные переменные для отслеживания своего состояния, 
вы действительно не хотите повторно инициализировать их в разгар 
сеанса отладки. Итак, как вы справляетесь с этим? Вы можете поместить 
определения переменных состояния вашей программы в отдельный файл, 
но это увеличивает вашу умственную нагрузку и увеличивает время отладки, 
разделяя ясно взаимосвязанные части вашей программы на два отдельных файла. 
(Я знаю, что это общепринятая практика во многих языках программирования, 
но она действительно увеличивает объем работы, которую вы делаете как 
программист. Представьте себе, насколько менее приятным было бы чтение романа, 
если бы он был представлен в виде набора брошюр, по одной на каждого персонажа, 
и вам пришлось бы следовать ссылкам на страницы, чтобы перейти к следующей 
части диалога.)

<p>
К счастью, Lisp вырос за десятилетия реального опыта программирования и 
имеет очень простой механизм для обработки того, будут ли переменные повторно
инициализированы или нет, когда вы загружаете файл. Вы используете DEFVAR для 
объявления переменных со значениями, которые должны быть инициализированы только 
один раз. Чтобы объявить переменную с начальным значением, которое устанавливается 
каждый раз при вычислении ее определяющей формы, используйте  <code>DEFPARAMETER</code>.

<p>
И последнее замечание: по форме вы должны называть глобальные переменные 
с начальными и конечными звездочками, как в <code>*MY-ADDRESS*</code>. 
Думайте об этом соглашении как о любезности по отношению к тем, кто 
будет поддерживать ваш код в будущем.

<h2>Определяйте константы с помощью DEFCONSTANT</h2>

<p>
Вы должны определить глобальные константы с помощью <code>DEFCONSTANT</code>. 
С точки зрения чтения программы Lisp, различие между <code>DEFPARAMETER</code> и
<code>DEFCONSTANT</code>заключается в том, что значение, определенное 
<code>DEFPARAMETER</code>, может быть изменено пользователем после компиляции 
программы, но значение <code>DEFCONSTANT</code> никогда не изменится. Хороший 
компилятор Lisp использует преимущества  деклараций <code>DEFCONSTANT</code> для
выполнения классических оптимизаций, таких как  свертка константных вычислений или
компиляция инструкций немедленной загрузки.

<p>
Меньше Лисп-программистов следуют соглашению об именовании констант. 
Тот, который я использую, ставит начальный и конечный знак плюс к имени
константы, как в  <code>+RTS-OPCODE+</code>.

<h2>Знайте когда (не) использовать компилятор</h2>

<p>
Большинство систем Lisp включают в себя как интерпретатор, так и компилятор; 
когда они доступны, вы обычно обнаруживаете, что легче отлаживать интерпретируемый 
код. Обратитесь к документации вашего поставщика, чтобы узнать, как переключаться 
между интерпретатором и компилятором.

<p>
Конечно, когда важна производительность, вы захотите запустить свой код, 
скомпилированный после его отладки. Но смотрите более ранние предостережения 
о запуске багги кода с низкими настройками безопасности.

<p>
Когда вы пишете Lisp-код для запуска на нескольких платформах, безопаснее 
всего предположить, что код будет работать интерпретируемо, если вы не 
вызовете <code>COMPILE</code> или <code>COMPILE-FILE</code>. По этой причине 
вы должны разработать практику написания (или использования) процедуры определения
системы, которая сначала загружает все исходные файлы Lisp, затем компилирует их, 
а затем загружает скомпилированные файлы. Обычно это перебор, но это очень безопасный,
консервативный подход. При подходящей организации исходного кода и правильном
использовании <code>EVAL-WHEN</code> вы можете уменьшить количество исходных файлов,
которые должны быть загружены в первую очередь; основная идея состоит в том, чтобы
убедиться, что все макросы определены до компиляции кода, который использует макросы, 
но есть и другие возможные ситуации, которые могут зависеть от текущего состояния мира
Lisp.

<h2>Скорость против способности к отладке</h2>

<p>
Интерпретируемые программы легче отлаживаются, потому что отладчику 
легче получить доступ к фактическому исходному коду в момент ошибки. 
После того как вы скомпилировали программу, отладчик обычно имеет меньше 
доступной исходной информации; вы можете обнаружить, что ломаете голову 
над преобразованной версией исходного кода или пресмыкаетесь перед 
инструкциями на ассемблере, чтобы найти источник ошибки. К счастью, 
необходимость в такой низкоуровневой отладке возникнет редко, если вы 
будете следовать некоторым простым советам:

<ol>
<li>Сохраняйте высокий уровень  <code>SAFETY</code> (безопасности) при
    оптимизации на непроверенном коде.
<li>Если вам доступен интерпретатор, используйте его до тех пор, пока ваш код 
    не будет работать хорошо.
<li>Если у вас есть среда только с компиляцией, используйте более низкие параметры
    оптимизации для <code>SPEED</code> и более высокие параметры для <code>DEBUG</code>.
</ol> 

<p>
После того, как ваш код работает хорошо, вы должны скомпилировать 
его и настроить объявления оптимизации для повышения производительности. 
Если вы обнаружите, что простая компиляция вашей программы обеспечивает 
достаточную производительность, оставьте ее в покое. Если производительность
скомпилированной программы значительно ниже ваших ожиданий, сначала 
улучшите алгоритм; объявления оптимизации обычно оказывают дробное 
влияние на производительность.

<a name="efficiency"></a> 
<h2>Эффективность: обнаружить, проверить</h2>

<p>
Первое правило эффективности в любом языке программирования-начинать 
с эффективного алгоритма. Немного сложнее обнаружить неэффективность 
в программе Lisp, потому что базовые операции обычно не отображаются 
непосредственно на аппаратную инструкцию. Но с определенным количеством 
знаний и практики вы должны быть в состоянии сказать, почему следующие 
четыре программы имеют радикально отличающиеся требования к ресурсам.


<p>
Эти четыре программы возвращают сумму списка чисел, но делают это по-разному. 
В каждом случае мы тестируем программу с формой <code>TIME</code>, которая
сообщает о времени выполнения и выделении памяти. Каждая программа тестируется 
дважды, один раз со списком из десяти тысяч элементов, а затем со ста тысячами.

<pre>
<i>;; Runtime increases as the square of the number of elements</i> 
? (defun sum-list-bad-1 (list)
    (let ((result 0))
      (dotimes (i (length list))
        (incf result (elt list i)))
      result))
SUM-LIST-BAD-1
? (let ((list (make-list 10000 :initial-element 1)))
    (time (sum-list-bad-1 list)))
(SUM-LIST-BAD-1 LIST) took 2,199 milliseconds (2.199 seconds) to run.
Of that, 102 milliseconds (0.102 seconds) were spent in The Cooperative Multitasking Experience.
 16 bytes of memory allocated.
10000
? (let ((list (make-list 100000 :initial-element 1)))
    (time (sum-list-bad-1 list)))
(SUM-LIST-BAD-1 LIST) took 336,650 milliseconds (336.650 seconds) to run.
Of that, 15,680 milliseconds (15.680 seconds) were spent in The Cooperative Multitasking Experience.
 2,704 bytes of memory allocated.
100000

<i>;; Recursive version works when compiler does tail-call optimization</i> 
? (defun sum-list-bad-2 (list)
    (labels ((do-sum (rest-list sum)
               (if (null rest-list)
                 sum
                 (do-sum (rest rest-list) (+ sum (first rest-list))))))
      (do-sum list 0)))
SUM-LIST-BAD-2
? (let ((list (make-list 10000 :initial-element 1)))
    (time (sum-list-bad-2 list)))
(SUM-LIST-BAD-2 LIST) took 2 milliseconds (0.002 seconds) to run.
10000
? (let ((list (make-list 100000 :initial-element 1)))
    (time (sum-list-bad-2 list)))
(SUM-LIST-BAD-2 LIST) took 21 milliseconds (0.021 seconds) to run.
100000

<i>;; The recursive version can fail w/o tail-call optimization</i> 
? (defun sum-list-bad-3 (list)
    (declare (optimize (debug 3)))  <i>; disable tail-call optimization</i> 
    (labels ((do-sum (rest-list sum)
               (if (null rest-list)
                 sum
                 (do-sum (rest rest-list) (+ sum (first rest-list))))))
      (do-sum list 0)))
SUM-LIST-BAD-3
? (let ((list (make-list 10000 :initial-element 1)))
    (time (sum-list-bad-3 list)))
&gt; Error: Stack overflow on control stack.

<i>;; The iterative version is not as elegant, but it's fast!</i> 
? (defun sum-list-good (list)
    (let ((sum 0))
      (do ((list list (rest list)))
          ((endp list) sum)
        (incf sum (first list)))))
SUM-LIST-GOOD
? (let ((list (make-list 10000 :initial-element 1)))
    (time (sum-list-good list)))
(SUM-LIST-GOOD LIST) took 1 milliseconds (0.001 seconds) to run.
10000
? (let ((list (make-list 100000 :initial-element 1)))
    (time (sum-list-good list)))
(SUM-LIST-GOOD LIST) took 10 milliseconds (0.010 seconds) to run.
100000
</pre> 

<p>
Первая версия, <code>SUM-LIST-BAD-1</code>, скрывает скрытую неэффективность: 
<code>(ELT LIST I)</code> должен искать в списке (<code>LIST</code>) с самого 
начала для каждого значения <code>I</code>. другими словами, <code>ELT</code> 
должен исследовать один элемент, когда <code>I</code> равен 1, два элемента, 
когда <code>I</code> равен 2, и так далее. Для списка длины <i>N</i>, <code>ELT</code>
будет рассматривать почти <i>N</i>-квадрат элементов. Взгляните на время выполнения 
для 1000 и 10 000 элементов.


<p>
Вторая версия кодируется с помощью осознания того, как осуществляется 
доступ к спискам; вспомогательная функция <code>DO-SUM</code> вызывает 
себя рекурсивно с хвостом списка, который ей задан. В <code>SUM-LIST-BAD-2</code>
Время выполнения увеличивается линейно с длиной входного списка. 
Так почему же это плохой пример?

<p>
<code>DO-SUM</code> вызывает себя как последнюю форму, которую он выполняет; 
это известно как хвостовая рекурсия. Некоторые компиляторы могут компилировать 
хвостовую рекурсию как команду перехода вместо вызова функции; это исключает 
рост стека управления (возврат функции), который в противном случае произошел бы при рекурсивном вызове. Однако стандарт Common Lisp не требует оптимизации хвостовых 
вызовов.

<p>
Третья версия показывает, что может произойти, если компилятор не 
оптимизирует хвостовую рекурсию. Компилятор в моей системе Lisp 
отключает оптимизацию хвостовой рекурсии, когда оптимизация <code>DEBUG</code>
(отладки) установлена равной 3. Без оптимизации хвостовой рекурсии 
<code>SUM-LIST-BAD-3</code>потребляет фрейм вызова функции для каждого 
рекурсивного вызова, и программа терпит неудачу-исчерпывает пространство 
стека-до достижения конца тестового списка.

<p>
Заключительная версия,  <code>SUM-LIST-GOOD</code>, использует итерацию 
вместо рекурсии для своего цикла управления и проходит по входному списку 
элемент за элементом. Он работает немного быстрее, чем <code>SUM-LIST-BAD-2</code>, 
и не терпит неудачи, если компилятор не поддерживает оптимизацию хвостовой 
рекурсии.

<h2>Признавая не эффективность, профилирование; производительность против читаемости</h2>

<p>
Предотвращение -лучшая защита от неэффективности. Используйте соответствующие 
структуры данных и методы управления. Когда вы не уверены, составьте небольшую 
тестовую программу и время ее работы с различными входными данными.

<p>
Каждая реализация Common Lisp будет иметь макрос <code>TIME</code>, 
который мы использовали для отображения различий в функциях 
<code>SUM-LIST-</code><i>xxx</i>. Вы можете использовать его для изучения 
и настройки небольших частей программы.

<p>
После того как вы собрали большую программу, вам может понадобиться 
найти узкое место, которое вызывает неожиданно низкую производительность. 
Для этого вам понадобится профилировщик. Профилировщик следит за выполнением 
всей вашей программы и создает отчет, чтобы показать, где программа проводит 
свое время. Некоторые профили также сообщают о выделении памяти. Профилировщик 
не является стандартной частью Lisp, но большинство поставщиков предоставляют 
его. Обратитесь к документации вашего поставщика.


<p>
Lisp предоставляет абстракции, которые помогут вам решить проблемы. 
Вы обнаружите, что вам не нужно делать компромисс между удобочитаемостью 
и производительностью; эффективная программа Lisp обычно написана с 
использованием наиболее подходящих абстракций и операций для решения 
данной проблемы.

<hr>
<div align="center">
<a href="contents.html">Contents</a> | <a href="cover.html">Cover</a> <br> 
<a href="chapter27.html">Chapter 27</a> | Chapter 28 | <a href="chapter29.html">Chapter 29</a> 
</div>
<hr>
<address>
Copyright &copy; 1995-2001, David B. Lamkins<br>
All Rights Reserved Worldwide<br>
<br>
This book may not be reproduced without the written consent of its author.  Online distribution is restricted to the author's site.
</address> 
</body> </html>