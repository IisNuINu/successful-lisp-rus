<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Successful Lisp - Chapter 16</title>
</head> 

<body bgcolor="white" text="black">
<h1>Глава 16 - Как найти обходной путь, часть 2</h1> 

<P>
Пришло время сделать перерыв и узнать о некоторых других инструментах, 
которые вы можете использовать, чтобы изучить <a href="#footnote1">[1]</a>
внутреннюю работу Lisp и ваших программ. В этой главе мы узнаем, что 
компилятор Lisp делает с вашим кодом, и как посмотреть, что ваш код 
делает во время работы.

<h2>DISASSEMBLE: Мне всегда было интересно, что они кладут в эти вещи...</h2>

<p>
Если вы немного разбираетесь в компиляторах и языке ассемблера - 
или если вам просто бесконечно любопытно , - вы можете точно узнать, 
<em>как</em> компилятор Lisp преобразует ваш код Lisp. <code>DISASSEMBLE</code>
принимает имя функции или объекта и выдает список инструкций на языке ассемблера, 
которые были бы выданы компилятором Lisp, если бы он действительно выдал код на 
языке ассемблера - большинство компиляторов непосредственно генерируют машинные 
инструкции без вызова ассемблера.

<p>
Результат <code>DISASSEMBLE</code> зависит как от архитектуры набора 
инструкций машины, которую вы используете для запуска Lisp, так и 
от самой реализации Lisp. Вот пример использования дизассемблирования 
на очень простой функции; это было сделано с помощью Macintosh Common Lisp 
на процессоре PowerPC.

<pre>
? (defun add1 (n) (1+ n))
ADD1
? (disassemble 'add1)
  (TWNEI NARGS 4)
  (MFLR LOC-PC)
  (BLA .SPSAVECONTEXTVSP)
  (VPUSH ARG_Z)
  (LWZ NARGS 331 RNIL)
  (TWGTI NARGS 0)
  (LI ARG_Y '1)
  (LWZ ARG_Z 0 VSP)
  (BLA .SPRESTORECONTEXT)
  (MTLR LOC-PC)
  (BA .SPBUILTIN-PLUS)
</pre> 

<p>
Первое, что вы заметите в этом списке, - это то, что он выглядит 
"Lisp-повским" с круглыми скобками. Вторая вещь, которую вы заметите - 
если вы знакомы с набором инструкций PowerPC - это то, что большинство
этих форм знакомы; это как если бы кто-то взял часть реальной программы 
языка ассемблера PowerPC и заключил каждую строку текста в скобки. 
Вы также можете заметить, что в ассемблерном коде нет комментариев, 
что есть некоторые псевдо-инструкции, такие как VPUSH, и что это 
не полная программа, которую вы могли бы ввести в ассемблер (даже 
после того, как вы сняли скобки). Я объясню вам все эти моменты.

<p>
Многие системы Lisp включают ассемблер, который принимает операторы в форме, 
генерируемой <code>DISASSEMBLE</code>. Эти операторы часто называются LAP, 
или Lisp Assembly Program. При наличии соответствующей документации вы можете 
написать код LAP и вызвать его своими собственными функциями. Но для этого вам
действительно нужна документация поставщика; вы не можете просто найти ассемблер 
LAP и передать ему список инструкций LAP. Вы должны знать, как использовать
зарезервированные регистры, какие подпрограммы вызывать, какому протоколу стека 
следовать и многие другие низкоуровневые детали. Вам также нужно связать код с 
именем функции, чтобы вы могли вызвать его позже; это одна из частей, которая 
отсутствует в выходных данных <code>DISASSEMBLE</code>.

<p>
Некоторые системы Lisp предоставляют дополнительную информацию 
(помимо необработанных инструкций ассемблера) в  выходных 
данных <code>DISASSEMBLE</code>. В приведенном выше коде вы увидите, 
что некоторые зарезервированные регистры или места памяти идентифицируются 
с помощью отличительного имени, такого как <code>NARGS</code>, <code>LOC-PC</code>,
<code>ARG_Y</code>, <code>ARG_Z</code>, <code>VSP</code> и <code>RNIL</code>.
Иногда некоторым инструкциям (или даже коротким последовательностям команд) 
присваивается мнемоническое имя, которое отражает их использование 
компилятором Lisp; <code>VPUSH</code>-это одна из таких мнемоник, 
используемых этой системой Lisp.

<p>
Некоторые Лисп-системы лучше других справляются с включением пояснительных 
комментариев к дизассеблированному коду. Системы, включающие комментарии, 
обычно синтезируют комментарии для объяснения кода или сохраняют 
информацию, позволяющую <code>DISASSEMBLE</code> разнообразить
фрагментами исходных программ список дизассемблирования.

<p>
Одна полезная вещь, которую вы можете сделать с <code>DISASSEMBLE</code>, - 
это посмотреть, оказывают ли объявления какое-либо влияние на ваш компилятор. 
Объявления - это формы, которые предоставляют рекомендации компилятору. 
За одним исключением объявления <code>SPECIAL</code>, которое изменяет 
значение кода, использующего его (см. 
<a href="chapter08.html#special">Глава 8</a>), компилятор может использовать или не
использовать информацию, которую вы предоставляете в объявлении. Документация вашего
поставщика Lisp может содержать некоторые указания относительно влияния деклараций, 
но наилучшая (и наиболее точная) оценка производится путем чтения списка, 
который генерирует <code>DISASSEMBLE</code>.

<p>
Предыдущее дизассемблирование <code>ADD1</code> показывает, что он вызывает 
несколько подпрограмм: <code>.SPSAVECONTEXTVSP</code>,
<code>.SPRESTORECONTEXT</code>, и <code>.SPBUILTIN-PLUS</code>. Если вам кажется, 
что это ужасно много работы, чтобы просто добавить один к числу, подумайте, что 
(1) число может быть любого типа (включая bignum, который является "бесконечным"
целочисленным типом точности), (2) нечисловые аргументы обрабатываются изящно-
вы получите выход в отладчик Lisp, а не сбой или дамп ядра, и (3) функция, 
вероятно, прилагает дополнительные усилия, чтобы сообщить о своем присутствии 
отладчику Lisp.

<p>
Итак, что же делать, если мы хотим играть быстро и свободно, предполагая, 
что <code>ADD1</code>  будет вызываться только для небольших целочисленных 
аргументов, и стоически страдать от неприятных последствий, если мы 
облажаемся и передадим неправильный тип данных? Мы можем добавить объявления, 
чтобы выразить наше намерение, а затем снова использовать <code>DISASSEMBLE</code>, 
чтобы увидеть, обратил ли компилятор какое-либо внимание на наши пожелания.

<pre>
? (defun int-add1 (n)
    (declare (fixnum n)
             (optimize (speed 3) (safety 0) (debug 0)))
    (the fixnum (1+ n)))
INT-ADD1
? (disassemble 'int-add1)
  (MFLR LOC-PC)
  (STWU SP -16 SP)
  (STW FN 4 SP)
  (STW LOC-PC 8 SP)
  (STW VSP 12 SP)
  (MR FN TEMP2)
  (LWZ IMM0 -117 RNIL)
  (TWLLT SP IMM0)
  (VPUSH ARG_Z)
  (LWZ ARG_Z 0 VSP)
  (ADDI ARG_Z ARG_Z 4)
  (LWZ LOC-PC 8 SP)
  (MTLR LOC-PC)
  (LWZ VSP 12 SP)
  (LWZ FN 4 SP)
  (LA SP 16 SP)
  (BLR)
</pre> 

<p>
Форма <code>DECLARE</code> в <code>INT-ADD1</code> включает в себя два 
вида советов. <code>(FIXNUM N)</code> объявляет, что параметр функции <code>N</code>
является малым целым числом. (Диапазон зависит от вашей реализации Lisp, 
но обычно вы получаете 29-битные fixnums на 32-битном процессоре; 
оставшиеся три бита часто используются системой Lisp для кодирования информации о типе.)
Объявление <code>(OPTIMIZE ...</code> - Это совет компилятору, что вы 
хотите, чтобы он подчеркивал определенные свойства скомпилированного 
кода. Здесь я сказал, что скорость имеет первостепенное значение, и 
что я мог бы меньше заботиться о безопасности выполнения или отладке. 
Если компилятор обращает внимание на все это, я должен получить код, 
который оптимизирован для fixnum, работает быстро и падает, если я 
передаю ему что-то другое, кроме fixnum, или заставляю его генерировать 
результат, который не является fixnum.

<p>
Глядя на сгенерированный код, кажется, что компилятор обратил внимание 
на мои объявления. Скомпилированный код для <code>INT-ADD1</code> немного 
длиннее кода для <code>ADD1</code>, но в нем нет вызовов подпрограмм. 
Каждая инструкция, генерируемая для <code>INT-ADD1</code>, является простой 
инструкцией PowerPC (даже инструкция <code>VPUSH</code>, которая является 
просто псевдонимом для одной инструкции PowerPC). Сложение выполняется 
инструкцией для PowerPC, а не подпрограммой. На самом деле, большая часть 
кода в <code>INT-ADD1</code> имеет отношение к входу и выходу из функции.


<p>
Кстати, <em>некоторые</em> настройки оптимизации всегда действуют, если 
вы не используете декларацию <code>(OPTIMIZE ...</code>. Чтобы узнать, 
каковы параметры глобальной оптимизации, выполните следующие действия:

<pre>
? (declaration-information 'optimize)
((SPEED 1) (SAFETY 1) (COMPILATION-SPEED 1) (SPACE 1) (DEBUG 1))
</pre> 

<blockquote> 
<code>DECLARATION-INFORMATION</code> может не существовать в реализации 
Pre-ANSI Common Lisp, но может существовать альтернативный способ доступа 
к этой информации. Обратитесь к документации поставщика. Если это не
сработает, посмотрите, может ли <code>APROPOS</code> (см. 
<a href="chapter10.html">Главу 10</a>) найти что-нибудь полезное. 
</blockquote> 

<h2>BREAK и backtrace: как я попал сюда?</h2>

<p>
Если вам когда-нибудь понадобится точно выяснить, что происходит в 
определенной точке вашей программы, вы можете вставить форму <code>BREAK</code>
в интересующую вас точку; когда ваша программа выполнит <code>BREAK</code>, 
система Lisp немедленно остановит вашу программу (без потери какой-либо информации)
и передаст управление отладчику Lisp. Оказавшись в отладчике, вы можете сделать 
такие вещи, как изучить стек вызовов (иногда называемый backtrace, поскольку 
кадры стека являются трассировкой текущей истории вызовов вашей программы, назад во
времени) и посмотреть на локальные переменные на любом уровне стека. И, конечно же, 
вы можете выполнить любой Лисп-код, который вам нравится. Но подождите, это еще не 
все! Вы можете выйти из отладчика, и ваша программа продолжит работу с того места, 
где ее прервал <code>BREAK</code>. Или вы можете изменить значения некоторых 
переменных, прежде чем продолжить. Если вы хотите, вы можете указать значение, 
которое будет возвращено прерванной функцией. Вы даже можете переопределить и перезапустить функции в любом месте стека вызовов.

<p>
Тот факт, что <code>BREAK</code>-это просто Lisp форма, имеет свои преимущества. 
Вы можете обернуть её в условное выражение произвольной сложности, чтобы ваша 
программа запускала <code>BREAK</code> именно тогда, когда это необходимо; это 
особенно полезно при отладке циклов или рекурсивных функций.

<p>
Если в коде имеется несколько операторов <code>BREAK</code>, то может 
оказаться полезным определить конкретный <code>BREAK</code>, вызывающий отладчик. 
Вы можете указать формат управляющей строки и аргументы, которые BREAK будет 
использовать для печати сообщения при входе в отладчик. Управляющая строка и 
аргументы те же, что и для <code>FORMAT</code>. (Примеры <code>FORMAT</code> мы 
видели в главах <a href="chapter04.html">4</a>, <a href="chapter05.html">5</a>,
и <a href="chapter06.html">6</a>. В <a href="chapter24.html">Главе 24</a>
 дается более полная трактовка <code>FORMAT</code>.)

<blockquote>
А обратная сторона? Большинство Лисп-IDE не дают вам интерфейс "укажи и кликни"
для установки <code>BREAK</code>. (Это ведь обратная сторона, верно?)
</blockquote> 

<p>
Lisp определяет <code>BREAK</code>, интерфейс для вашей программы, 
чтобы получить доступ к отладчику. После этого команды, которые вы будете 
использовать для навигации, полностью зависят от реализации. Если Вам повезет, 
вы получите интерфейс окна и меню, по крайней мере, для самых распространенных 
действий. Если вместо графического интерфейса отладчик предлагает вам просто 
сообщение и приглашение, вам, возможно, придется тщательно изучить 
руководство. Но прежде чем вы впадете в такую крайность, попробуйте заставить 
отладчик напечатать текст справки или меню: одна из команд <code>H</code>, 
<code>?</code>, <code>:H</code>, or <code>:HELP</code> может работать для 
вашей системы Lisp.

<h2><a name="trace-and-step">TRACE и STEP: Я слежу за тобой!</a> </h2>

<p>
Когда вам нужно точно знать, как работает функция в определенной точке 
вашего кода, <code>BREAK</code> и отладчик Lisp являются незаменимыми 
инструментами. Но они трудоемки и медленны (по крайней мере, относительно 
нормального выполнения программы) - ничего не происходит, кроме как при 
выполнении команд отладчиком.

<p>
Иногда достаточно знать, что определенная функция была вызвана 
и вернула значение. <code>TRACE</code> дает вам эту способность. 
Вы просто вызываете трассировку с одним или несколькими именами функций, 
и среда Lisp организует печать имени функции и ее аргументов при входе, 
а также имени функции и ее значений при выходе. Все это происходит без 
изменения исходного кода функции.

<pre>
? (defun factorial (n)
    (if (plusp n)
      (* n (factorial (1- n)))
      1))
FACTORIAL
? (factorial 6)
720
? (trace factorial)
NIL
? (factorial 6)
 Calling (FACTORIAL 6) 
  Calling (FACTORIAL 5) 
   Calling (FACTORIAL 4) 
    Calling (FACTORIAL 3) 
     Calling (FACTORIAL 2) 
      Calling (FACTORIAL 1) 
       Calling (FACTORIAL 0) 
       FACTORIAL returned 1
      FACTORIAL returned 1
     FACTORIAL returned 2
    FACTORIAL returned 6
   FACTORIAL returned 24
  FACTORIAL returned 120
 FACTORIAL returned 720
720
</pre> 

<blockquote> 
Некоторые системы Lisp могут печатать только первую и последнюю строки этой 
трассировки из-за оптимизации компилятора. Если вы хотите видеть рекурсивные 
вызовы, в этом может помочь выполнение 
<code>(DECLAIM (OPTIMIZE (DEBUG 3)))</code> перед определением любых отслеживаемых 
функций.
 </blockquote> 

<p>
Обратите внимание, как отступы используется для представления глубины 
стека вызовов. Это и другие детали представления <code>TRACE</code> 
зависят от реализации.


<p>
Когда вы больше не хотите отслеживать функцию, вычислите <code>UNTRACE</code>,
передавая имя функции (или имена). <code>UNTRACE</code> без каких-либо аргументов 
остановит трассировку всех текущих отслеживаемых функций.

<p>
Иногда, несмотря на все ваши усилия, вы просто не знаете, какие части 
функции выполняются. Если вы настолько сбиты с толку и предпочитаете 
идти вперед, а не пытаться упростить функцию, Lisp дает вам форму <code>STEP</code>.
<code>STEP</code> принимает полную форму Lisp в качестве аргумента; 
он вычисляет эту форму и возвращает то, что возвращает форма. Однако по пути 
он позволяет вам увидеть все вычисления, которые происходят - так сказать, 
шаг за шагом. Как и <code>BREAK</code>, <code>STEP</code> имеет только стандартный 
программный интерфейс; пользовательский интерфейс зависит от реализации.

<blockquote> 
Качество информации, доступной в рамках <code>STEP</code>, широко варьируется 
в зависимости от реализаций. Наиболее распространенным недостатком является то, 
что вы видите некоторую преобразованную версию исходного кода программы, а не 
исходный исходный код. Как правило, вы сможете обнаружить достаточное количество 
подсказок (имена переменных, функции и т. д.) так что вы можете держать свои ориентиры 
при выполнении пошагового кода по одной форме за раз.
</blockquote> 

<hr>

<p>Footnotes:

<p>[1] :grok: /grok/, var. /grohk/ /vt./  [из романа Роберта А. Хайнлайна 
   "Чужак в чужой стране", где это марсианское слово буквально означает 
   "пить" и метафорически "быть единым с"] эмфатическая форма - 
   "Грок во всей полноте". 
   1. Понимать, как правило, в глобальном смысле. Означает интимное и исчерпывающее знание. 
    Контраст {дзэн}, который подобен сверхъестественному пониманию, переживаемому как одна 
    короткая вспышка. 
   2. Использование программ, может означать просто достаточное понимание.

<hr>
<div align="center">
<a href="contents.html">Contents</a> | <a href="cover.html">Cover</a> <br> 
<a href="chapter15.html">Chapter 15</a> | Chapter 16 | <a href="chapter17.html">Chapter 17</a> 
</div>
<hr>
<address>
Copyright &copy; 1995-2001, David B. Lamkins<br>
All Rights Reserved Worldwide<br>
<br>
This book may not be reproduced without the written consent of its author.  Online distribution is restricted to the author's site.
</address> 
</body> </html>