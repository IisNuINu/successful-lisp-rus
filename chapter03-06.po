#
# NuINu <don't@send.my>, 2020.
#
#. extracted from in/chapter03-06.html
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-04-19 13:50+0300\n"
"PO-Revision-Date: 2020-04-23 10:24+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter03-06.html:5
msgid ""
"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/"
"html4/strict.dtd\">\n"
"<html><head>\n"
"<title>Successful Lisp - Chapter 3, Lesson 6</title> \n"
"</head> "
msgstr ""

#: in/chapter03-06.html:8
msgid ""
"<body bgcolor=\"white\" text=\"black\">\n"
"<h1>Chapter 3 - Essential Lisp in Twelve Lessons</h1> "
msgstr ""
"<body bgcolor=\"white\" text=\"black\">\n"
"<h1>Глава 3 - Основы Лисп в 12 уроках</h1> "

#: in/chapter03-06.html:10
msgid "<h2><A NAME=\"lesson-6\">Lesson 6 - Binding versus Assignment</A></h2> "
msgstr ""
"<h2><A NAME=\"lesson-6\">Урок 6 - Связывание против Присваивания</A></h2> "

#: in/chapter03-06.html:12
msgid "<h3>Binding creates a new place to hold a value</h3> "
msgstr "<h3>Привязка(Binding) создает новое место для хранения значения</h3> "

#: in/chapter03-06.html:20
msgid ""
"<P>Lisp often \"creates a binding\" for a variable by allocating a piece "
"of \n"
"storage to hold the variable's value and putting the value into the newly \n"
"allocated memory.  Binding is a very general mechanism for implementing \n"
"lexical scope for variables, but it has other uses depending upon the \n"
"lifetime of the binding.  We'll revisit this in \n"
"<A HREF=\"chapter08.html\">Chapter 8</A> when we study lifetime and \n"
"visibility.</P>"
msgstr ""
"<P>\n"
"Lisp часто \"создает привязку\" для переменной, выделяя часть памяти \n"
"для хранения значения переменной и помещая это значение во вновь \n"
"выделенную память. Привязка - это очень общий механизм реализации \n"
"лексической области для переменных, но он имеет и другие применения в\n"
"зависимости от времени жизни привязки. Мы еще вернемся к этому в \n"
"<A HREF=\"chapter08.html\">главе 8</A>, когда будем изучать время жизни и\n"
"видимость.\n"
"</P>"

#: in/chapter03-06.html:30
msgid ""
"<BLOCKQUOTE>\n"
"Yes, Lisp allocates storage for new bindings.  While this sounds like it "
"could\n"
"be horribly inefficient, we've said nothing yet about <EM>where</EM> Lisp \n"
"allocated the storage.  For example, Lisp binds function parameters to \n"
"actual values, but allocates the storage on the stack just like any other \n"
"programming language.  Lisp creates bindings in the heap if it can't \n"
"determine that the binding has a lifetime which ends when the binding form \n"
"finishes executing.\n"
"</BLOCKQUOTE>"
msgstr ""
"<BLOCKQUOTE>\n"
"Да, Lisp выделяет хранилище для новых Привязок. Хотя это звучит так, как \n"
"будто это может быть ужасно неэффективно, мы еще ничего не сказали о том, \n"
"<EM>где</EM> Lisp выделил хранилище. Например, Lisp привязывает параметры "
"функции к фактическим значениям, но выделяет хранилище в стеке точно так же, "
"как и любой другой язык программирования. Lisp создает привязки в куче, "
"если \n"
"он не может определить, что привязка имеет время жизни, которое "
"заканчивается,\n"
"когда форма привязки завершает выполнение.\n"
"</BLOCKQUOTE>"

#: in/chapter03-06.html:32
msgid "<h3>Bindings have names</h3> "
msgstr "<h3>Привязки имеют имена</h3> "

#: in/chapter03-06.html:35
msgid ""
"<P>Lisp gives each binding a name.  Otherwise, how would your program \n"
"refer to the binding?  Simple, eh?  Hold on...</P>"
msgstr ""
"<P>\n"
"Lisp дает каждой привязке имя. В противном случае, как бы ваша \n"
"программа обращалась к привязке? Все просто, да? \n"
"</P>"

#: in/chapter03-06.html:37
msgid "<h3>A binding can have different values at the same time</h3> "
msgstr "<h3>Привязка может иметь одновременно разные значения</h3> "

#: in/chapter03-06.html:40
msgid ""
"<P>It is quite common for multiple bindings to share the same name.  For \n"
"example:</P>"
msgstr ""
"<P>Довольно часто для нескольких Привязок используется одно и то же имя. "
"Например:</P>"

#: in/chapter03-06.html:45
msgid ""
"<PRE WIDTH=80>(let ((a 1))\n"
"   (let ((a 2))\n"
"      (let ((a 3))\n"
"         ...)))</PRE>"
msgstr ""

#: in/chapter03-06.html:48
msgid ""
"<P>Here, <CODE>A</CODE> has three distinct bindings by the time the body \n"
"(marked by <CODE>...</CODE>) executes in the innermost <CODE>LET</CODE>.</P>"
msgstr ""
"<P>\n"
"Здесь <CODE>A</CODE> получает три отчетливых привязки к тому времени, \n"
"когда тело (обозначено <CODE>...</CODE>) начнет исполнятся в самом "
"внутреннем\n"
"<CODE>LET</CODE>.\n"
"</P>"

#: in/chapter03-06.html:53
msgid ""
"<BLOCKQUOTE>\n"
"This is not to say that the above example is representative of typical "
"Lisp \n"
"code, however.\n"
"</BLOCKQUOTE>"
msgstr ""
"<BLOCKQUOTE>\n"
"Однако это не означает, что приведенный выше пример является "
"репрезентативным\n"
"для типичного кода Lisp.\n"
"</BLOCKQUOTE>"

#: in/chapter03-06.html:55
msgid "<h3>One binding is innermost</h3> "
msgstr "<h3>Одна привязка является самой внутренней</h3> "

#: in/chapter03-06.html:64
msgid ""
"<PRE WIDTH=80><I>;; Here, A has no binding.</I>\n"
"(let ((a 1))\n"
"   <I>;; Here, the innermost binding of A has the value 1.</I>\n"
"   (let ((a 2))\n"
"      <I>;; Here, the innermost binding of A has the value 2.</I>\n"
"      (let ((a 3))\n"
"         <I>;; Here, the innermost binding of A has the value 3.</I>\n"
"         ...)))</PRE>"
msgstr ""
"<PRE WIDTH=80><I>;; Здесь, не имеет никакой привязки.</I>\n"
"(let ((a 1))\n"
"   <I>;; Здесь, самая внутренняя привязка  A имеет значение 1.</I>\n"
"   (let ((a 2))\n"
"      <I>;; Здесь, самая внутренняя привязка  A имеет значение 2.</I>\n"
"      (let ((a 3))\n"
"         <I>;; Здесь, самая внутренняя привязка  A имеет значение 3.</I>\n"
"         ...)))</PRE>"

#: in/chapter03-06.html:70
msgid ""
"<P>As you can see, the notion of innermost binding depends on the relative \n"
"position of your program's code to the form that established a particular \n"
"binding.  If you look at how binding forms are nested (easy to do if you \n"
"indent your code as shown above) then the program has access to bindings \n"
"created around, or enclosing, your program code.</P>"
msgstr ""
"<P>\n"
"Как вы можете видеть, понятие внутренней привязки зависит от относительного\n"
"положения кода вашей программы к форме, которая установила ту или иную\n"
"привязку. Если вы посмотрите на то, как вложены формы привязки (это легко\n"
"сделать, если вы отформатируете свой код, как показано выше), то программа\n"
"имеет доступ к привязкам, созданным вокруг или заключающим ваш программный \n"
"код.\n"
"</P>"

#: in/chapter03-06.html:74
msgid ""
"<P>One more thing you should know is that an outer binding is still \n"
"visible through inner binding forms, as long as the inner binding form "
"does \n"
"not bind the same symbol:</P>"
msgstr ""
"<P>\n"
"Еще одна вещь, которую вы должны знать, заключается в том, что внешняя "
"привязка\n"
"будет видна через внутренние формы привязки, пока внутренняя форма "
"привязки \n"
"не свяжет тот же самый символ:\n"
"</P>"

#: in/chapter03-06.html:87
msgid ""
"<PRE WIDTH=80><I>;; Here, A and B have no binding.</I>\n"
"(let ((a 1)\n"
"      (b 9))\n"
"   <I>;; Here, the innermost binding of A has the value 1,\n"
"   ;; and the binding of B has the value 9.</I>\n"
"   (let ((a 2))\n"
"      <I>;; Here, the innermost binding of A has the value 2.\n"
"      ;; The binding of B still has the value 9.</I>\n"
"      (let ((a 3))\n"
"         <I>;; Here, the innermost binding of A has the value 3.\n"
"         ;; B still has the value 9 from the outermost LET form.</I>\n"
"         ...)))</PRE>"
msgstr ""
"<PRE WIDTH=80><I>;; Здесь A и B не имеют привязки.</I>\n"
"(let ((a 1)\n"
"      (b 9))\n"
"   <I>;; Здесь, внутрення привязка A имеет значение 1,\n"
"   ;; а привязка B имеет значение 9.</I>\n"
"   (let ((a 2))\n"
"      <I>;; Здесь, внутрення привязка A имеет значение 2.\n"
"      ;; Привязка B все еще имеет значение 9.</I>\n"
"      (let ((a 3))\n"
"         <I>;; Здесь, внутрення привязка A имеет значение 3.\n"
"         ;; B все еще имеет значение 9 из самой внешней формы LET.</I>\n"
"         ...)))</PRE>"

#: in/chapter03-06.html:89
msgid "<h3>The program can only access bindings it creates</h3> "
msgstr ""
"<h3>Программа может получить доступ только к привязкам, которые она создает</"
"h3> "

#: in/chapter03-06.html:95
msgid ""
"<P>When a binding form binds a new value to an existing symbol, the \n"
"previous value becomes shadowed.  The value of the outer binding is hidden \n"
"(but not forgotten) while your program code executes inside the inner \n"
"binding form.  But as soon as your program leaves the inner binding form, \n"
"the value of the outer binding is restored.  For example:</P>"
msgstr ""
"<P>Когда форма привязки связывает новое значение с существующим символом,\n"
"Предыдущее значение становится затененным. Значение внешней привязки\n"
"скрыто (но не забыто), в то время как ваш программный код выполняется \n"
"внутри формы внутренней привязки. Но как только ваша программа покидает "
"форму\n"
"внутренней привязки, значение внешней привязки восстанавливается. Например:</"
"P>"

#: in/chapter03-06.html:104
msgid ""
"<PRE WIDTH=80>(let ((z 1))\n"
"   <I>;; Here, the innermost binding of Z has the value 1.</I>\n"
"   (let ((z 2))\n"
"      <I>;; Here, the innermost binding of Z has the value 2.</I>\n"
"      ...)\n"
"   <I>;; Now we're outside the inner binding form,\n"
"   ;; and we again see the binding with the value 1.</I>\n"
"   ...)</PRE>"
msgstr ""
"<PRE WIDTH=80>(let ((z 1))\n"
"   <I>;; Здесь, внутренняя привязка Z имеет значение 1.</I>\n"
"   (let ((z 2))\n"
"      <I>;; Здесь, внутренняя привязка Z имеет значение 2.</I>\n"
"      ...)\n"
"   <I>;; Здесь, мы выходим из внутренней связывающей формы\n"
"   ;; и мы снова видм что z связана со значением 1.</I>\n"
"   ...)</PRE>"

#: in/chapter03-06.html:106
msgid "<h3>Assignment gives an old place a new value</h3> "
msgstr "<h3>Присвоение записывает на старое место новое значение</h3>"

#: in/chapter03-06.html:108
msgid ""
"<P>The <CODE>SETQ</CODE> form changes the value of an existing binding:</P>"
msgstr ""
"<P>\n"
"Форма <CODE>SETQ</CODE> изменяет значение существующей привязки:\n"
"</P>"

#: in/chapter03-06.html:119
msgid ""
"<PRE WIDTH=80>(let ((z 1))\n"
"   <I>;; Here, the innermost binding of Z has the value 1.</I>\n"
"   (setq z 9)\n"
"   <I>;; Now the value of Z is 9.</I>\n"
"   (let ((z 2))\n"
"      <I>;; Here, the innermost binding of Z has the value 2.</I>\n"
"      ...)\n"
"   <I>;; Now we're outside the inner binding form,\n"
"   ;; and we again see the outer binding of Z with the value 9.</I>\n"
"   ...)</PRE>"
msgstr ""
"<PRE WIDTH=80>(let ((z 1))\n"
"   <I>;; Здесь внутрення привязка Z имеет значение 1.</I>\n"
"   (setq z 9)\n"
"   <I>;; Сейчас значение Z равно 9.</I>\n"
"   (let ((z 2))\n"
"      <I>;; Здесь внутрення привязка Z имеет значение 2.</I>\n"
"      ...)\n"
"   <I>;; Здесь, мы выходим из внутренней связывающей формы\n"
"   ;; и мы снова видм что z связана со значением 9.</I>\n"
"   ...)</PRE>"

#: in/chapter03-06.html:129
msgid ""
"<P>The <CODE>SETQ</CODE> form above changed the value of the outer binding \n"
"of <CODE>Z</CODE> for the remainder of the outer <CODE>LET</CODE> form.  \n"
"This is often the wrong thing to do.  The problem is that you now have to \n"
"look in two places to discover the value of <CODE>Z</CODE> -- first at the \n"
"binding forms, then in the program code for assignments such as \n"
"<CODE>SETQ</CODE>.  While the binding forms are indented by convention \n"
"(many Lisp editors do this as you type), the assignment form, as part of \n"
"the body code of the program, gets no special indentation; this makes it \n"
"harder to spot when you read the program.</P>"
msgstr ""
"<P>\n"
"Приведенная выше форма <CODE>SETQ</CODE> изменила значение внешней привязки\n"
"<CODE>Z</CODE> для оставшейся части внешней формы <CODE>LET</CODE>. "
"Зачастую\n"
"так делать неправильно. Проблема заключается в том, что теперь вам придется\n"
"искать значение <CODE>Z</CODE> в двух местах - сначала в формах привязки, \n"
"а затем в программном коде для таких присваиваний, как <CODE>SETQ</CODE>. \n"
"В то время как формы привязки имеют отступы по соглашению (многие редакторы\n"
"Lisp делают это при вводе текста), форма присваивания, как часть основного \n"
"кода программы, не получает специального отступа; это затрудняет поиск при\n"
"чтении программы.\n"
"</P>"

#: in/chapter03-06.html:132
msgid ""
"<P>We can quite easily avoid the assignment in the previous example by \n"
"introducing a new binding:</P>"
msgstr ""
"<P>\n"
"Мы можем довольно легко избежать присваивания в предыдущем примере, \n"
"введя новую привязку:\n"
"</P>"

#: in/chapter03-06.html:145
msgid ""
"<PRE WIDTH=80>(let ((z 1))\n"
"   <I>;; Here, the innermost binding of Z has the value 1.</I>\n"
"   (let ((z 9))\n"
"      <I>;; Now the value of Z is 9.</I>\n"
"      (let ((z 2))\n"
"         <I>;; Here, the innermost binding of Z has the value 2.</I>\n"
"         ...)\n"
"      <I>;; Now we're outside the innermost binding form,\n"
"      ;; and we again see the middle binding of Z with the value 9.</I>\n"
"      ...)\n"
"   <I>;; Here, we see the outermost binding of Z with the value 1.</I>\n"
"   ...)</PRE>"
msgstr ""
"<PRE WIDTH=80>(let ((z 1))\n"
"   <I>;; Здесь, внутренняя привязка has имеет значение 1.</I>\n"
"   (let ((z 9))\n"
"      <I>;; Здесь значение Z равно 9.</I>\n"
"      (let ((z 2))\n"
"         <I>;; Здесь, внутренняя привязка has имеет значение 2.</I>\n"
"         ...)\n"
"      <I>;; Здесь, мы выходим из внутренней связывающей формы\n"
"         ;; и мы снова видм что z связана со значением 9.</I>\n"
"      ...)\n"
"   <I>;; Здесь мы видим самую внешнюю привязку Z со значением 1.</I>\n"
"   ...)</PRE>"

#: in/chapter03-06.html:152
msgid ""
"<P>Now all of the bindings of <CODE>Z</CODE> are apparent from the \n"
"relative indentation of the <CODE>LET</CODE> forms.  While reading the \n"
"program, all we have to do to find the right binding for <CODE>Z</CODE> at \n"
"any point in our program code (the <CODE>...</CODE> in the example) is to "
"scan \n"
"vertically looking for a <CODE>LET</CODE> form at an outer level of \n"
"indentation.</P>"
msgstr ""
"<P>\n"
"Теперь все привязки <CODE>Z</CODE> очевидны из относительного отступа форм\n"
"<CODE>LET</CODE>. Во время чтения программы все, что нам нужно сделать, \n"
"чтобы найти правильную привязку для <CODE>Z</CODE> в любой точке нашего\n"
"программного кода (<CODE>...</CODE> в Примере) состоит в том, чтобы \n"
"просматривать код сверху вниз, ища форму <CODE>LET</CODE> на внешнем \n"
"уровне отступа.\n"
"</P>"

#: in/chapter03-06.html:158
msgid ""
"<P>When a <CODE>SETQ</CODE> form refers to a variable that is not bound by \n"
"an enclosing <CODE>LET</CODE> form, it assigns a value to the global or \n"
"special value of the symbol.  A global value is accessible anywhere it's \n"
"not shadowed, and stays available for as long as the Lisp system runs.  \n"
"We'll look at special variables in <A HREF=\"chapter08.html\">Chapter 8</A>."
msgstr ""
"<P>\n"
"Когда форма <CODE>SETQ</CODE> ссылается на переменную, которая не связана "
"заключающей формой <CODE>LET</CODE>, она присваивает значение глобальному \n"
"или специальному значению символа. Глобальное значение доступно везде, \n"
"где оно не затенено, и остается доступным до тех пор, пока работает система "
"Lisp. Мы рассмотрим специальные переменные в \n"
"<A HREF=\"chapter08.html\">Глава 8</A>.\n"
"."

#: in/chapter03-06.html:166
msgid ""
"<PRE WIDTH=80>(setq a 987)\n"
"<I>;; Here, A has the global value 987.</I>\n"
"(let ((a 1))\n"
"   <I>;; Here, the binding of A to the value 1 shadows the global value.</"
"I>\n"
"   ...)\n"
"<I>;; Now the global value of A is again visible.</I>\n"
"...</PRE>"
msgstr ""
"<PRE WIDTH=80>(setq a 987)\n"
"<I>;; Здесь A имеет глобальное значение 987.</I>\n"
"(let ((a 1))\n"
"   <I>;; Здесь, привязка A к значению 1 затеняет глобальное значение.</I>\n"
"   ...)\n"
"<I>;; Здесь глобальное значение  A снова видно.</I>\n"
"...</PRE>"

#: in/chapter03-06.html:180
msgid ""
"<hr>\n"
"<div align=\"center\">\n"
"<a href=\"contents.html\">Contents</a> | <a href=\"cover.html\">Cover</a> "
"<br> \n"
"<a href=\"chapter02.html\">Chapter 2</a> | <A HREF=\"chapter03.html"
"\">Chapter 3, Introduction</A> | <A HREF=\"chapter03-05.html\">Chapter 3, "
"Lesson 5</A> | Chapter 3, Lesson 6 | <A HREF=\"chapter03-07.html\">Chapter "
"3, Lesson 7</A> | <a href=\"chapter04.html\">Chapter 4</a> | \n"
"</div>\n"
"<hr>\n"
"<address>\n"
"Copyright &copy; 1995-2001, David B. Lamkins<br>\n"
"All Rights Reserved Worldwide<br>\n"
"<br>\n"
"This book may not be reproduced without the written consent of its \n"
"author.  Online distribution is restricted to the author's site.\n"
"</address> \n"
"</body> </html> "
msgstr ""
