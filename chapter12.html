<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Successful Lisp - Chapter 12</title>
</head> 

<body bgcolor="white" text="black">
<h1>Глава 12 - Отображение(Mapping) вместо Итерации</h1> 

<p>В этой главе мы рассмотрим группу функций, которые в совокупности 
называются функциями отображения. Вы можете представить себе функцию 
отображения как своего рода итератор специального назначения. Каждая 
функция отображения ожидает, что вы предоставите ей функцию. Типичная 
функция отображения применяет вашу функцию к каждому элементу 
предоставленного ей списка(списков). Один из вариантов этой темы 
применяет вашу функцию к последовательности подсписков.

<p>Последовательность-это обобщение типа данных списка. 
Векторы (одномерные массивы) и списки являются специализациями типа 
данных последовательности(sequence). Некоторые функции отображения 
работают только со списками в качестве входных данных, в то время 
как другие принимают последовательности

<h2>MAPCAR, MAPC, и MAPCAN обрабатывают последовательные элементы списка</h2>

<p>Первая группа функций отображения обрабатывает последовательные 
элементы списков. Функции отображения в этой группе отличаются тем, 
как они строят возвращаемое значение.

<p><code>MAPCAR</code> обрабатывает последовательные элементы 
одного или нескольких предоставленных списков. Вы должны предоставить 
функцию, которая принимает столько же аргументов, равное количеству списков, 
которые вы предоставляете <code>MAPCAR</code>, который применяет вашу 
функцию к последовательным элементам и объединяет результаты функции в 
только что созданный список. Отображение останавливается по достижении 
конца самого короткого списка; результат <code>MAPCAR</code> имеет столько 
же элементов, сколько и самый короткий входной список.

<p><code>MAPC</code> не объединяет результаты применения вашей функции 
к последовательным элементам входного списка(ов). Вместо этого он 
обрабатывает входные данные только ради эффекта и возвращает первый 
список входных данных в качестве результата <code>MAPC</code>.

<p>
<code>MAPCAN</code> объединяет результаты, используя разрушающую 
функцию <code>NCONC</code>. Поскольку <code>NCONC</code> - как и его
неразрушающий аналог <code>APPEND</code>-ожидает, что его аргументы будут
списками, функция, которую вы предоставляете <code>MAPCAN</code>, всегда 
должна возвращать список.

<pre>
? (mapcar #'atom (list 1 '(2) "foo" nil))
(T NIL T T)
? (mapcar #'+ (list 1 2 3) (list 4 5 6))
(5 7 9)
? (mapc #'(lambda (x y) (print (* x y))) (list 1 0 2) (list 3 4 5))

3
0
10
(1 0 2)
? (mapcan #'list (list 1 2 3) (list 4 5 6))
(1 4 2 5 3 6)
? (mapcan #'(lambda (a b) (list (cons a b))) (list 1 2 3) (list 4 5 6))
((1 . 4) (2 . 5) (3 . 6))
</pre> 

<h2>MAPLIST, MAPL, и MAPCON обрабатывают последовательные подсписки</h2>

<p><code>MAPLIST</code> обрабатывает последовательные подсписки одного 
или нескольких предоставленных списков. Вы должны предоставить функцию, 
которая принимает столько же аргументов, сколько количество списков, 
которые вы предоставляете <code>MAPLIST</code>, который применяет вашу
функцию к последовательным подспискам и объединяет результаты функции в 
только что созданный список. Отображение останавливается по достижении 
конца самого короткого списка; результат <code>MAPLIST</code> имеет столько 
же элементов, сколько и самый короткий входной список.

<p><code>MAPL</code> не объединяет результаты применения вашей 
функции к последовательным подспискам входного списка(ов). Вместо 
этого он обрабатывает входные данные только ради сторонних эффектов 
и возвращает первый список входных данных в результате <code>MAPL</code>.

<p><code>MAPCON</code>  объединяет результаты, используя 
разрушающую функцию <code>NCONC</code>. Поскольку <code>NCONC</code>
- как и его неразрушающий аналог <code>APPEND</code> - ожидает, что е
го аргументы будут списками, функция, которую вы предоставляете 
<code>MAPCON</code>, всегда должна возвращать список.

<pre>
? (maplist #'list (list 1 2 3) (list 4 5 6))
(((1 2 3) (4 5 6)) ((2 3) (5 6)) ((3) (6)))
? (mapl #'(lambda (x y) (print (append x y))) (list 1 0 2) (list 3 4 5))

(1 0 2 3 4 5) 
(0 2 4 5) 
(2 5) 
(1 0 2)
? (mapcon #'list (list 1 2 3) (list 4 5 6))
((1 2 3) (4 5 6) (2 3) (5 6) (3) (6))
</pre> 

<h2>MAP и MAP-INTO работают с последовательностями,
а не только со списками</h2>

<p>
Последовательность - это либо список, либо вектор (одномерный массив). 
Предыдущая группа  функций отображения (MAPCAR и иже с ним) обрабатывали последовательные CAR или CDRs их входных списков. <code>MAP</code> 
и  <code>MAP-INTO</code> обрабатывают последовательные элементы входной
последовательности.


<p><code>MAP</code> требует, чтобы вы указали тип ее результата, 
используя одно из следующих обозначений:

<pre>
Designator   Result
----------   ------
NIL          NIL
'LIST        a list
'VECTOR      a vector
</pre> 

<p>
Обратите внимание, что вы также можете указать подтипы <code>LIST</code>
или <code>VECTOR</code> - ваша реализация Lisp может оптимизировать 
хранение результата на основе указанного типа.

<pre>
? (map nil #'+ (list 1 2 3) (list 4 5 6))
NIL
? (map 'list #'+ (list 1 2 3) (list 4 5 6))
(5 7 9)
? (map 'vector #'+ (list 1 2 3) (list 4 5 6))
#(5 7 9)
? (map '(vector number 3) #'+ (list 1 2 3) (list 4 5 6))
#(5 7 9)
</pre> 

<p><code>MAP-INTO</code> - это разрушающая версия <code>MAP</code>.
Первый аргумент - это последовательность, которая получает результаты сопоставления. Отображение останавливается по достижении конца 
результирующей последовательности или любой из входных последовательностей.
(Поэтому, если в качестве результирующей последовательности указать 
<code>NIL</code>, сопоставление не выполняется, так как <code>NIL</code> -
это список нулевой длины.) Входные последовательности не изменяются. 
Измененная последовательность результатов возвращается в виде значения 
<code>MAP-INTO</code>.

<pre>
? (let ((a (make-sequence 'list 3)))
    (print a)
    (map-into a #'+ (list 1 2 3) (list 4 5 6))
    a)

(NIL NIL NIL)
(5 7 9)
? (let ((a (make-sequence 'vector 3)))
    (print a)
    (map-into a #'+ (list 1 2 3) (list 4 5 6))
    a)

#(0 0 0)
#(5 7 9)
</pre> 

<p>
Ваша реализация Lisp может печатать различные начальные значения для
немодифицированных последовательностей в приведенных выше примерах. 
Если вам необходимо задать некоторое начальное значение для 
<code>MAKE-SEQUENCE</code>, используйте ключевое слово
<code>:INITIAL-ELEMENT</code>

<pre>
? (let ((a (make-sequence 'list 3 :initial-element 0)))
    (print a)
    (map-into a #'+ (list 1 2 3) (list 4 5 6))
    a)

(0 0 0)
(5 7 9)
</pre> 

<h2>Функции отображения хороши для фильтрации</h2>

<p>
Фильтр пропускает некоторые из своих входных вещей через свой выход,
и отбрасывает другие. Мы можем использовать функции отображения для 
реализации фильтров, принимая во внимание поведение <code>APPEND</code>:

<pre>
? (append '(1) nil '(3) '(4))
(1 3 4)
</pre> 

<p>
Аргумент <code>NIL</code> (который эквивалентен пустому списку) просто 
"исчезает" из результата. Это ключевое наблюдение, которое нам необходимо 
для построения фильтра. Мы будем использовать <code>MAPCAN</code> для 
отображения нашего входного списка(ов) и предоставления функции отображения, которая:

<ul>
<li>делает список каждого результата, который мы хотим сохранить в выходных данных, или
<li>возвращает NIL вместо каждого входа, который мы хотим исключить из выходных данных.
</ul> 

<pre>
? (defun filter-even-numbers (numbers)
    (mapcan #'(lambda (n) (when (evenp n) (list n))) numbers))
FILTER-EVEN-NUMBERS
? (filter-even-numbers (list 1 2 3 4 5 6 7 8))
(2 4 6 8)
</pre> 

<blockquote> 
<code>WHEN</code> возвращает NIL, если условие равно <code>NIL</code>.
Вместо этого мы могли бы написать 
 <code>(if (evenp n) (list n) nil)</code> . </blockquote> 

<p>
Вот немного более сложный фильтр, который возвращает список нацело 
делимых пар числителей и знаменателей:

<pre>
? (defun filter-evenly-divisible (numerators denominators)
    (mapcan #'(lambda (n d)
                (if (zerop (mod n d))
                  (list (list n d))
                  nil))
            numerators denominators))
? (filter-evenly-divisible (list 7 8 9 10 11 12)
                           (list 1 4 5  5  2  3))
((7 1) (8 4) (10 5) (12 3))
</pre> 

<p>
Функции <code>REMOVE-IF</code> и <code>REMOVE-IF-NOT</code>
(а также их разрушающие аналоги, <code>DELETE-IF</code> и 
<code>DELETE-IF-NOT</code>) фильтруют одну последовательность, но 
не могут использоваться для нескольких последовательностей 
(как в приведенном выше примере). Используйте <code>REMOVE-IF</code> 
и тому подобное, если это сделает ваш код более понятным. 
Дополнительную информацию см. В <a href="chapter13.html">Главу 13</a>.

<h2>Лучше избегать отображения, если вы заботитесь об эффективности</h2>

<p>
Большинство систем Lisp генерируют более эффективный код для вызова функции,
которая известна во время компиляции, чем функция, которая может изменяться 
во время выполнения. Функции отображения принимают функциональный аргумент, 
и большинство компиляторов генерируют код, поддерживающий привязку функций
времени выполнения - даже если вы задаете "постоянную" функцию, такую как
<code>#'+</code>. Кроме того, вызов времени выполнения может потребовать
дополнительных накладных расходов для создания списка аргументов для 
применения функции.

<p>
Поэтому, если вы беспокоитесь об эффективности, вам следует писать
функции подобные отображению, используя итерацию вместо  функций
отображения. Но делайте это только тогда, когда вы уверены, что 
эффективность является проблемой для той части программы, которую 
вы собираетесь переписать. См. <a href="chapter28.html">Главу 28</a> 
для обсуждения профилирования, которое может помочь вам найти 
узкие места производительности вашей программы.

<h2>Проверка последовательностей с помощью функций отображения предикатов</h2>

<p>
Иногда вам может потребоваться применить тест к некоторым входным
последовательностям и вернуть истинное значение, основанное на том, 
что тест вернул для всех входных данных. Например, вы можете узнать, 
находится ли какое-либо число в последовательности вне указанного диапазона 
или что каждое слово имеет длину не менее пяти букв. Вы можете построить 
эти тесты из функций отображения, описанных выше, но это будет более 
многословный код (и менее эффективный), чем использование функций отображения 
предикатов, предоставляемых Lisp.

<h2>SOME, EVERY, NOTANY, NOTEVERY</h2>

<p>
Встроенные функции отображения предикатов ожидают, что вы предоставите 
тестовую функцию (она же предикат) и одну или несколько входных
последовательностей. Предикат применяется к последовательным элементам 
входных последовательностей до тех пор, пока не будет определен результат 
функции отображения.

<pre>
Function   Condition
--------   ---------
SOME       user-supplied predicate succeeds on at least one input
EVERY      user-supplied predicate succeeds on every input
NOTANY     complement of SOME
NOTEVERY   complement of EVERY
</pre> 

<p>Например, <code>SOME</code>(некоторые) проверяет входные данные до тех пор, 
пока предикат ложен; тесты останавливаются - и <code>SOME</code> возвращает
истинное значение - как только предикат станет истинен для некоторых входных
данных. Если предикат имеет значение false для всех входных данных, то 
<code>SOME</code> из них возвращает ложное значение.

<p>
Аналогично, <code>EVERY</code>(каждый) проверяет входные данные до тех пор, 
пока предикат истинен; тесты останавливаются - и <code>EVERY</code> 
возвращает ложное значение - как только предикат станет ложен для некоторых
входных данных. Если предикат истинен для каждого входного сигнала, то 
<code>EVERY</code> возвращает истинное значение.

<pre>
? (some #'(lambda (n) (or (&lt; n 0) (&gt; n 100))) (list 0 1 99 100))
NIL
? (some #'(lambda (n) (or (&lt; n 0) (&gt; n 100))) (list -1 0 1 99 100))
T
? (every #'(lambda (w) (&gt;= (length w) 5)) (list "bears" "bulls" "racoon"))
T
? (every #'(lambda (w) (&gt;= (length w) 5)) (list "bears" "cat" "racoon"))
NIL
</pre> 

<p>
И конечно, функции отображения предикатов обрабатывают несколько
последовательностей, как и следовало ожидать.

<pre>
? (some #'&gt; (list 0 1 2 3 4 5) (list 0 0 3 2 6))
T
</pre> 

<h2>REDUCE объединяет элементы последовательности</h2>

<p>Раз уж мы заговорили о отображениях, разве не было бы здорово иметь
возможность объединить все элементы последовательности с помощью какой-то
функции? <code>REDUCE</code> делает именно это, принимая функцию (с двумя 
или нулевыми аргументами) и последовательность. Если последовательность длиннее
одного элемента, то <code>REDUCE</code> объединяет результаты применения функции
к последовательным элементам последовательности. Например:

<pre>
? (reduce #'* (list 1 2 3 4 5)) <i>(* (* (* (* 1 2) 3) 4) 5)</i> 
120
? (reduce #'- (list 10 2 3 1)) <i>; (- (- (- 10 2) 3) 1)</i> 
4
</pre> 

<p>
Если последовательность имеет длину один, <code>REDUCE</code>
возвращает последовательность, и функция не применяется. Если 
последовательность имеет нулевую длину, <code>REDUCE</code> применяет 
функцию без аргументов и возвращает значение, возвращаемое функцией. 
(В случае арифметических функций это значение тождества для операции.)


<p>
Различные аргументы ключевые слова позволяют указать подпоследовательность 
для <code>REDUCE</code>, или что <code>REDUCE</code> должен объединять 
элементы в правой ассоциативной манере (т. е. с конца последовательности, 
а не с начала).

<hr>
<div align="center">
<a href="contents.html">Contents</a> | <a href="cover.html">Cover</a> <br> 
<a href="chapter11.html">Chapter 11</a> | Chapter 12 | <a href="chapter13.html">Chapter 13</a> 
</div>
<hr>
<address>
Copyright &copy; 1995-2001, David B. Lamkins<br>
All Rights Reserved Worldwide<br>
<br>
This book may not be reproduced without the written consent of its author.  Online distribution is restricted to the author's site.
</address> 
</body> </html>