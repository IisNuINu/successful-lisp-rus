<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<title>Successful Lisp - Chapter 7</title> 
</head> 

<body bgcolor="white" text="black">
<h1>Глава 7 - Первый взгляд на объекты как на причудливые структуры.</h1> 

<p>Мы впервые столкнулись со структурами в 
<a href="chapter03-10.html#structures"> Главе 3</a>, а затем узнали об их
некотором необязательных поведении в 
<a href="chapter06.html">Главе 6</a>. В этой главе мы начнем изучать объекты 
в системе Common Lisp Object System (CLOS). А пока мы рассмотрим только способы
использования объектов для структурирования данных. Позже, в 
<a href="chapter14.html">Главе 14</a>, мы узнаем больше о CLOS.

<h2>Иерархии: классификация и содержание</h2>

<p>
Когда вы программируете с объектами, вы будете пытаться каким-то образом
создать модель некоторой части реального мира. Когда вы сделаете это, вы,
вероятно, заметите, что некоторые объекты состоят из более мелких частей.
Каждая часть имеет свою собственную идентичность; часть идентифицируется 
сама по себе, отдельно от любого объекта, частью которого она может быть. 
Кроме того, часть может быть сделана из более мелких деталей. Если вы 
нарисуете картину отношений компонентов между всеми частями какого-либо
сложного объекта, вы обнаружите, что они образуют иерархию. Полностью 
собранный объект будет находиться на вершине иерархии (первый уровень), 
все его части будут находиться на втором уровне, все части, составляющие 
части второго уровня, будут находиться на третьем уровне и так далее. Эта
иерархия является иерархией содержания; каждый уровень представляет объект, 
а следующий самый низкий уровень представляет объекты, которые являются 
частями объекта на более высоком уровне. Объект на более высоком уровне 
содержит (или имеет в качестве частей) некоторые объекты на более низком уровне
иерархии, а объект на более низком уровне содержится (или является частью)
некоторого объекта на более высоком уровне.

<p>Иерархии содержания важны, поскольку они моделируют отношения "имеет"
 и "является-частью" между объектами. Эти отношения упрощают модель реального
мира вашей программы, позволяя вам мыслить в терминах относительно небольших
составных частей, а не моделировать один очень сложный объект. Моделирование с
помощью содержания также окупается, когда вы можете смоделировать аналогичный
объект в терминах  комбинации других компонентов.

<blockquote> Объект может обладать определенными характеристиками, 
которые не могут быть отделены от объекта. Например, объект может 
иметь цвет, размер, массу, скорость и температуру. Эти характеристики
 не являются составными частями объекта; они не могут быть отделены
от объекта и не могут быть объединены для создания новых объектов. 
Эти характеристики являются (<em>attributes</em>)атрибутами объекта.
</blockquote> 

<p>Другой тип иерархии, с которым вы будете работать как программист
объектов - это иерархия классификации. В <em>классификационной иерархии</em> 
объекты связаны отношениями типа "is-a-kind-of" (или, более кратко,"is-a"
или"a-k-o"). Эти отношения также имеют различные названия в зависимости от 
нашей точки зрения: если А является разновидностью B, то А является
специализацией B, а B - обобщением А.

<blockquote> 
С ростом интереса к объектному программированию, многие специализированные
лексиконы выросли для поддержки конкретных методов и языков. 
После исключения терминов, описывающих особенности конкретной методологии
или языковой реализации, обычно остается переименование локальных иерархий
и классификации (и отношений, поддерживаемых каждой из них) и некоторый 
способ указания атрибутов объекта. На самом деле, наиболее распространенным
переименованием ссылаться на классификационную иерархию как на
иерархию "класса".
</blockquote> 

<h2>Используйте DEFCLASS для определения новых объектов</h2>

<p>Объект CLOS определяется формой <code>DEFCLASS</code>. 
<code>DEFCLASS</code> описывает только объект. Для создания 
экземпляра объекта можно использовать форму <code>MAKE-INSTANCE</code>.


<p>Вот как бы вы определили тривиальный объект:

<pre>
? (defclass empty-object () ())
#&lt;STANDARD-CLASS EMPTY-OBJECT&gt;
</pre> 

<p>Этот класс не очень интересен; <code>()</code> - это заполнители для 
будущих вещей. Кроме того, обратите внимание, что эта конкретная система 
Lisp печатает <code>#&lt;STANDARD-CLASS EMPTY-OBJECT&gt;</code> в ответ 
на форму <code>DEFCLASS</code>. Это нечитабельно - Reader(читатель)
сигнализирует об ошибке всякий раз, когда он читает форму, начинающуюся с
<code>#&lt;</code>, но это дает вам знать, что произошло что-то полезное.

<p>
Как только вы определили класс, вы можете использовать его для создания объектов.
Большинство форм, которым требуется класс, принимают имя класса, или вы можете
использовать <code>FIND-CLASS</code> для получения фактического класса, 
учитывая его имя. <code>MAKE-INSTANCE</code> создает новый объект, заданный именем класса или классом:

<pre>
? (make-instance 'empty-object)
#&lt;EMPTY-OBJECT #x3CA1206&gt;
? (make-instance 'empty-object)
#&lt;EMPTY-OBJECT #x3CA1DFE&gt;
? (find-class 'empty-object)
#&lt;STANDARD-CLASS EMPTY-OBJECT&gt;
? (make-instance (find-class 'empty-object))
#&lt;EMPTY-OBJECT #x3CB397E&gt;
</pre> 

<p>Опять же, система Lisp отвечает нечитаемым объектом. На этот раз ответ
включает в себя адрес хранения объекта. Большинство систем Lisp имеют 
принтер(функцию вывода) по умолчанию для объектов CLOS, который работает 
также, хотя детали могут немного отличаться. Важно отметить, что 
<code>MAKE-INSTANCE</code> создает новый объект каждый раз, когда 
она вызывается.


<blockquote> Даже если принтер объектов показывает разные адреса для 
каждого объекта, вы не должны зависеть от печатного представления для
идентификации объекта. Системы Lisp могут (и делают) изменять адрес 
объектов во время выполнения. Единственный способ достоверно сравнить
идентичность объекта - это использовать проверку идентичности, например 
<code>EQ</code> (см. <a href="chapter17.html">Главу 17</a>). 
</blockquote> 

<h2>Объекты имеют слоты, с большим количеством опций чем у
структур</h2>

<p>
Наша первая форма <code>DEFCLASS</code> определила объект, который 
не был хорош ни для чего. Теперь мы увидим, как расширить определение 
класса, чтобы наши объекты имели именованные слоты. Они служат той 
же цели, что и слоты в структурах 
(<a href="chapter03-10.html#structures">Глава 3</a>), они просто хранят данные.
Эти данные могут быть атрибутами объекта, содержащимися в нем объектами или
ссылками на связанные объекты.


<p>Чтобы определить класс для объекта со слотами, мы начинаем с 
формы <code>DEFCLASS</code> и добавляем определения слотов, 
например:

<pre>
? (defclass 3d-point () (x y x))
#&lt;STANDARD-CLASS 3D-POINT&gt;
</pre> 

<p>
Здесь мы определили класс <code>3D-POINT</code>, объекты которого 
будут иметь три слота с именами <code>X</code>, <code>Y</code>, и 
<code>Z</code>. Это может быть похоже на определение структуры, 
например

<pre>
(defstruct 3d-point-struct x y z)
</pre> 

<p>но на самом деле класс обладает <b>меньшей</b> функциональностью, 
чем структура. Класс не определяет методы доступа по умолчанию 
для слотов. Чтобы получить доступ к слотам, вам нужно будет 
использовать <code>SLOT-VALUE</code>, как в этом примере:

<pre>
? (let ((a-point (make-instance '3d-point)))
    (setf (slot-value a-point 'x) 0)  <i>; set the X slot</i> 
    (slot-value a-point 'x))          <i>; get the X slot</i> 
0
</pre> 

<p>Если вы попытаетесь получить значение слота до его установки, 
Lisp будет сигнализировать об ошибке, потому что слот не привязан 
(т. е. у него <em>нет</em> значения).

<pre>
? (let ((a-point (make-instance '3d-point)))
    (slot-value a-point 'y))
&gt; Error: Slot Y is unbound in #&lt;3D-POINT #x3CD3216&gt;
</pre> 

<h2>Контроль доступа к слоту помогает сохранить честность клиентов</h2>

<p>
Получение и установка слотов с формами <code>SLOT-VALUE</code> немного 
громоздко по сравнению с аксессорами, созданными автоматически для слотов в
структуре. К счастью, вы можете указать методы доступа(аксессоры) для каждого
слота при определении класса.

<pre>
(defclass 3d-point ()
  ((x :accessor point-x)
   (y :accessor point-y)
   (z :accessor point-z)))
</pre> 

<p>Тогда доступ к слоту объекта выглядит так же, как и доступ 
к слоту структуры.

<pre>
? (let ((a-point (make-instance '3d-point)))
    (setf (point-x a-point) 0)
    (point-x a-point))
0
</pre> 

<p>Вы также можете указать отдельные имена доступа для чтения 
и записи слота.

<pre>
? (defclass 3d-point ()
    ((x :reader get-x :writer set-x)
     (y :reader get-y :writer set-y)
     (z :reader get-z :writer set-z)))
#&lt;STANDARD-CLASS 3D-POINT&gt;
? (let ((a-point (make-instance '3d-point)))
    (set-z 3 a-point)
    (get-z a-point))
3
</pre> 

<p>Видите ли вы разницу между указанием: <code>:accessor</code> и
<code>:writer</code>? Обратите внимание, что слот writer(записи)
<em>не</em> используется с <code>SETF</code>. Также обратите внимание 
на порядок аргументов для слота (writer)записи слота: сначала значение, 
затем объект.

<p>
Когда вы пишете сложную программу, полезно иметь все эти опции для доступа
к слоту. С помощью различных комбинаций определений доступа к слоту вы 
можете предоставить доступ к слоту для чтения/записи, только для чтения,
только для записи или вообще без доступа. Вы можете подумать, что последние 
два случая будут бесполезны, но это не так. Слот только для записи может
предоставлять информацию, которая полезна только для установления состояния
внутри объекта в ответ на запрос клиента объекта - например, семя(seed) для
генератора случайных чисел. Слот без доступа может содержать информацию,
которая должна быть известна только по внутренней работе объекта; функции,
которые управляют внутренним состоянием объекта, все еще могут получить
доступ к слоту с помощью <code>SLOT-VALUE</code>.

<p>
Существование <code>SLOT-VALUE</code> является анафемой для некоторых
проектировщиков объектов, которые считают, что конфиденциальность 
внутренней информации объекта должна быть <em>абсолютно</em> защищена от
клиентского доступа. Lisp требует применения дисциплины программиста 
для защиты внутренней информации объекта. Как правило, вы должны использовать
<code>SLOT-VALUE</code> для управления частными слотами и предоставлять
соответствующие именованные средства доступа для всех других слотов. 
Сделав это, любое появление формы с <code>SLOT-VALUE</code> в клиентской
программе сигнализирует о нарушении вашего намерения скрыть внутреннее
состояние какого-либо объекта.

<h2>Переопределение метода доступа к слоту, чтобы сделать то, что клиент
не может</h2>

<p>В этом разделе мы рассмотрим, как определить специальные средства доступа,
которые делают больше, чем просто чтение и запись значений слотов. Думайте об
этом как о тайном просмотре <a href="chapter14.html">Главы 14</a>.

<p>Давайте определим сферу. Сфера определяется своим положением в 
3-м пространстве и своим радиусом. Мы хотели бы запрашивать сферу о 
ее объеме. Наконец, мы хотели бы иметь возможность перемещать-или 
переводить-положение сферы на определенную величину без необходимости 
явно вычислять ее новые координаты. Мы начнем с этого определения 
класса:

<pre>
? (defclass sphere ()
    ((x :accessor x)
     (y :accessor y)
     (z :accessor z)
     (radius :accessor radius)
     (volume :reader volume)
     (translate :writer translate)))
#&lt;STANDARD-CLASS SPHERE&gt;
</pre> 

<p>
Методы доступа для <code>X</code>, <code>Y</code>, <code>Z</code>,
и <code>RADIUS</code> не нуждаются в дальнейшем объяснении, но методы 
доступа для <code>VOLUME</code> и <code>TRANSLATE</code> еще бесполезны;
метод чтения <code>VOLUME</code> потерпит неудачу, потому что его слот не связан,
и метод записи <code>TRANSLATE</code> не будет делать ничего, кроме  
установки своего слота.


<p>
Мы закончим определение нашей сферы, сначала заставив <code>VOLUME</code>
возвращать значение, вычисленное по радиусу сферы. Есть два способа сделать 
это: заставить <code>VOLUME</code> прочитать радиус сферы и вычислить
соответствующий объем или заставить <code>RADIUS</code> вычислить объем 
и установить слот объема для последующего использования средством доступа 
к <code>VOLUME</code>. Вот оба решения - если вы попробуете его сделать, 
выберите только одно:

<pre>
<i>; Volume from Radius</i> 
(defmethod volume ((object sphere))
  (* 4/3 pi (expt (radius object) 3)))

<i>; Radius to Volume</i> 
(defmethod radius ((new-radius number) (object sphere))
  (setf (slot-value object 'radius) new-radius)
  (setf (slot-value object 'volume)
        (* 4/3 pi (expt new-radius 3))))
</pre> 

<blockquote>
Это не самый лучший пример стиля Lisp. Вы определяете метод чтения или 
записи по умолчанию в форме DEFCLASS, а затем переопределяете метод, чтобы
добавить специальное поведение. Ваша система Lisp может предупредить вас о
попытке переопределения; это нормально, продолжить с предупреждением и
переопределить метод.


<p>
Один из способов избежать этой проблемы - опустить параметр slot, 
который определяет значение по умолчанию: <code>:READER</code> 
(для <code>VOLUME</code>) или <code>:WRITER</code> 
(для <code>TRANSLATE</code>) в форме <code>DEFCLASS</code>, но 
тогда вы потеряете документирование, предоставляемое этими объявлениями. 
В <a href="chapter14.html">Главе 14</a> мы увидим некоторые другие 
объявления, которые могут помочь улучшить читаемость кода.
 </blockquote> 

<p>Форма <code>DEFMETHOD</code> определяет функцию, которая применяется 
только к определенным типам аргументов. В этом случае метод 
<code>VOLUME</code> применяется только к объектам <code>SPHERE</code>, 
а метод <code>RADIUS</code> - только к <code>NUMBER</code> (новому радиусу) 
и <code>SPHERE</code>. Метод <code>VOLUME</code> вычисляет объем по радиусу 
сферы при каждом ее вызове. Метод <code>RADIUS</code> вычисляет объем сферы
каждый раз, когда устанавливается радиус; значения как радиуса, так и объема
сохраняются в слотах сферы с помощью форм <code>SLOT-VALUE</code>.

<p>Вы можете думать о том, что читатель и писатель слотов по умолчанию
определяются следующим образом (но компилятор, вероятно, генерирует 
лучший код, если вы просто используете стандартные методы доступа, 
созданные автоматически опциями слотов:  <code>:READER</code> и
<code>:WRITER</code>):

<pre>
<i>; Default slot reader (illustration only)</i> 
(defmethod slot-reader ((object object-class))
  (slot-value object 'slot-name))

<i>; Default slot writer (illustration only)</i> 
(defmethod slot-writer (new-value (object object-class))
  (setf (slot-value object 'slot-name) new-value))
</pre> 

<h2>Определение классов с одиночным наследованием для специализации</h2>

<p>
Специализация - одно из важнейших понятий объектного программирования.
Специализация позволяет определить объект в терминах другого объекта путем
описания новых или отличающихся признаков; базовая функциональность объекта
наследуется от определения родительского объекта.


<p>
В самом простом виде специализации, одиночном наследовании, наследник
наследует черты только от одного родителя. В качестве примера мы определим
некоторые базовые двумерные объекты, используя одиночную иерархию наследования.

<pre>
(defclass 2d-object () ())

(defclass 2d-centered-object (2d-object)
  (x :accessor x)
  (y :accessor y)
  (orientation :accessor orientation)

(defclass oval (2d-centered-object)
  (axis-1 :accessor axis-1)
  (axis-2 :accessor axis-2))

(defclass regular-polygon (2d-centered-object)
  (n-sides :accessor number-of-sides)
  (size :accessor size))
</pre> 

<p>Граф наследования для этих четырех классов выглядит следующим образом:

<p><img src="gifs/2d-object-inheritance.gif">

<p>Класс <code>2D-OBJECT</code> - это заполнитель, из которого 
мы могли бы впоследствии вывести другие 2D-объекты, например 
линии и точки. <code>2D-CENTERED-OBJECT</code> объект имеет  опорное положение
по центру, заданное его атрибутами <code>X</code> и <code>Y</code>, 
и ориентацию - величину поворота объекта относительно его центрального 
положения. Классы  <code>OVAL</code> и <code>REGULAR-POLYGON</code> 
наследуются от <code>2D-CENTERED-OBJECT</code>, сохраняя атрибуты положения 
и ориентации родительского класса и добавляя атрибуты, соответствующие геометрии производных объектов.

<h2>Множественное наследование позволяет определять смешивание и
соответствие</h2>

<p>CLOS поддерживает множественное наследование, которое позволяет 
классу наследовать признаки от нескольких родителей. Это полезно для 
стиля программирования, который начинается с общей функциональности, 
а затем "смешивает" расширения с базовым поведением.

<p>
В качестве примера предположим, что мы хотели бы написать код для 
визуализации 2D-объектов, которые мы начали определять в предыдущем 
разделе. Предположим, что мы хотели бы достичь двух целей одновременно: 
мы хотели бы визуализировать изображения либо на растровом(bitmapped), 
либо на Постскриптумном(Postscript) устройстве отображения, и мы хотели 
бы визуализировать объекты либо на плоской поверхности, либо в виде 
проекции в пространстве "2.5 D", где каждый 2D-объект имеет глубину Z, 
и система обеспечивает выбор позиций просмотра. Эти требования вовсе не
являются взаимозависимыми; один из них имеет дело с деталями визуализации
объектов на устройстве отображения, в то время как другой имеет дело с
преобразованиями объектов, которые должны произойти до визуализации.

<p>Одним из способов выполнения этих требований является использование
множественного наследования. Один подмешиваемый набор обрабатывает
преобразования, в то время как другой подмешиваемый набор обрабатывает 
детали рендеринга для устройства отображения. Благодаря тщательно 
разработанному протоколу обмена информацией, новые комбинации 
преобразований и визуализаторов могут быть добавлены к нашим 
2D-объектам без переписывания какого-либо существующего кода.

<p>Мы видели в предыдущем разделе, как одиночное наследование записывается
с помощью <code>DEFCLASS</code>, помещая имя родительского класса в 
первые скобки после нового имени класса. Классы, которые наследуются 
от нескольких родителей, просто перечисляют всех родителей. Таким образом, 
чтобы определить все комбинации преобразования и рендеринга для нашего 
класса <code>REGULAR-POLYGON</code>, мы могли бы сделать что-то вроде этого:

<pre>
(defclass renderer-mixin () (...))
(defclass bitmap-renderer-mixin (renderer-mixin) (...))
(defmethod render (description (self bitmap-renderer-mixin)) ...)
(defclass postscript-renderer-mixin (renderer-mixin) (...))
(defmethod render (description (self postscript-renderer-mixin)) ...)

(defclass transform-mixin () (...))
(defclass plane-transform-mixin (transform-mixin) (...))
(defmethod transform ((self plane-transform-mixin)) ...)
(defclass z-transform-mixin (transform-mixin) (...))
(defmethod transform ((self z-transform-mixin)) ...)

(defmethod draw ((self regular-polygon))
  (render (transform self) self))

(defclass regular-polygon-bmr-pt (regular-polygon
                                  bitmap-renderer-mixin 
                                  plane-transform-mixin)
  (...))

(defclass regular-polygon-psr-pt (regular-polygon
                                  postscript-renderer-mixin
                                  plane-transform-mixin)
  (...))

(defclass regular-polygon-bmr-zt (regular-polygon
                                  bitmap-renderer-mixin
                                  z-transform-mixin)
  (...))

(defclass regular-polygon-psr-zt (regular-polygon
                                  postscript-renderer-mixin
                                  z-transform-mixin)
  (...))
</pre> 

<p>Теперь наша иерархия классов выглядит так:


<p><img src="gifs/2d-object-with-mixins.gif">

<p>
Я показал несколько определений методов, чтобы дать вам представление 
о том, как протокол рисования взаимодействует с подмешиваемыми определениями
для создания ожидаемого поведения. Метод <code>DRAW</code>,
специализированный на классе <code>REGULAR-POLYGON</code> обеспечивает
следующий протокол: он вызывает <code>TRANSFORM</code>, чтобы применить
преобразование к самому себе, а затем <code>RENDER</code>, чтобы нарисовать
самого себя, используя некоторое (пока еще не определенное) описание,
сгенерированное  <code>TRANSFORM</code>.

<p>Теперь давайте предположим, что мы создали экземпляр 
<code>REGULAR-POLYGON-BMR-PT</code> и вызвали метод 
<code>DRAW</code>:

<pre>
(let ((poly (make-instance 'regular-polygon-bmr-pt ...)))
  (draw poly))
</pre> 

<p>
Метод <code>DRAW</code> <em>не</em> специализируются в 
классе <code>REGULAR-POLYGON-BMR-PT</code>, поэтому мы вызываем 
метод более общий, специализированный в <code>REGULAR-POLYGON</code>. 
Затем этот метод <code>DRAW</code> пытается вызвать методы 
<code>TRANSFORM</code> и <code>RENDER</code>, которые специализируются 
в классе <code>REGULAR-POLYGON-BMR-PT</code>; эти методы определены, 
поэтому они обеспечивают ожидаемое подмешиваемое поведение.

<p>
Как вы можете видеть из этого очень простого примера, подмешивание 
являются мощным инструментом для объектного программирования. 
Предварительно определив очень простой протокол - метод <code>DRAW</code>,
который вызывает <code>TRANSFORM</code> и <code>RENDER</code>, - мы можем
добавить новое поведение в нашу систему, определив дополнительные подмешивания.
Исходный код остается неизменным. Поскольку Lisp может добавлять определения
динамически, вам даже не нужно останавливать свое программное обеспечение,
чтобы расширить его таким образом.

<h2>Параметры управляющие инициализацией и предоставление документации</h2>

<p>
По умолчанию слоты объекта не связваются в новом объекте. Во многих 
случаях было бы более полезно придать слотам некоторое значимое 
начальное значение. Например, наша <code>3D-POINT</code> может быть
инициализирована в начале координат.

<pre>
(defclass 3d-point ()
  ((x :accessor point-x :initform 0)
   (y :accessor point-y :initform 0)
   (z :accessor point-z :initform 0)))
</pre> 

<p>
Параметр <code>:INITFORM</code> слота предоставляет значение для слота 
в момент создания объекта. Форма инициализации вычисляется каждый раз, 
когда она используется для инициализации слота.

<p>Кроме того, при создании объекта может потребоваться указать 
конкретные аргументы инициализации. Для этого используйте опцию
слота: <code>:INITARG</code>.

<pre>
(defclass 3d-point ()
  ((x :accessor point-x :initform 0 :initarg :x)
   (y :accessor point-y :initform 0 :initarg :y)
   (z :accessor point-z :initform 0 :initarg :z)))
</pre> 

<p>Чтобы создать <code>3D-POINT</code> объект с использованием 
явных инициализаторов, вы должны сделать что-то вроде этого:

<pre>
(make-instance '3d-point :x 32 :y 17 :z -5)
</pre> 

<p>Поскольку определение класса включает в себя оба параметра 
<code>:INITFORM</code> и <code>:INITARG</code>, слот все равно 
получит значение по умолчанию, если вы опустите явный инициализатор.


<p>Определения слотов также позволяют использовать параметры 
<code>:DOCUMENTATION</code> и <code>:TYPE</code>.

<pre>
(defclass 3d-point ()
  ((x :accessor point-x :initform 0 :initarg :x
      :documentation "x coordinate" :type real)
   (y :accessor point-y :initform 0 :initarg :y
      :documentation "y coordinate" :type real)
   (z :accessor point-z :initform 0 :initarg :z
      :documentation "z coordinate" :type real)))
</pre> 

<p>Параметр <code>:TYPE</code> может использоваться компилятором 
для помощи в оптимизации кода или для создания тестов времени 
выполнения при установке слотов. Однако это поведение может отличаться 
у разных компиляторов Lisp, и стандарт не требует какой-либо 
интерпретации этого параметра. Поэтому лучше всего думать о нем как о
дополнительной документации для человека, читающему вашу программу.

<h2>Но это только начало...</h2>

<p>
В <a href="chapter14.html">Главе 14</a>  мы рассмотрим методы 
более подробно и увидим, как связать поведение с объектами.

<hr>
<div align="center">
<a href="contents.html">Contents</a> | <a href="cover.html">Cover</a> <br> 
<a href="chapter06.html">Chapter 6</a> | Chapter 7 | <a href="chapter08.html">Chapter 8</a> 
</div>
<hr>
<address>
Copyright &copy; 1995-2001, David B. Lamkins<br>
All Rights Reserved Worldwide<br>
<br>
This book may not be reproduced without the written consent of its author.  Online distribution is restricted to the author's site.
</address> 
</body> </html>