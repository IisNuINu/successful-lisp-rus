<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<title>Successful Lisp - Chapter 30</title>
</head> 

<body bgcolor="white" text="black">
<h1>Глава 30 - Полезные советы по отладке и проверке
ошибок</h1> 

<P>
Как и в любом другом языке программирования, предотвращение ошибок 
является лучшей стратегией отладки. Воспользуйтесь преимуществами 
интерактивной документации (доступной для большинства систем) и 
тестовых функций или даже частей функций, когда вы их пишете.

<p>
Тем не менее, вы неизбежно столкнетесь с неожиданной ошибкой, и вы 
должны знать, как использовать отладчик. Чаще всего быстрый взгляд 
на местоположение ошибки, показанное отладчиком, указывает на 
очевидную проблему.


<p>
Некоторые проблемы, однако, не очевидны; ваша программа будет работать 
без ошибок, но даст неправильные результаты. Если проверка кода не 
выявила ошибки, вы можете положиться на встроенные инструменты Lisp, 
чтобы выявить детали работы вашей программы и найти ошибку во время 
выполнения.

<h2>Поиск причины ошибки</h2>

<p>
Есть два способа заметить ошибку. Вторжение отладчика Lisp является наиболее 
очевидным. Отладчик будет появляться всякий раз, когда ваша программа вызывает 
Lisp, чтобы сигнализировать об ошибке. Это часто является результатом чего-то 
очевидного, например, попытки выполнить арифметику с <code>NIL</code> или 
попытки <code>FUNCALL</code> объекта, который не является функцией.

<p>
Неспособность вашей программы выдавать ожидаемые результаты также 
является ошибкой, даже если отладчик никогда не появляется. В этом 
случае ваша программа не делает никаких ошибок при использовании Lisp, 
но успешная последовательность операций Lisp не делает того, что вы 
намеревались. Другая возможность заключается в том, что ваша программа 
вообще не завершается.

<p>
Лучшая защита от всех этих проблем - написать короткие, четкие 
определения функций и протестировать каждое из них, как только 
вы его напишете. Я считаю полезным написать один или несколько 
тестовых случаев и включить их в качестве комментариев 
(в скобках #| и |#) в один и тот же файл.

<h2>Чтение трассы вызовов(backtraces), настройки компилятора для
отладки</h2>

<p>
Каждый отладчик Lisp будет предоставлять по крайней мере две 
важные части информации: сообщение об ошибке и 
обратную трассировку стека.

<p>
Сообщение об ошибке описывает, <em>как</em> произошел сбой программы. 
Обычно это описание ошибки, возникшей при выполнении какой-либо 
встроенной функции Lisp. Если ваша программа вызывает <em>ERROR</em>,
отладчик отобразит указанное вами сообщение.


<p>
Обратная трассировка стека описывает, <em>где</em> ваша программа 
потерпела неудачу, отображая стек вызовов в точке ошибки. Функция, 
которая сигнализировала об ошибке, будет находиться в "верхней" части 
стека. Ниже приводится функция, которая вызвала функцию, которая сигнализировала 
об ошибке, и так далее вплоть до (а иногда и за ее пределами) цикла 
чтения-выполнения-печати(REPL) слушателя.

<p>
Отладчик полагается на определенную информацию, предоставленную 
компилятором или интерпретатором. Хотя детали реализации различаются, 
можно с уверенностью сказать, что оптимизация компилятора, которая 
повышает скорость или уменьшает пространство, как правило, уменьшает 
объем информации, доступной отладчику. Вы можете изменить эти 
оптимизации на время отладки вашей программы:

<pre>
(declaim (optimize (speed 0) (space 0) (debug 3)))
</pre> 

<p>
Если вы выполните это перед компиляцией вашей программы, отладчик должен 
быть в состоянии дать вам больше полезной информации. Вы должны ознакомиться 
с документацией вашего поставщика, чтобы узнать о дополнительных элементах 
управления, специфичных для реализации. Если ваша система Lisp предоставляет 
вам выбор между использованием компилятора и интерпретатора, вы, вероятно, 
обнаружите, что интерпретатор заставляет отладчик давать вам лучшую 
информацию.

<h2>Простые инструменты отладки</h2>

<p>
Если ваша программа дорабатывает до завершения, но дает неверные результаты, 
или если она работает, но не завершается, то вам понадобятся некоторые 
дополнительные инструменты. Первый из этих инструментов должен быть знаком 
всем программистам: вставка вызова отладчика или (чаще всего) 
вставка инструкции print.

<h2>BREAK, PRINT</h2>

<p>
<code>BREAK</code> приводит к тому, что ваша программа вызывает отладчик. 
Оказавшись внутри отладчика, вы можете изучить стек вызовов. Большинство 
отладчиков также позволяют исследовать значения, локальные для каждой 
активной функции в стеке вызовов; рассматривая эти значения в критической 
точке во время выполнения программы, вы можете найти важный ключ к пониманию 
причин сбоев в работе программы.


<p>
Отладчик позволит вам продолжить работу после break. Вы можете найти 
полезным возможность - если вы еще не поняли причину проблемы - исправить одно 
или несколько неправильных значений, прежде чем продолжить; с другими 
формами  <code>BREAK</code>, вставленными в ключевые точки вашей программы, 
эта стратегия может привести вас к месту, где ошибка очевидна.

<p>
Конечно, вы всегда можете вставить формы <code>PRINT</code> в ключевые 
места вашей программы и изучить полученный результат. В Lisp это наиболее 
полезно, когда вам нужно почувствовать, что происходит глубоко внутри 
какой-то функции. Например, у вас может быть сложное вычисление, и чтобы 
определить, выполняется ли последовательность кода или нет. <code>PRINT</code>
может сказать вам, как работает программа.

<p>
Не забывайте, что вы можете использовать <code>FORMAT</code> для печати 
значений нескольких переменных вместе с пояснительным текстом. А при
использовании <code>PRINT</code> или <code>FORMAT</code> будьте осторожны, 
чтобы не изменить значение кода, вставив инструкцию отладки. Помните, что 
некоторые формы управления потоком (например, <code>IF</code> 
и <code>UNWIND-PROTECT</code>) ожидают единую форму в определенных местах. 
Кроме того, остерегайтесь обертывания <code>PRINT</code> вокруг формы 
возврата значения; это не будет работать, если получатель значения ожидает 
несколько значений.

<h2>Мощные инструменты для трудных задач</h2>

<p>Lisp предоставляет дополнительные средства отладки, которые 
помогут вам наблюдать динамическое поведение вашей программы.

<h2>TRACE, STEP, ADVISE, WATCH</h2>

<p> 
<code>TRACE</code> позволяет наблюдать за каждым вызовом и возвратом 
из определенной функции, независимо от того, где эта функция появляется 
в вашей программе. Чтобы отследить функцию, вызовите <code>TRACE</code> 
с именем функции. Вы можете сделать это для любого количества функций, 
которые вам необходимы. Вы также можете передать несколько имен функций 
для <code>TRACE</code>.

<p>
Когда ваша программа запускает отслеживаемую функцию, она будет печатать 
имя функции при входе и выходе. Большинство реализаций трассировки также 
печатают аргументы функции при входе и возвращаемые значения при выходе.


<p>
Чтобы прекратить трассировку функции, передайте ее имя в <code>UNTRACE</code>. 
Чтобы прекратить трассировку всех отслеживаемых функций, выполните 
вычисление <code>(UNTRACE)</code>.

<p>
См. <a href="chapter16.html#trace-and-step">Главу 16</a> 
для ознакомления с примером использования <code>TRACE</code>.

<p>
<code>STEP</code> позволяет вам интерактивно управлять вычислением 
выражения. Если вы выполняете шаг вызова функции, вы должны иметь 
возможность изучить каждую подформу определения функции непосредственно 
перед ее вычислением. Реализации <code>STEP</code> сильно различаются, 
поэтому для получения более подробной информации вам следует обратиться 
к документации вашего поставщика. В общем случае те же самые оптимизации 
и элементы управления, которые помогают отладчику, будут также помогать 
пошаговому исполнению.


<p>
<code>STEP</code> - это очень трудоемкий способ отладки программы, 
так как вы должны указать ее пользовательский интерфейс для вычисления 
каждой подформы. Это разумно для прямолинейного кода, но быстро становится 
утомительным при наличии циклов или рекурсии.

<p>
Некоторые реализации Lisp предоставляют два дополнительных инструмента, 
<code>ADVISE</code> и <code>WATCH</code>, которые могут быть использованы 
во время отладки.

<p>
<code>ADVISE</code> изменяет функцию без изменения ее исходного кода. 
<code>ADVISE</code> обычно может проверить аргументы рекомендованной функции, 
выполнить ее собственный код, выполнить рекомендованную функцию, проверить 
возвращаемые значения рекомендованной функции и изменить возвращаемые значения. 
В целях отладки <code>ADVISE</code> можно использовать для реализации условных 
<code>BREAK</code> и <code>TRACE</code> или для временного исправления 
неправильного поведения в одной части программы во время отладки 
другой части.

<p>
<code>WATCH</code>  позволяет указать переменные, которые будут 
отображаться при выполнении программы. Это обычно доступно только 
в реализациях Lisp, которые предоставляют оконный пользовательский 
интерфейс. Из-за проблем с переменной областью действия, временем 
обновления дисплея и накладными расходами <code>WATCH</code> имеет 
ограниченную ценность. Большинство реализаций Lisp не предоставляют 
этот инструмент.

<h2>Прямо в брюхо зверя</h2>

<p>
При отладке программы может потребоваться просмотреть внутренние 
сведения о составных объектах, таких как списки, структуры, массивы, 
потоки и экземпляры CLOS. Lisp позволяет вам сделать это независимо 
от того, были ли данные определены вашей программой или системой 
выполнения Lisp.

<h2>INSPECT, DESCRIBE</h2>

<p>
<code>DESCRIBE</code> - это функция, которая принимает любой объект 
в качестве аргумента и печатает описание этого объекта. Форма и 
содержание описания могут варьироваться в зависимости от реализаций 
Lisp. <code>DESCRIBE</code> принимает выходной поток в качестве 
необязательного второго аргумента.


<p>
<code>INSPECT</code> это интерактивная версия <code>DESCRIBE</code>. 
Он наиболее полезен для изучения сложных объектов путем "детализации" 
деталей реализации вложенных элементов данных.

<h2>Продолжая с(?) ошибками</h2>

<p>
Когда вы столкнетесь с отладчиком, у вас будет выбор действий перезапуска 
в зависимости от того, как была сигнализирована ошибка. 
<code>ERROR</code> требует, чтобы вы отказались от выполнения вашей программы. 
Однако многие внутренние функции Lisp используют <code>CERROR</code>, что дает 
вам возможность продолжить работу после ошибки.


<p>
В большинстве отладчиков вы можете сделать довольно много полезных вещей, 
прежде чем продолжить работу после ошибки:

<ul>
<li>изменение значений переменных
<li>переопределить функцию, вызвавшую ошибку, и запустить ее снова
<li>пропустить остальную часть функции, вызвавшей ошибку, и 
    указать возвращаемые значения
<li>перезагрузить любую функцию ниже по стеку вызовов
<li>пропустить остальную часть любой функции дальше по стеку вызовов и 
    указать возвращаемые значения
</ul> 

<h2>Проблемы с нежелательными определениями</h2>

<p>
Нежелательные определения обычно не являются проблемой в программе Lisp. 
Вы можете избавиться от определений функций с помощью <code>FMAKUNBOUND</code>, 
от значений переменных с помощью <code>MAKUNBOUND</code> и даже от символов 
с помощью <code>UNINTERN</code>. На практике обычно нет необходимости 
использовать любой из них; доступная память обычно велика по сравнению 
с размером нескольких неверно определенных переменных или функций, и 
они будут устранены в любом случае при следующем перезапуске образа Lisp 
и загрузке вашей программы.

<p>
Определения методов - это совершенно другой вопрос. Помните, что методы 
должны иметь конгруэнтные списки аргументов; если вы изменили свое мнение 
во время разработки программы о списке аргументов метода - возможно, сначала 
вы думали, что ему нужны два аргумента, но затем поняли, что на самом деле нужны 
три аргумента, - то вам придется удалить старое определение метода, прежде чем 
добавлять новое. Некоторых средах Лисп этот пересмотр облегчен:

<pre>
? (defmethod baz (a b))
#&lt;STANDARD-METHOD BAZ (T T)&gt;
? (defmethod baz (a b c))
Error: Incompatible lambda list in #&lt;STANDARD-METHOD BAZ (T T T)&gt;
       for #&lt;STANDARD-GENERIC-FUNCTION BAZ #x3D2CB66&gt;.
Restart options:
  1. Remove 1 method from the generic-function and change its lambda list
  2. Top levl
  ? 
</pre> 

<p>
Если вы просто добавляете метод, который, как вы позже решите, 
больше не нужен, вам понадобится способ удалить этот метод. 
Наименее желательным методом является перезагрузка системы Lisp и 
перезагрузка программы без нежелательного определения. Другой подход, 
который предлагают некоторые поставщики, заключается в интерактивном 
удалении определения с помощью специальной команды редактора или браузера 
методов. Если все остальное не удается, вы можете удалить этот метод вручную 
с помощью  <code>REMOVE-METHOD</code>:

<pre>
(let* ((generic-function (symbol-function '<i>gf-name</i>))
       (method (find-method generic-function
                            '(<i>method-specializers</i>)
                            (list (find-class <i>parameter-class-name</i>)
                                  <i>; one per argument</i> 
                                  ...))))
  (remove-method generic-function method))
</pre> 

<p>
где <i>gf-name</i> - это имя обобщенной функции (т. е. имя метода), 
<i>method-specializers</i> - это либо пустой спецификатор, либо 
комбинации спецификаторов  метода, таких как <code>:BEFORE</code>,
<code>:AFTER</code>, или <code>:AROUND</code>, а 
<i>parameter-class-name</i> - это имя класса, на котором специализирован 
конкретный параметр метода.

<h2>Проблемы в пакетах; определения методов</h2>

<p>
Конфликты символов между пакетами могут быть неприятными во время разработки. 
Если вы определили несколько пакетов для своей программы, вам нужно будет быть
осторожным, чтобы установить правильный пакет (используя <code>IN-PACKAGE</code>) 
перед определением объекта, предназначенного для этого пакета. Если вы случайно 
создадите объект в неправильном пакете, а затем попытаетесь определить его в 
правильном пакете, Lisp будет сигнализировать об ошибке, если существует связь 
"uses" между двумя пакетами. Правильный ответ заключается в том, чтобы сначала 
удалить ошибочное определение с помощью <code>UNINTERN</code>.

<p>
Вы также можете попасть в неприятности с пакетами, имея unexported
(не экспортированные) классы, определенные в двух пакетах, и специализируя 
метод, основанный на неправильном классе.

<h2>Проблемы с макросами</h2>

<p>
Макросы всегда должны быть определены перед использованием. Это особенно 
важно при переопределении макроса во время разработки: каждый фрагмент кода, 
использующий переопределенный макрос, <code>должен быть</code> перекомпилирован. 
Вы можете помочь себе избежать проблем с переопределением макросов, перезагрузив 
исходный код после переопределения любого макроса(ов).

<h2>Проверки времени выполнения ловят "случаи которых не может быть" когда они
порисходят...</h2>

<p>
Когда я читаю код, нахождение фразы "не может произойти" в комментарии 
всегда вызывает красный флаг. Обычно это утверждение делается после того, 
как программист изучил среду выполнения кода и его предполагаемое использование. 
К сожалению, все меняется, и случаи "не может случиться" действительно случаются.

<p>
Lisp предоставляет очень удобный инструмент для проверки операторов
"не может произойти" во время выполнения. Макрос <code>ASSERT</code>
предполагает форму, которая будет возвращать true во время выполнения. 
Если вместо этого форма принимает значение <code>NIL</code>, <code>ASSERT</code>
сигнализирует о продолжаемой(continuable) ошибке, передавая управление отладчику. 
По крайней мере, он поможет вам узнать, какое утверждение было нарушено, чтобы 
вы могли исправить свою программу.

<p>
<code>ASSERT</code> принимает необязательный список мест значений, 
который пользователь может интерактивно изменить, чтобы удовлетворить 
этому утверждению.

<pre>
? (defun add-2 (n)
    (assert (numberp n) (n))
    (+ 2 n))
? (add-2 3)
5
? (add-2 'foo)
Error: Failed assertion (NUMBERP N)
Restart options:
  1. Change the values of some places, then retry the assertion
  2. Top level
  ? 1
  Value for N: 4
6
</pre> 

Дополнительную информацию о <a href="chapter23.html#assert"><code>ASSERT</code></a>
 и других методах обнаружения и восстановления ошибок см. В 
<a href="chapter23.html">Главе 23</a>

<h2>Используйте диспечеризацию метдов, а не условную диспетчеризацию(case dispatch)</h2>

<p>
Когда ваша программа должна принять решение, основанное на типе объекта, 
у вас есть два варианта. Вы можете использовать <code>TYPECASE</code>
или <code>DEFMETHOD</code>. Если у вас нет обстоятельств, которые особенно 
оправдывают использование <code>TYPECASE</code> (или его вариантов
<code>CTYPECASE</code> и <code>ETYPECASE</code>) - и особенно если набор 
типов будет меняться в ходе нормальной эволюции программы или обслуживания
- вы, вероятно, должны построить свою программу для работы с отдельными типами 
с помощью обобщенных функций. Это более четко раскрывает цель программы и 
исключает вероятность того, что вы забудете обновить форму <code>TYPECASE</code>
 во время обслуживания.

<hr>
<div align="center">
<a href="contents.html">Contents</a> | <a href="cover.html">Cover</a> <br> 
<a href="chapter29.html">Chapter 29</a> | Chapter 30 | <a href="chapter31.html">Chapter 31</a> 
</div>
<hr>
<address>
Copyright &copy; 1995-2001, David B. Lamkins<br>
All Rights Reserved Worldwide<br>
<br>
This book may not be reproduced without the written consent of its author.  Online distribution is restricted to the author's site.
</address> 
</body> </html>