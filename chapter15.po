#
# NuINu <don't@send.my>, 2020.
#
#. extracted from in/chapter15.html
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-04-19 13:50+0300\n"
"PO-Revision-Date: 2020-06-12 19:55+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter15.html:5
msgid ""
"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/"
"html4/strict.dtd\">\n"
"<html><head>\n"
"<title>Successful Lisp - Chapter 15</title>\n"
"</head> "
msgstr ""
"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/"
"html4/strict.dtd\">\n"
"<html><head>\n"
"<META http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n"
"<title>Successful Lisp - Chapter 15</title>\n"
"</head> "

#: in/chapter15.html:8
msgid ""
"<body bgcolor=\"white\" text=\"black\">\n"
"<h1>Chapter 15 - Closures</h1> "
msgstr ""
"<body bgcolor=\"white\" text=\"black\">\n"
"<h1>Глава 15 - Замыкания</h1> "

#: in/chapter15.html:14
msgid ""
"<P>In this chapter we'll expand upon the discussion of closures that\n"
"we started in <a href=\"chapter11.html#closures\">Chapter 11</a>.  We'll\n"
"see again how (and why) closures capture free variables for use in \n"
"other execution contexts, then we'll see some practical applications.\n"
"We'll close this chapter with a look at functions that return functions."
msgstr ""
"<P>\n"
"В этой главе мы подробно остановимся на обсуждении вопроса о замыканиях, \n"
"которое мы начали в <a href=\"chapter11.html#closures\">Главе 11</a>. \n"
"Мы снова увидим, как (и почему) замыкания захватывают свободные переменные \n"
"для использования в других контекстах выполнения, а затем мы увидим "
"некоторые \n"
"практические приложения. Мы закончим эту главу, рассмотрев функции, "
"которые \n"
"возвращают функции."

#: in/chapter15.html:16
msgid ""
"<h2>Is it a function of the lifetime, or the lifetime of a function?</h2>"
msgstr ""
"<h2>Является ли это функцией с временем жизни, или временем жизни функции?</"
"h2>"

#: in/chapter15.html:27
msgid ""
"<p>Common Lisp does not expose closures per se. Recall from <a\n"
"href=\"chapter11.html#closures\">Chapter 11</a> that a closure is a\n"
"collection of closed-over variables retained by a function. (A\n"
"closed-over variable is a variable found \"free\" in the function;\n"
"this gets \"captured\" by the closure. We saw some examples of this in\n"
"<a href=\"chapter11.html#closures\">Chapter 11</a>; we'll review the\n"
"details in the next section, in case you've forgotten.) For this\n"
"reason, Lisp programmers tend to refer to \"a function having\n"
"closed-over variables\" as simply \"a closure.\" Or maybe they call it\n"
"that because it saves them nine syllables."
msgstr ""
"<p>\n"
"Common Lisp не раскрывает замыкания как таковые. Напомним из \n"
"<a href=\"chapter11.html#closures\">Главы 11</a>, что замыкание - \n"
"это набор замкнутых переменных, сохраняемых функцией. (Замкнутая переменная "
"- это\n"
"переменная, найденная \"свободной \"в функции; она \"захватывается\" "
"замыканием. \n"
"Мы видели некоторые примеры этого в <a href=\"chapter11.html#closures"
"\">Главе 11</a>; \n"
"мы рассмотрим детали в следующем разделе, Если вы забыли.) По этой причине \n"
"программисты Lisp склонны называть \"функцию, имеющую замкнутые переменные "
"\"просто\"\n"
"замыкаием.- Или, может быть, они называют его так, потому что это экономит \n"
"им девять слогов."

#: in/chapter15.html:35
msgid ""
"<p>A closure has to be associated with a function, so it must have\n"
"the same lifetime -- or extent -- as the function. But all of the\n"
"closed-over variables come along for the ride -- a closed-over\n"
"variable has the same extent as the closure. This means that you can\n"
"close over a lexical variable, which would normally have lexical\n"
"extent, and give that variable indefinite extent. This is a very\n"
"useful technique, as we'll see shortly."
msgstr ""
"<p>\n"
"Замыкание должно быть связано с функцией, поэтому оно должно иметь тот же \n"
"срок жизни - или экстент/протяженность - что и функция. Но все замкнутые "
"переменные \n"
"идут вместе  - замкнутая переменная имеет тот же экстент(время жизни), что и "
"замыкание. \n"
"Это означает, что вы можете замкнуть лексическую переменную, которая обычно "
"имеет\n"
"лексический экстент, и дать этой переменной неопределенный экстент. Это "
"очень \n"
"полезная техника, как мы вскоре увидим."

#: in/chapter15.html:37
msgid "<h2>How to spot a free variable, and what to do about it.</h2>"
msgstr "<h2>Как определить свободную переменную и что с ней делать.</h2>"

#: in/chapter15.html:44
msgid ""
"<p>A variable is <em>free</em> within a function (or within any\n"
"form, for that matter) if there is no binding occurrence of its name\n"
"within the lexical scope -- the textual bounds, more or less -- of\n"
"the function. A binding occurrence is an occurrence of the name\n"
"that (according to the definition of the form that includes the\n"
"name) associates storage with the name."
msgstr ""
"<p>\n"
"Переменная свободна в пределах функции (или в пределах любой формы, \n"
"если уж на то пошло), если нет привязки её имени в лексической области \n"
"- текстуальной границы функции. Вхождение привязки - \n"
"это вхождение имени, которое (в соответствии с определением формы, \n"
"включающей имя) связывает хранилище с именем."

#: in/chapter15.html:53
msgid ""
"<p>A free variable must be found in one of two places. Either the\n"
"function is textually wrapped within a form that provides a binding\n"
"occurrence of the variable, or the variable is <code>special</code>\n"
"(review <a href=\"chapter08.html#special\">Chapter 8</a>) and\n"
"contained in the global environment. If a free variable is not found\n"
"in one of these two places, it is <em>unbound</em> (i.e. has no\n"
"storage associated with the name) and will cause an error when\n"
"referenced at runtime."
msgstr ""
"<p>\n"
"Свободная переменная должна быть найдена в одном из двух мест. Либо "
"функция \n"
"текстуально завернута в форму, которая обеспечивает связывание вхождения "
"переменной, \n"
"либо переменная является специальной(<code>special</code>) (смотрите\n"
"<a href=\"chapter08.html#special\">Главу 8</a> ) и содержится в глобальном "
"окружении. \n"
"Если свободная переменная не найдена ни в одном из этих двух мест, она не "
"считается\n"
"связанной (т. е. не имеет хранилища, связанного с именем) и вызовет ошибку "
"при \n"
"ссылке на нее во время выполнения."

#: in/chapter15.html:55
msgid "<h2>Using closures to keep private, secure information.</h2>"
msgstr ""
"<h2>Использование замыканий для хранения конфиденциальной информации.</h2>"

#: in/chapter15.html:61
msgid ""
"<p>If you close over a lexical variable, that variable is accessible\n"
"<em>only</em> from within the closure. You can use this to your\n"
"advantage to store information that is truly private, accessible\n"
"only to functions that have a closure containing your private\n"
"variable(s)."
msgstr ""
"<p>\n"
"Если вы закрываете/замыкаете лексическую переменную, то эта переменная "
"доступна только \n"
"изнутри замыкания. Вы можете использовать это в своих интересах для "
"хранения \n"
"информации, которая действительно является частной, доступной только для "
"функций, \n"
"которые имеют замыкание, содержащее вашу частную переменную(ные)."

#: in/chapter15.html:111
msgid ""
"<pre>\n"
"? (let ((password nil)\n"
"        (secret nil))\n"
"    (defun set-password (new-passwd)\n"
"      (if password\n"
"        '|Can't - already set|\n"
"        (setq password new-passwd)))\n"
"    (defun change-password (old-passwd new-passwd)\n"
"      (if (eq old-passwd password)\n"
"        (setq password new-passwd)\n"
"        '|Not changed|))\n"
"    (defun set-secret (passwd new-secret)\n"
"      (if (eq passwd password)\n"
"        (setq secret new-secret)\n"
"        '|Wrong password|))\n"
"    (defun get-secret (passwd)\n"
"      (if (eq passwd password)\n"
"        secret\n"
"        '|Sorry|)))\n"
"GET-SECRET\n"
"? (get-secret 'sesame)\n"
"|Sorry|\n"
"? (set-password 'valentine)\n"
"SECRET\n"
"? (set-secret 'sesame 'my-secret)\n"
"|Wrong password|\n"
"? (set-secret 'valentine 'my-secret)\n"
"MY-SECRET\n"
"? (get-secret 'fubar)\n"
"|Sorry|\n"
"? (get-secret 'valentine)\n"
"MY-SECRET\n"
"? (change-password 'fubar 'new-password)\n"
"|Not changed|\n"
"? (change-password 'valentine 'new-password)\n"
"NEW-PASSWORD\n"
"? (get-secret 'valentine)\n"
"|Sorry|\n"
"<i>; The closed-over lexical variables aren't in the global environment</"
"i> \n"
"? password\n"
"Error: unbound variable\n"
"? secret\n"
"Error: unbound variable\n"
"<i>; The global environment doesn't affect the closed-over variables</i> \n"
"? (setq password 'cheat)\n"
"CHEAT\n"
"? (get-secret 'cheat)\n"
"|Sorry|\n"
"</pre> "
msgstr ""

#: in/chapter15.html:113
msgid ""
"<h2>Functions that return functions, and how they differ from macros.</h2>"
msgstr ""
"<h2>Функции, которые возвращают функции и чем они отличаются от макросов.</"
"h2>"

#: in/chapter15.html:122
msgid ""
"<p>The preceding example is only good for keeping one secret,\n"
"because every time we evaluate the outer <code>LET</code> form we\n"
"redefine all of the functions that close over our \"private\"\n"
"variables. If we want to eliminate our dependence upon the global\n"
"namespace for functions to manipulate our closed-over variables,\n"
"we're going to have to find a way to create new closed-over\n"
"variables and return a function that we can save and later use to\n"
"manipulate the variables.  Something like this will work:"
msgstr ""
"<p>\n"
"Предыдущий пример хорош только для сохранения одного секрета, потому что \n"
"каждый раз, когда мы вычисляем внешнюю форму <code>LET</code>, мы \n"
"переопределяем все функции, которые замыкаются над нашими \"частными\" \n"
"переменными. Если мы хотим устранить нашу зависимость от глобального \n"
"пространства имен для функций, манипулирующих нашими закрытыми "
"переменными, \n"
"нам придется найти способ создать новые замкнутые/закрытые переменные и \n"
"вернуть функцию, которую мы можем сохранить и позже использовать для \n"
"манипулирования переменными. Что-то вроде этого сработает:"

#: in/chapter15.html:171
msgid ""
"<pre>\n"
"? (defun make-secret-keeper ()\n"
"    (let ((password nil)\n"
"          (secret nil))\n"
"      #'(lambda (operation &amp;rest arguments)\n"
"          (ecase operation\n"
"            (set-password\n"
"             (let ((new-passwd (first arguments)))\n"
"               (if password\n"
"                 '|Can't - already set|\n"
"                 (setq password new-passwd))))\n"
"            (change-password\n"
"             (let ((old-passwd (first arguments))\n"
"                   (new-passwd (second arguments)))\n"
"               (if (eq old-passwd password)\n"
"                 (setq password new-passwd)\n"
"                 '|Not changed|)))\n"
"            (set-secret\n"
"             (let ((passwd (first arguments))\n"
"                   (new-secret (second arguments)))\n"
"               (if (eq passwd password)\n"
"                 (setq secret new-secret)\n"
"                 '|Wrong password|)))\n"
"            (get-secret\n"
"             (let ((passwd (first arguments)))\n"
"               (if (eq passwd password)\n"
"                 secret\n"
"                 '|Sorry|)))))))\n"
"MAKE-SECRET-KEEPER\n"
"? (defparameter secret-1 (make-secret-keeper))\n"
"SECRET-1\n"
"? secret-1\n"
"#&lt;LEXICAL-CLOSURE #x36AE056&gt;\n"
"? (funcall secret-1 'set-password 'valentine)\n"
"VALENTINE\n"
"? (funcall secret-1 'set-secret 'valentine 'deep-dark)\n"
"DEEP-DARK\n"
"? (defparameter secret-2 (make-secret-keeper))\n"
"SECRET-2\n"
"? (funcall secret-2 'set-password 'bloody)\n"
"BLOODY\n"
"? (funcall secret-2 'set-secret 'bloody 'mysterious)\n"
"MYSTERIOUS\n"
"? (funcall secret-2 'get-secret 'valentine)\n"
"|Wrong password|\n"
"? (funcall secret-1 'get-secret 'valentine)\n"
"DEEP-DARK\n"
"</pre> "
msgstr ""

#: in/chapter15.html:176
msgid ""
"<p>The <code>ECASE</code> form is an <em>exhaustive case</em>\n"
"statement. In our program, the <code>OPERATION</code> must be found\n"
"in one of the <code>ECASE</code> clauses, or Lisp will signal an\n"
"error."
msgstr ""
"<p>\n"
"Форма <code>ECASE</code> является исчерпывающим изложением дела. \n"
"В нашей программе операция <code>OPERATION</code> должна быть найдена \n"
"в одном из предложений <code>ECASE</code>, иначе Lisp будет "
"сигнализировать \n"
"об ошибке."

#: in/chapter15.html:183
msgid ""
"<p>The <code>#'(LAMBDA ...</code> form creates a closure over the\n"
"free variables <code>PASSWORD</code> and <code>SECRET</code>. Each\n"
"time we evaluate <code>MAKE-SECRET-KEEPER</code>, the outermost\n"
"<code>LET</code> form creates new bindings for these variables; the \n"
"closure is then created and returned as the result of the \n"
"<code>MAKE-SECRET-KEEPER</code> function."
msgstr ""
"<p>\n"
"Форма <code>#'(LAMBDA ...</code> создает замыкание над свободными "
"переменными \n"
"<code>PASSWORD</code> and <code>SECRET</code>. Каждый раз, когда мы "
"вычисляем \n"
"<code>MAKE-SECRET-KEEPER</code>, самая внешняя форма <code>LET</code> "
"создает \n"
"новые привязки для этих переменных; замыкание затем создается и возвращается "
"в \n"
"результате функции <code>MAKE-SECRET-KEEPER</code>."

#: in/chapter15.html:190
msgid ""
"<blockquote>\n"
"In pre-ANSI Common Lisp, <code>LAMBDA</code> is merely a symbol\n"
"that is recognized as a marker to define a lambda expression.\n"
"By itself, <code>LAMBDA</code> does not create a closure; that is\n"
"the function of the <code>#'</code> reader macro (which expands\n"
"into a <code>(FUNCTION ...</code> form)."
msgstr ""
"<blockquote>\n"
"В пред-ANSI Common Lisp  <code>LAMBDA</code> - это просто символ, \n"
"который распознается  как маркер для определения лямбда-выражения. \n"
"Сама по себе  <code>LAMBDA</code> не создает  замыкания; \n"
"это функция макроса чтения <code>#'</code> (который расширяется \n"
"в форму  <code>(FUNCTION ...</code> form)."

#: in/chapter15.html:198
msgid ""
"<p>ANSI Common Lisp defines a <code>LAMBDA</code> macro that expands\n"
"into <code>(FUNCTION (LAMBDA ...</code>, which you can use in place\n"
"of <code>#'(LAMBDA</code> wherever it appears in this example. For\n"
"backward compatibility with pre-ANSI Common Lisp implementations,\n"
"you should always write <code>#'(LAMBDA ...</code> -- the redundant\n"
"<code>(FUNCTION ...</code> in the expansion will do no harm.\n"
"</blockquote> "
msgstr ""
"<p>\n"
"ANSI Common Lisp определяет макрос <code>LAMBDA</code>, который "
"расширяется \n"
"в <code>(FUNCTION (LAMBDA ...</code>, который вы можете использовать "
"вместо \n"
"<code>#'(LAMBDA</code> везде, где он появляется в этом примере. Для "
"обратной \n"
"совместимости с реализациями Пред-ANSI Common Lisp вы всегда должны писать \n"
"<code>#'(LAMBDA ...</code> -- избыточная <code>(FUNCTION ...</code> в \n"
"расширении не причинити никакого вреда.\n"
"</blockquote> "

#: in/chapter15.html:202
msgid ""
"<p>Within each <code>ECASE</code> clause we extract arguments from\n"
"the <code>&amp;REST</code> variable <code>ARGUMENTS</code> and then do\n"
"exactly the same processing as in our earlier example."
msgstr ""
"<p>\n"
"В каждом предложении <code>ECASE</code> мы извлекаем аргументы из \n"
"остатков(<code>&amp;REST</code>) переменной <code>ARGUMENTS</code>\n"
"и затем выполняем точно такую же обработку, как и в нашем предыдущем \n"
"примере."

#: in/chapter15.html:209
msgid ""
"<p>Once we have invoked <code>MAKE-SECRET-KEEPER</code> and saved\n"
"the resultant closure, we can <code>FUNCALL</code> the closure,\n"
"passing the operation symbol and any additional arguments. Note that\n"
"each closure created by <code>MAKE-SECRET-KEEPER</code> is\n"
"completely independent; we've therefore achieved the goal of being\n"
"able to keep multiple secrets."
msgstr ""
"<p>\n"
"После того, как мы вызвали <code>MAKE-SECRET-KEEPER</code> и сохранили \n"
"результирующее замыкание, мы можем <code>FUNCALL</code>(выполнить) "
"замыкание, \n"
"передавая символ операции и любые дополнительные аргументы. Обратите "
"внимание, \n"
"что каждое замыкание, созданное <code>MAKE-SECRET-KEEPER</code>, полностью \n"
"независимо; поэтому мы достигли цели хранить множество секретов"

#: in/chapter15.html:215
msgid ""
"<p>Functions that return closures are different from macros. A macro\n"
"is a function that produces a form; the form is then evaluated to\n"
"produce a result. A function that returns a closure simply returns\n"
"an object: the closure. The returned closure is <em>not</em>\n"
"automatically evaluated by the Lisp evaluator."
msgstr ""
"<p>\n"
"Функции, возвращающие замыкания, отличаются от макросов. Макрос - это "
"функция, \n"
"которая создает форму; затем форма вычисляется для получения результата. \n"
"Функция, возвращающая замыкание, просто возвращает объект: замыкание. \n"
"Возвращаемое замыкание не вычисляется автоматически Lisp вычислителем."

#: in/chapter15.html:228
msgid ""
"<hr>\n"
"<div align=\"center\">\n"
"<a href=\"contents.html\">Contents</a> | <a href=\"cover.html\">Cover</a> "
"<br> \n"
"<a href=\"chapter14.html\">Chapter 14</a> | Chapter 15 | <a href=\"chapter16."
"html\">Chapter 16</a> \n"
"</div>\n"
"<hr>\n"
"<address>\n"
"Copyright &copy; 1995-2001, David B. Lamkins<br>\n"
"All Rights Reserved Worldwide<br>\n"
"<br>\n"
"This book may not be reproduced without the written consent of its author.  "
"Online distribution is restricted to the author's site.\n"
"</address> \n"
"</body> </html> "
msgstr ""
