<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>Successful Lisp - Chapter 3, Lesson 2</title> 
</head>

<body bgcolor="white" text="black">
<h1>Глава 3 - Основы Лисп в 12 уроках</h1> 

<h2><A NAME="lesson-2">Урок 2 - Основы Выполнения</A></h2> 

<h3>Форма предназначена для оценки/вычисления(evaluate)</h3> 

<P>
<A NAME="form">Форма</A> может быть либо <A HREF="chapter03-01.html#atom">атомом</A>,
либо <A HREF="chapter03-01.html#list">списком</A>. Важно то, что форма предназначена 
для <A NAME="evaluated">оценки/вычисления</A>. Вычисление имеет довольно техническое определение, которое мы будем постепенно раскрывать в этом разделе.
</P>

<P>Оценка/Вычисление тривиально, если форма является атомом. Lisp обрабатывает
атом как имя и извлекает значение для этого имени (если оно существует). Вы, 
вероятно, удивляетесь, почему я избегаю более прямого объяснения, называя 
атом переменной. Причина в том, что атом может иметь как переменное, 
так и постоянное значение. А значение атома может быть постоянным по 
нескольким причинам.</P>

<P>
Число - это атом. (Его значение постоянно по понятным причинам.) Lisp 
не <EM>хранит</EM> значение для числа - число, как говорят, самовычисляемо. 
</P>

<BLOCKQUOTE>
Мы собираемся ввести новый термин без полного определения. А пока думайте 
о  <EM>символе</EM> как об атоме, который может иметь значение. Мы рассмотрим
символы более подробно, когда перейдем к <A HREF="chapter03-05.html">уроку 5</A>.
</BLOCKQUOTE>

<P>
Символ, определенный в форме <CODE>defconstant</CODE>, имеет постоянное
значение. Lisp сохранит значение, как если бы у атома было переменное
значение, и добавит заметку о том, что это значение не может быть изменено.
</P>

<P>
Символ в пакете <CODE>KEYWORD</CODE>(ключевых) слов является самовычисляемым. 
Мы подробно рассмотрим пакеты в <A HREF="chapter31.html">главе 31</A>. 
На данный момент все, что вам нужно знать, это то, что символ, начинающийся с 
символьного знака <CODE>:</CODE> (называемого префиксом пакета), 
является символом ключевым словом. Символы ключевые слова  имеют 
сами себя в качестве своих значений.
</P>

<P>
Символ может получить значение переменной многими различными способами. 
Лисп на самом деле хранит несколько различных значений для символа. 
Одно из них имеет традиционное значение как значение символа, взятого в 
качестве переменной. Другое имеет значение как функция символа. Третье 
следит за документацией символа, его печатным представлением и свойствами
(properties), которые программист выбирает для ассоциации с символом. 
Некоторые из них мы рассмотрим более подробно на 
<A HREF="chapter03-05.html">Уроке 5</A>, <A HREF="chapter03-06.html">Уроке 6</A> 
и <A HREF="chapter03-07.html">уроке 7</A>.
</P>

<P>
Если форма-это список, то первый элемент должен быть либо символом, 
либо специальной формой, называемой лямбда-выражением. (Некоторое время 
мы не будем рассматривать лямбда-выражения.) Символ должен давать имя функции. 
В Lisp <EM>символы</EM> <CODE>+</CODE>, <CODE>-</CODE>, <CODE>*</CODE> обозначают
четыре общие арифметические операции: сложение, вычитание, умножение и деление. 
Каждый из этих символов имеет соответствующую функцию, которая выполняет 
арифметическую операцию.
</P>

<P>
Поэтому, когда Lisp вычисляет форму <CODE>(+ 2 3)</CODE>, он применяет функцию сложения 
к аргументам <CODE>2</CODE> и <CODE>3</CODE>, давая ожидаемый результат <CODE>5</CODE>. 
Обратите внимание, что 
символ функции ,<CODE>+</CODE>, предшествует ее аргументам. Это 
<EM>prefix/префиксная</EM> нотация. 
Каждый раз, когда вы видите список, посмотрите на его первый элемент, 
чтобы узнать, что Лисп будет делать, чтобы вычислить/оценить список 
как форму.
</P>

<h3>Функция применяется к своим аргументам</h3> 

<P>Lisp, когда ему дается список для вычисления, рассматривает форму как
вызов функции. С этого момента мы будем видеть много Lisp вычислений, 
поэтому мы будем использовать некоторые визуальные средства для определения 
входных данных для Lisp и его ответов:</P>

<PRE WIDTH=80><IMG SRC="gifs/circle-dot.gif" ALT="?" ALIGN="BOTTOM"> 
он предшествует строке ввода Lisp<br>
<IMG SRC="gifs/right-arrow.gif" ALT="-&gt;" ALIGN="BOTTOM"> результат вычисления Lisp
</PRE>

<P>Например:</P>

<PRE WIDTH=80><IMG SRC="gifs/circle-dot.gif" ALT="?" ALIGN="BOTTOM"> (+ 4 9)<br><IMG SRC="gifs/right-arrow.gif" ALT="-&gt;" ALIGN="BOTTOM"> 13<br><br><IMG SRC="gifs/circle-dot.gif" ALT="?" ALIGN="BOTTOM"> (- 5 7)<br><IMG SRC="gifs/right-arrow.gif" ALT="-&gt;" ALIGN="BOTTOM"> -2<br><br><IMG SRC="gifs/circle-dot.gif" ALT="?" ALIGN="BOTTOM"> (* 3 9)<br><IMG SRC="gifs/right-arrow.gif" ALT="-&gt;" ALIGN="BOTTOM"> 27<br><br><IMG SRC="gifs/circle-dot.gif" ALT="?" ALIGN="BOTTOM"> (/ 15.0 2)<br><IMG SRC="gifs/right-arrow.gif" ALT="-&gt;" ALIGN="BOTTOM"> 7.5</PRE>

<P>
В каждом приведенном выше случае вычисляемая форма представляет собой список. 
Его первый элемент-это символ, который именует функцию. Остальные элементы 
являются <EM>аргументами</EM> функции. Здесь все аргументы-это числа, и мы знаем, 
что числа-являются самовычисляемыми.
</P>

<P>Вот еще несколько примеров:</P>

<PRE WIDTH=80><IMG SRC="gifs/circle-dot.gif" ALT="?" ALIGN="BOTTOM"> (atom 123)<br><IMG SRC="gifs/right-arrow.gif" ALT="-&gt;" ALIGN="BOTTOM"> T<br><br><IMG SRC="gifs/circle-dot.gif" ALT="?" ALIGN="BOTTOM"> (numberp 123)<br><IMG SRC="gifs/right-arrow.gif" ALT="-&gt;" ALIGN="BOTTOM"> T<br><br><IMG SRC="gifs/circle-dot.gif" ALT="?" ALIGN="BOTTOM"> (atom :foo)<br><IMG SRC="gifs/right-arrow.gif" ALT="-&gt;" ALIGN="BOTTOM"> T<br><br><IMG SRC="gifs/circle-dot.gif" ALT="?" ALIGN="BOTTOM"> (numberp :foo)<br><IMG SRC="gifs/right-arrow.gif" ALT="-&gt;" ALIGN="BOTTOM"> NIL</PRE>

<P><CODE>ATOM</CODE> и <CODE>NUMBERP</CODE>  - это предикаты. Предикаты 
возвращают значение true или false. NIL-это единственное ложное значение в Lisp , 
все остальное-правда. Если предикат не имеет более полезного значения для возврата, 
он обычно возвращает <CODE>T</CODE>, чтобы означать true. <CODE>ATOM</CODE> 
возвращает <code>T</code>, если его единственным аргументом является атом Lisp. 
<CODE>NUMBERP</CODE> возвращает значение <code>T</code>, если его аргументом 
является число.
</P>

<P>Чтобы вычислить каждую из вышеперечисленных форм, Lisp сначала вычисляет
аргументы (слева направо), затем вычисляет первый элемент, чтобы получить 
его функцию, а затем применяет функцию к аргументам. За редким исключением, 
о котором мы узнаем в конце этого урока, Lisp всегда делает то же самое 
для вычисления формы списка:</P>

<A NAME="basic-eval"><OL>
<LI>Вычисляются аргументы слева направо.</LI>
<LI>Получают функцию, связанную с первым элементом.</LI>
<LI>Применяют функцию к аргументам.</LI>
</OL></A>

<P>Помните, что атом также может быть Лисп формой. Когда дается Атом для 
вычисления, Lisp просто возвращает его значение:</P>

<PRE WIDTH=80><IMG SRC="gifs/circle-dot.gif" ALT="?" ALIGN="BOTTOM"> 17.95<br><IMG SRC="gifs/right-arrow.gif" ALT="-&gt;" ALIGN="BOTTOM"> 17.95<br><br><IMG SRC="gifs/circle-dot.gif" ALT="?" ALIGN="BOTTOM"> :A-KEYWORD<br><IMG SRC="gifs/right-arrow.gif" ALT="-&gt;" ALIGN="BOTTOM"> :A-KEYWORD<br><br><IMG SRC="gifs/circle-dot.gif" ALT="?" ALIGN="BOTTOM"> *FEATURES*<br><IMG SRC="gifs/right-arrow.gif" ALT="-&gt;" ALIGN="BOTTOM"> (:ANSI-CL :CLOS :COMMON-LISP)<br><br><IMG SRC="gifs/circle-dot.gif" ALT="?" ALIGN="BOTTOM"> "Hello, world!"<br><IMG SRC="gifs/right-arrow.gif" ALT="-&gt;" ALIGN="BOTTOM"> "Hello, world!"<br><br><IMG SRC="gifs/circle-dot.gif" ALT="?" ALIGN="BOTTOM"> WHAT-IS-THIS?<br><IMG SRC="gifs/right-arrow-bar.gif" ALT="-&gt;" ALIGN="BOTTOM"> Error: Unbound variable</PRE>

<P>
Цифры и ключевые слова - самовычисляются. Как и строки. Переменная 
<CODE>*FEATURES*</CODE> предопределена в Lisp - ваша система, вероятно, 
вернет другое значение.
</P>

<P>
Символ - <CODE>WHAT-IS-THIS?</CODE> не имеет значения, потому что он не 
предопределен Lisp, и я не задал ему значения. Система отвечает сообщением 
об ошибке, а не значением. Мы помечаем сообщение знаком 
<IMG SRC="gifs/right-arrow-bar.gif" ALT="-&gt;|" ALIGN="BOTTOM">, а не маркером 
<IMG SRC="gifs/right-arrow.gif" ALT="-&gt;" ALIGN="BOTTOM">, который мы 
используем при успешном вычислении. Ваша система, вероятно, напечатает 
другое сообщение.
</P>

<h3>Функция может возвращать любое количество значений</h3> 

<P>
Иногда вы хотите, чтобы функция возвращала несколько значений. Например, функция, 
которая ищет запись базы данных, может возвращать как желаемый результат, 
так и код состояния завершения. Один из способов сделать это-передать функции
местоположение для одного из результатов; это возможно, но <STRONG>очень</STRONG> редко 
для программы Lisp.
</P>

<P>
Другой подход создает одно возвращаемое значение объединяя оба значения, 
как результат, так и код состояния. Lisp дает вам несколько различных 
способов вернуть результ, включая возврат 
<A HREF="chapter03-10.html#structures">структуры(structures)</A>. 
Опытные программисты на Лиспе не делают так, когда созданное для
возврата значение будет просто разбито на его компоненты, а затем забыто, 
так как составное значение тогда становится мусором 
(см. <A HREF="chapter29.html">Главу 29</A>), что в конечном итоге 
замедляет работу программы.
</P>

<P>
Правильный способ вернуть несколько значений из функции - это использовать 
форму <CODE>VALUES</CODE>. Через некоторое время мы увидим форму
<A HREF="chapter03-09.html"><CODE>VALUES</CODE>, используемую в контексте 
функции</A>. А пока давайте посмотрим, что происходит, когда Lisp вычисляет 
форму <CODE>VALUES</CODE>:
</P>

<PRE WIDTH=80><IMG SRC="gifs/circle-dot.gif" ALT="?" ALIGN="BOTTOM"> (values 1 2 3 :hi "Hello")<br><IMG SRC="gifs/right-arrow.gif" ALT="-&gt;" ALIGN="BOTTOM"> 1<br><IMG SRC="gifs/right-arrow.gif" ALT="-&gt;" ALIGN="BOTTOM"> 2<br><IMG SRC="gifs/right-arrow.gif" ALT="-&gt;" ALIGN="BOTTOM"> 3<br><IMG SRC="gifs/right-arrow.gif" ALT="-&gt;" ALIGN="BOTTOM"> :HI
<IMG SRC="gifs/right-arrow.gif" ALT="-&gt;" ALIGN="BOTTOM"> "Hello"</PRE>

<P>
Обратите внимание, как Lisp возвращает значение (после индикатора 
<IMG SRC="gifs/right-arrow.gif" ALT="-&gt;" ALIGN="BOTTOM">) для <EM>каждого</EM> 
аргумента в форме <CODE>VALUES</CODE>. Моя система Lisp представляет это, 
печатая каждое значение в новой строке; ваша может отделить значения 
каким-то другим способом.
</P>

<h3>Аргументы обычно не изменяются функцией</h3> 

<P>
Я уже упоминал ранее, что вы можете передать в функцию местоположение и 
заставить ее изменить значение местоположения. Это <EM>очень</EM> необычная 
практика для программы Lisp, хотя другие языки делают ее частью своего 
стандартного репертуара.
</P>

<P>
Вы можете указать местоположение, которое будет изменено, как обычный символ, а 
не ключевое слово или составное значение - очевидно, вы не можете изменить константу. 
Если вы предоставляете символ, то ваша функция должна выполнить код, который даст 
символу новое значение. Если вы предоставляете составную структуру данных, 
ваша функция должна выполнить код, чтобы изменить правильный фрагмент 
составного значения. Для этого труднее написать Лисп-код, и труднее понять 
программы, написанные таким образом. Таким образом, программисты Lisp обычно 
пишут функции,  которые получают свои входные данные из параметров и производят 
свои  выходные данные в качестве результата функции.
</P>

<h3>Аргументы обычно вычисляются перед применением функции</h3> 

<P>
Когда Lisp вычисляет функцию, он всегда сначала вычисляет все аргументы, 
как мы видели <A HREF="#basic-eval">ранее</A>. К сожалению, каждое правило имеет исключения, и это правило не является исключением (как мы вскоре увидим)... 
Проблема не в том, что Lisp не всегда вычисляет аргументы функции, а в том, 
что не каждая форма списка является вызовом функции.
</P>

<h3>Аргументы вычисляются в порядке слева направо</h3> 

<P>
Когда форма списка <EM>является</EM> вызовом функции, ее аргументы всегда 
вычисляются по порядку слева направо. Как и в других языках программирования, 
полагаться на это-дурной тон, но если вы абсолютно должны полагаться 
на порядок, то хорошо знать, что Lisp определяет его для вас.
</P>

<h3>Специальные формы и макросы изменяют оценку/вычисление аргументов</h3> 

<P>
Итак, если форма списка не всегда является вызовом функции, то чем еще 
она может быть? Есть два случая, но результат один и тот же: одни аргументы 
вычисляются, а другие - нет. Вам просто придется изучить исключения. К счастью, 
большинство систем Lisp покажет вам онлайн - документацию для любой формы 
с помощью одного или двух нажатий клавиш.
</P>

<P>
Есть два вида форм, которые не вычисляют все свои аргументы: специальные формы 
и макросы. Лисп предопределяет небольшое количество специальных форм. 
Вы не можете добавить свои собственные специальные формы - эти 
примитивы являются особенностью самого языка. Lisp также определяет 
довольно много макросов. Вы также можете определить свои собственные макросы. 
Макросы в Lisp позволяют использовать всю мощь языка для добавления 
собственной функциональности. Далее в этой главе мы кратко рассмотрим, 
<A HREF="chapter03-08.html">как определить простые макросы</A>. В 
<A HREF="chapter20.html">главе 20</A> мы рассмотрим темы, связанные с 
созданием более сложных макросов.
</P>

<hr>
<div align="center">
<a href="contents.html">Contents</a> | <a href="cover.html">Cover</a> <br> 
<a href="chapter02.html">Chapter 2</a> | <A HREF="chapter03.html">Chapter 3, Introduction</A> | <A HREF="chapter03-01.html">Chapter 3, Lesson 1</A> | Chapter 3, Lesson 2 | <A HREF="chapter03-03.html">Chapter 3, Lesson 3</A> | <a href="chapter04.html">Chapter 4</a> <br>
</div>
<hr>
<address>
Copyright &copy; 1995-2001, David B. Lamkins<br>
All Rights Reserved Worldwide<br>
<br>
This book may not be reproduced without the written consent of its 
author.  Online distribution is restricted to the author's site.
</address> 
</body>
</html>