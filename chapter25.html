<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Successful Lisp - Chapter 25</title>
</head> 

<body bgcolor="white" text="black">
<h1>Глава 25-подключение Lisp к реальному миру</h1> 

<P>
Lisp предоставляет замечательную среду разработки, как мы увидим в следующих
главах. Но Lisp был бы мало полезен для некоторых приложений без возможности
доступа к внешним программам, написанным на других языках. К счастью, 
современные реализации Lisp имеют интерфейс внешних функций,
или сокращенно FFI.

<p>
В этой главе я опишу FFI в общих чертах. Реализации различаются в деталях,
поскольку FFI еще не была стандартизирована. Несмотря на отсутствие
стандартизации, современные реализации, по-видимому, сошлись на сходном 
наборе функций.

<h2>Интерфейс Внешних Функций(Foreign Function Interfaces) позволяет вам общаться с программами, написанными на	"внешних языках"</h2>

<p>
FFI позволяет вашей программе Lisp взаимодействовать с кодом, который является
"чужеродным", т. е. не Lisp. 

<blockquote>
Этот Лиспо-центрированный взгляд на мир, вероятно, созан Лисп-машинами, 
где все-даже низкоуровневые части операционной системы-были написаны на 
Лиспе. Очень многие люди, занимавшиеся Лиспом в то время, также ответственны 
за развитие современных реализаций Лиспа; следовательно, не столь тонкий 
намек на понятие Лиспа как центра вселенной программиста.
</blockquote> 

<p>
Типичный FFI предоставляет для вызовов из Lisp отдельно-скомпилированный код, 
и отдельно скомпилированного кода на Лиспе. (В последнем случае почти всегда
верно, что внешний код должен был быть вызван из Lisp; затем он может сделать
вызов обратно в Lisp.) Чаще всего FFI поддерживает соглашение о вызове C.

<h2>Немогли бы вы завернуть это, пожалуйста?</h2>

<p>
Зачем вообще нужен FFI? Почему вы не можете связать отдельно скомпилированный
код, как на любом другом языке? Основная причина заключается в том, что типы
данных Lisp обычно не имеют эквивалентов в обычных языках. Например, целые
числа C обычно заполняют (в зависимости от объявления) половину, одно или два
машинных слова и дают математически неверные результаты, когда результат
превышает репрезентативную емкость хранилища целого числа. Целое число Lisp
может поместиться в машинное слово, сохраняя несколько битов для тега типа. Они
называются fixnum. Целые числа Lisp, имеющие значения, превышающие емкость
представления одного слова, преобразуются в представление, имеющее
неограниченное число битов - это bignum(большие числа). А с помощью хорошего
компилятора можно определить подтипы целых чисел, которые, будучи упакованы в
массив, имеют ровно столько битов в своем представлении, чтобы обрабатывать
объявленный диапазон значений.

<p>
Таким образом, одной из целей FFI является перевод типов данных Lisp 
в "чужие/внешние" типы данных (и из них). Не все преобразования возможны
 - хороший FFI будет сигнализировать об ошибке, когда преобразование 
невозможно во время выполнения.

<p>
Когда не-Лисп функция принимает или возвращает значения в типе данных 
записи, FFI должен предоставить средство построения соответствующих записей. 
Как правило, FFI предоставляет вам Способ построения записей, которые 
бит в бит идентичны тем, которые были бы созданы другим языком. Поля 
внутри записи устанавливаются и извлекаются с помощью специализированных 
средств доступа Lisp.

<p>
FFI также должен поддерживать правильный протокол вызова функций для 
не-Лисп функций. Протоколы различаются по платформе и языку. Соглашения 
о вызове функций Lisp обычно отличаются от тех, которые используются 
в других языках. Lisp поддерживает необязательные, ключевые слова, 
параметры по умолчанию и rest, несколько возвращаемых значений, 
замыкания и (иногда, в зависимости от компилятора) исключение
(оптимизацию) хвостового вызова; обычно язык(Лисп) может реализовать 
исключение хвостового вызова.

<p>
Что еще должен делать FFI? Он загружает объектные файлы, созданные другими
языками, обеспечивая функциональность компоновщика в Lisp для этих объектных
файлов. Компоновщик находит и связывает имена записей в коде объектного
файла и заполняет машинные адреса в объектном коде в зависимости от того, 
куда код загружается в память.

<p>
Наконец, FFI должен разрешить различия в распределении памяти между Lisp и
другими языками. Большинство реализаций Lisp позволяют объектам перемещаться во
время работы; это повышает долгосрочную эффективность управления памятью и
может повысить производительность программы при реализации виртуальной памяти
за счет уменьшения размера рабочего набора. К сожалению, большинство других
языков ожидают, что объекты будут оставаться на фиксированном адресе памяти во
время выполнения программы. Поэтому FFI должен организовать так, чтобы внешняя
функция видела объекты Lisp, которые не перемещаются.

<p>
Вся вышеперечисленная функциональность инкапсулируется функцией-оболочкой 
FFI. Все, что вам нужно сделать, это определить имя, последовательность 
вызова и файл объектного кода некоторой внешней функции, и FFI сгенерирует
оболочку, которая выполняет все необходимые преобразования. Как только вы
сделаете это, внешняя функция может быть вызвана точно так же, как и любая 
другая функция Lisp.

<h2>Я тебе перезвоню(I'll call you back)...</h2>

<p>
Обычно внешняя функция вызывается ради ее результатов или для того, чтобы 
оказать некоторое влияние на внешнюю среду, и простая последовательность 
вызова/возврата-это все, что нужно. Но некоторые внешние функции, 
особенно те, которые имеют дело с пользовательским интерфейсом или 
устройством ввода-вывода, требуют доступа к функциям 
<em>callback/обратного вызова</em> во время их работы. Функция 
обратного вызова вызывается <em>из</em> внешней функции.

<p>
Чтобы определить функцию обратного вызова в Lisp, FFI в основном должен 
решить все проблемы внешней функции в обратном направлении. FFI 
используется для определения функции Lisp, которая может быть вызвана 
из другого языка. Результатом обычно является объект функции или 
указатель, который может быть передан (в качестве параметра) вызову 
внешней функции. Когда вызывается внешняя функция, она ссылается на 
параметр обратного вызова обычным образом, чтобы вызвать функцию 
обратного вызова Lisp. Оболочка FFI вокруг обратного вызова преобразует 
внешнюю последовательность вызовов и значения параметров в 
соответствующий формат Lisp, вызывает функцию обратного вызова Lisp 
и возвращает результаты обратного вызова после подходящего перевода 
из Lisp во внешие форматы.

<h2>Сетевые интерфейсы: за этими четыремя стенами</h2>

<p>
Хотя сетевые протоколы являются высоко стандартизированными и совместимыми,
сетевые API-интерфейсы таковыми не являются. Поставщики Common Lisp обычно
предоставляют свой собственный интерфейс для сетевого программного обеспечения
целевой платформы. Franz'S Allegro Common Lisp предоставляет простую библиотеку
сокетов для IP-сетей. Digitool'S Macintosh Common Lisp поставляется с полным
набором интерфейсов к низкоуровневым сетевым API (IP, AppleTalk и PPC) Mac OS,
а также набором примеров кода, который использует низкоуровневые вызовы для
выполнения общих сетевых задач; вы можете использовать образцы как есть или
настроить их в соответствии с вашими требованиями.

<hr>
<div align="center">
<a href="contents.html">Contents</a> | <a href="cover.html">Cover</a> <br> 
<a href="chapter24.html">Chapter 24</a> | Chapter 25 | <a href="chapter26.html">Chapter 26</a> 
</div>
<hr>
<address>
Copyright &copy; 1995-2001, David B. Lamkins<br>
All Rights Reserved Worldwide<br>
<br>
This book may not be reproduced without the written consent of its author.  Online distribution is restricted to the author's site.
</address> 
</body> </html>