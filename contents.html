<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<title>Успешный Лисп - Содержание</title>
</head> 

<body bgcolor="white" text="black">
<h1>Table of Contents</h1>

<ul>
<li><a href="author.html">О Авторе</a> 
<li><a href="about.html">О Книге</a> 
<li><a href="dedication.html">Посвящение</a> 
<li><a href="credits.html">Похвалы</a> 
<li><a href="copyright.html">Авторские права</a> 
<li><a href="acknowledgments.html">Признания</a> 
<li><a href="foreword.html">Вступительное слово</a> 
<li><a href="introduction.html">Введение</a> 

<hr>
<a href="#ch01">1</a> <a href="#ch02">2</a> <a href="#ch03">3</a> <a href="#ch04">4</a> <a href="#ch05">5</a> <a href="#ch06">6</a> <a href="#ch07">7</a> <a href="#ch08">8</a> <a href="#ch09">9</a> <a href="#ch10">10</a> <a href="#ch11">11</a> <a href="#ch12">12</a> <a href="#ch13">13</a> <a href="#ch14">14</a> <a href="#ch15">15</a> <a href="#ch16">16</a> <a href="#ch17">17</a> <a href="#ch18">18</a> <a href="#ch19">19</a> <a href="#ch20">20</a> <a href="#ch21">21</a> <a href="#ch22">22</a> <a href="#ch23">23</a> <a href="#ch24">24</a> <a href="#ch25">25</a> <a href="#ch26">26</a> <a href="#ch27">27</a> <a href="#ch28">28</a> <a href="#ch29">29</a> <a href="#ch30">30</a> <a href="#ch31">31</a> <a href="#ch32">32</a> <a href="#ch33">33</a> <a href="#ch34">34</a> <a href="#appA">Appendix A</a> 
<HR>
<a name="ch01"></a>
<li><a href="chapter01.html">Глава 1 - Зачем?  Или: Ответы на возражения</a> 

<P>Цель главы: описать наиболее распространенные возражения против Лиспа
и ответить на каждое из них в свете современных реализаций и
предварительный обзор того, что эта книга объясняет.</P>

	<ul>
	<li>Я видел Лисп раньше и не понял его.
	<li>За скобками, я не вижу программы.
	<li>Лисп очень медленный по сравнению с моим любимым языком.
	<li>Никто больше не пишет программы на Лиспе.
	<li>Лисп не позволяет мне использовать графические интерфейсы.
	<li>Я не могу вызвать код написанный другими людьми из Лиспа.
	<li>Сборщик мусора в Лиспе вызывает непредсказуемые паузы при запуске
моей программы.
	<li>Лисп это огромный язык.
	<li>Лисп только для исследований в области искуственного интеллекта.
	<li>Лисп не имеет хороших инструментов программирования.
	<li>Лисп использует слишком много памяти.
	<li>Лисп использует слишком много дискового пространства.
	<li>Я не могу найти хороший компилятор Лиспа.
	</ul>

<HR>
<a name="ch02"></a>
<li><a href="chapter02.html">Глава 2 - Эта книга для меня?</a> 

<P>Цель главы: Описать, как эта книга принесет пользу читателю, с конкретными
примерами и ссылками на содержимое глав.</P>

	<ul>
	<li><a href="track1.html">Профессиональный программист</a></li>
	<li><a href="track2.html">Студент</a></li>
	<li><a href="track3.html">Любитель</a></li>
	<li><a href="track4.html">Уже знакомый с Лиспом</a></li>
	<li><a href="track5.html">Любопытный</a></li>
	</ul> 

<HR>
<a name="ch03"></a>
<li><a href="chapter03.html">Глава 3 - Основы Лисп в 12 уроках</a> 

<P>Цель главы: Объяснить Лисп в его самой простой форме, не беспокоясь
об особых случаях, которые могут запутать начинающих.</P>

	<ul>
	<li><a href="chapter03-01.html">Урок 1 - Основной Синтаксис</a></li>
		<ul>
		<li>Списки заключаются в круглые скобки
		<li>Атомы разделяются пробелами или круглми скобками
		</ul> 
	<li><a href="chapter03-02.html">Урок 2 - Основы Выполнения</a></li>
		<ul>
		<li>Форма предназначена для выполнения
		<li>Функция применяется к своим аргументам
		<li>Функция может возвращать любое количество значений
		<li>Аргументы обычно не модифицируются функций
		<li>Аргументы обычно вычисляются перед применением функции
		<li>Аргументы вычисляются слева на право
		<li>Специальные формы и макросы изменяют вычисление аргументов
		</ul> 
	<li><a href="chapter03-03.html">Урок 3 - Некоторые примеры специальных форм и макросов</a></li>
		<ul>
		<li>SETQ
		<li>LET
		<li>COND
		<li>QUOTE
		</ul> 
	<li><a href="chapter03-04.html">Урок 4 - Собираем вещи и разбираем их</a></li>
		<ul>
		<li>CONS
		<li>LIST
		<li>FIRST и REST
		</ul> 
	<li><a href="chapter03-05.html">Урок 5 - Наименование и Идентичность</a></li>
		<ul>
		<li>Символ это просто имя
		<li>Символ всегда уникален
		<li>Символ может иметь значение
		<li>Значение может иметь больше одного имени
		</ul> 
	<li><a href="chapter03-06.html">Урок 6 - Связывание и Присваивание</a></li>
		<ul>
		<li>Привязка(Binding) создает новое место для хранения значения
		<li>У Привязок есть имена
		<li>Привязка может иметь разные значения одновременно
		<li>Одна привязка лежит глубже всех
		<li>Программа может получить доступ только к привязкам, которые она создает
		<li>Присваивание дает старому месту новое значение
		</ul> 
	<li><a href="chapter03-07.html">Урок 7 - Основы определения Функций</a></li>
		<ul>
		<li>DEFUN определяет именованные функции
		<li>LAMBDA пределяет анонимные функции
		</ul> 
	<li><a href="chapter03-08.html">Урок 8 - Основы определения Макросов</a></li>
		<ul>
		<li>DEFMACRO определяет именованный макрос
		<li>Макросы возвращают форму, а не значения
		</ul>
	<li><a href="chapter03-09.html">Урок 9 - Основы - Множественные Значения</a></li>
		<ul>
		<li>Большинство форм создают только одно значение
		<li>VALUES создает несколько (или ни одного) значений
		<li>Несколько специальных форм получают несколько значений
		<li>Некоторые формы передают несколько значений
		</ul> 
	<li><a href="chapter03-10.html">Урок 10 - Обзор других типов данных</a></li>
		<ul>
		<li>Лисп почти всегда правильно работает с числами
		<li>Символьные знаки позволяют Лиспу что либо читать и писать
		<li>Массивы организуют данные в таблицы
		<li>Векторы - это одномерные массивы
		<li>Строки - это векторы, содержащие только символьные знаки.
		<li>Символы уникальны, но имеют много значений
		<li>Структуры позволяют хранить связанные данные
		<li>Информация о типе видна во время выполнения
		<li>Хеш-таблицы обеспечивают быстрый доступ к данным по ключу поиска.
		<li>Пакты защищают от совпадения имен
		</ul> 
	<li><a href="chapter03-11.html">Урок 11 - Основы Ввода и Вывода</a></li>
		<ul>
		<li>READ позволяет получать Лиспу данные
		<li>PRINT печатает данные Лиспа для вас и для READ
		<li>OPEN и CLOSE позволяют вам работать с файлами
		<li>Вариации на тему печати - PRINT
		</ul> 
	<li><a href="chapter03-12.html">Урок 12 - Основы Макросов чтения</a></li>
		<ul>
		<li>Читатель превращает символьные знаки в данные
		<li>Стандартыне макросы чтения обрабатывают встроенные типы данных
		<li>Пользовательские программы могут определять макросы чтения
		</ul> 
	</ul> 

<HR>
<a name="ch04"></a>
<li><a href="chapter04.html">Глава 4 - Овладение Основами</a> 

<P>Цель главы: закрепить концепции главы 3 практическими упражнениями.</P>

	<ul>
	<li>Руки-вверх! "Главный(верхний) цикл"
	<li>Обнаружение и избежание распространенных ошибок
	<li>Определение простых функций
	<li>Использование глобальных переменных и констант
	<li>Определение рекурсивных функций
	<li>Хвостовая рекурсия
	<li>Упражнения по именованию
	<li>Лексическое связывание и несколько пространств имен
	<li>Чтение, запись и арифметика
	<li>Другие типы данных
	<li>Простые макросы
	<li>Макросы чтения
	</ul> 

<HR>
<a name="ch05"></a>
<li><a href="chapter05.html">Глава 5 - Введение в итерацию</a> 

<P>Цель главы: представить наиболее растространенные конструкции циклов.</P>

<blockquote>
"Нет такой вещи, как бесконечный цикл. В конце концов, компьютер сломается." -- John D. Sullivan
</blockquote> 

	<ul>
	<li>Простой LOOP вечный цикл...
	<li>Но выход есть!
	<li>Используйте DOTIMES для счетного цикла
	<li>Используйте DOLIST для обработки элементов списка
	<li>DO это сложно, но мощно
	</ul> 

<HR>
<a name="ch06"></a>
<li><a href="chapter06.html">Глава 6 - Погружение в Структуры</a> 

<P>Цель главы: показать наиболее полезные дополнительные функции структур.</P>

	<ul>
	<li>Значения по умолчанию позволяют вам, иногда, пропустить некоторые инициализаторы
	<li>Изменение Лисп способа печати ваших структур
	<li>Изменение способа хранения структур в памяти
	<li>Сокращенные имена процедур доступа к слотам
	<li>Выделение новых структур без использования аргументов ключевых слов
	<li>Определение одной структуры как расширение другой
	</ul> 

<HR>
<a name="ch07"></a>
<li><a href="chapter07.html">Глава 7 - Первый взгляд на объекты как на причудливые структуры.</a> 

<P>Цель главы: Представить объекты CLOS как инструменты для структурирования данных. 
Поведение объекта будет рассмотрено в следующей главе.
</P>

	<ul>
	<li>Иерархии: Классификация и сдерживание
	<li>Используйте DEFCLASS для определения новых объектов
	<li>Объекты имеют слоты, с большим количеством опций чем у
структур
	<li>Контроль доступа к слоту помогает сохранить честность клиентов
	<li>Переопределение метода доступа к слоту, чтобы сделать то, что клиент
не может
	<li>Определение классов с одиночным наследованием для специализации
	<li>Множественное наследование позволяет определять смешивание и
соответствие
	<li>Параметры управление инициализацией и предоставление документации
	<li>Это только начало...
	</ul> 

<HR>
<a name="ch08"></a>
<li><a href="chapter08.html">Глава 8 - Время жизни и Видимость</a> 

<P>Цель главы: Показать как время жизни и видимость влияют на значения
переменных Лисп во время выполнения. Это во многом похоже на локальные
и глобальные переменные в других языках, но специальные переменные Лиспа
меняют эту ситуацию. Эта глава также создает основу для понимания того, 
что время жизни и видимость не только для переменных.</P>

	<ul>
	<li>Все в Лиспе имеет как время жизни, так и видимость.
	<li>Время жизни: Создание, существование, затем разрушение
	<li>Видимость: видеть и быть увиденным
	<li>Технические названия: Объем/Протяженность(Extent) и Область видимости(Scope)
	<li>Действительно просты случаи: определяющие формы верхнего уровня
	<li>Область видимости(Scope) и протяженность(extent) параметров и LET переменные
	<li>Немного сложнее: специальные переменные
	</ul> 

<HR>
<a name="ch09"></a>
<li><a href="chapter09.html">Глава 9 - Введение в Обработку Ошибок и 
Не Локальные Выходы</a> 

<P>Цели главы: показать три новых способа передачи управления между частями
программы.</P>

	<ul>
	<li>UNWIND-PROTECT: когда он абсолютно, положительно должен выполняться
	<li>Милостивые выходы с BLOCK и RETURN-FROM
	<li>Побег из любого места (но не в любое время) с CATCH и THROW
	<li>Убедитесь, что файлы остаются открытыми столько, сколько нужно
	</ul> 

<HR>
<a name="ch10"></a>
<li><a href="chapter10.html">Глава 10 - Как найти свой путь 
Часть 1</a> 

<P>Цель главы: показать как найти вещи в Лиспе, не прибегая к руководству 
(документации).</P>

	<ul>
	<li>APROPOS: Я не помню имя, но узнаю по лицу
	<li>DESCRIBE: Расскажи мне больше о себе
	<li>INSPECT: Откройте шире(рот) и скажите "Ah..."
	<li>DOCUMENTATION: Я знаю, что где-то это записал
	</ul> 

<HR>
<a name="ch11"></a>
<li><a href="chapter11.html">Глава 11 - Разрушающее Изменение</a> 

<P>Цель главы: Проилюстрировать разницу между присваиванием(assignment) и
связыванием(binding) и показать, почему присваивание труднее понять. Затем
изучите причины предпочтения более сложных концепций и приведем функции,
использующие разрушающее изменение.</P>

	<ul>
	<li>Простое присваивание это разрушающее изменение
	<li>Риск присваивания
	<li>Изменение против копирования: проблема эффективности
	<li>Изменение списков с помощью разрушающих функций
	<li>RPLACA, RPLACD, SETF ...; (округлость?)circularity
	<li>Место против значения: разрушающие функции не всегда имеют
            желаемый побочный эффект
	<li>Разница/контраст, например между PUSH и DELETE
	<li>Разделяемые(Shared) и постоянные(constant) данные: Опасность
разрушающих изменений
	</ul> 

<HR>
<a name="ch12"></a>
<li><a href="chapter12.html">Глава 12 - Отображение(Mapping) вместо Итерации</a> 

<P>Цель главы: классифицировать и продемонстрировать функции отображения.
Показать подходящее и неуместное использование. Ввести понятие 
последовательности(sequence).</P>

	<ul>
	<li>MAPCAR, MAPC, и MAPCAN обрабатывают последовательные элементы списка
	<li>MAPLIST, MAPL, и MAPCON обрабатывают последовательные подсписки
	<li>MAP и MAP-INTO работают с последовательностями, а не только со списками
	<li>Функции отображения хороши для фильтрации
	<li>Лучше избегать отображения, если вы заботитесь об эффективности
	<li>Проверка последовательностей с помощью функций отображения предикатов
	<li>SOME, EVERY, NOTANY, NOTEVERY
	<li>REDUCE объединяет элементы последовательности
	</ul> 

<HR>
<a name="ch13"></a>
<li><a href="chapter13.html">Глава 13 - Еще больше вещей, которые вы можете
сделать с последовательностями(Sequences)</a> 

<P>Цель главы: Представить наиболее полезные функции работающие с последовательностями,
и показать как их использовать. Показать как должны использоваться разрушающие функции
работающие с последовательностями для достижения желаемого эффекта.</P>

	<ul>
	<li>CONCATENATE: новая последовательность из старых
	<li>ELT и SUBSEQ получают то что вы хотите из любой последовательности (также см., COPY-SEQ)
	<li>REVERSE переворачивает последовательность с начала в конец (см. также, NREVERSE)
	<li>LENGTH: в конце концов, размер имеет значение
	<li>COUNT: когда важно, что находится внутри
	<li>REMOVE, SUBSTITUTE, и другие модификаторы последовательностей
	<li>DELETE, REMOVE-DUPLICATES, DELETE-DUPLICATES, и NSUBSTITUTE
        <li>FILL и REPLACE
	<li>Обнаружение вещей в последовательностях: POSITION, FIND, SEARCH, и MISMATCH
	<li>SORT и MERGE завершают набор инструментов работающих с последовательностями
	</ul> 

<HR>
<a name="ch14"></a>
<li><a href="chapter14.html">Глава 14 - Могут ли объекты иметь собственное 
поведение?</a> 

<P>Цель главы: Показать, как работают обобщенные функции. Описать множественную
диспетчеризацию, наследование и комбинацию методов. Предварительный обзор
метаобъектного протокола.</P>

	<ul>
	<li>Обобщенные функции дают объектам их поведение
	<li>Граница между методами и объектами размывается для мультиметодов
	<li>Методы на не объектах?  Так где же живет этот метод?
	<li>Обобщенные функции работают путем диспетчеризации по указанным аргументам
	<li>В конце концов наследование объектов имеет значение; поиск подходящих методов
	<li>Комбинации методов предлагают дополнительные варианты выбора
	<li>Ничто не выбито на камне; Взгляд на метаобъектный протокол
	</ul> 

<HR>
<a name="ch15"></a>
<li><a href="chapter15.html">Глава 15 - Замыкания</a> 

<P>Цель главы: Показать, как замыкания захватывают свободные переменные для
использования в других контекстах выполнения. Продемонстрировать некоторые 
практические применения.</P>

	<ul>
	<li>Является ли это функцией с временем жизни, или временем жизни функции?
	<li>Как определить свободную переменную и что с ней делать.
	<li>Использование замыканий для хранения конфиденциальной информации.
	<li>Функции, которые возвращают функции и чем они отличаются от макросов.
	</ul> 

<HR>
<a name="ch16"></a>
<li><a href="chapter16.html">Глава 16 - Как найти обходной путь, часть 2
</a> 

<P>Цель главы: узнать, что компилятор Лисп делает с вашим кодом, и как посмотреть, что ваш код делает во время выполнения.</P>

<blockquote>
"DISASSEMBLE это ваш друг." -- Bill St. Clair
</blockquote> 

	<ul>
	<li>DISASSEMBLE: Мне всегда было интересно, что они вкладывают в эти вещи...
	<li>BREAK и backtrace: как я попал сюда?
	<li>TRACE и STEP: Я слежу за тобой!
	</ul> 

<HR>
<a name="ch17"></a>
<li><a href="chapter17.html">Глава 17 - Не все сравнения Одинаковы(Equal)</a> 

<P>Цель главы: рассказать как и почему в Лисп так много разных функций сравнения.
Дать указания для правильного выбора.</P>

	<ul>
	<li>Чем дольше тест, тем больше он вам скажет
	<li>EQ истинен для идентичных символов
	<li>EQL также истенен для одинаковых чисел и символьных знаков
	<li>EQUAL обычно истинно для вещей, которые печатаются одинаково
	<li>EQUALP игнрорирует тип числа и регистр символов
	<li>Более длинные тесты медленне; надо знать что вы сравниваете
	<li>Специализированные тесты работают быстрее на более ограниченных типах данных
	</ul>

<HR>
<a name="ch18"></a>
<li><a href="chapter18.html">Глава 18 - Действительно, Очень Логично...</a> 

<P>Цель главы: описать общие логические функции и условные конструкции выполнения. Ввести функции управления битами, битовыми векторами и обобщенным управлением байтами.</P>

	<ul>
	<li>Исполнение AND и OR, только столько, сколько им нужно
	<li>Биты(Bits), байты(bytes), и Логические значения(Boole)
	<li>Битовые векторы могут продолжаться вечно
	<li>Куски(Chunks) битов создают байты
	</ul> 

<HR>
<a name="ch19"></a>
<li><a href="chapter19.html">Глава 19 - Потоки</a> 

<P>Цель главы: Представить потоки как обобщенные средства ввода/вывода. 
Подчеркнуть взаимозаменяемость потоков, подключенных к различным устройствам.
</P>

	<ul>
	<li>Потоки предоставляют канал для подачи и приема данных
	<li>Создание потоков на файлах
	<li>Создание потоков на строках
	<li>Двоичный Ввод/Вывод
	</ul> 

<HR>
<a name="ch20"></a>
<li><a href="chapter20.html">Глава 20 - Этикет(свод правил правильных действий) Макросов</a> 

<P>Цель главы: Выйти за рамки проостых примеров глав 3 и 4, чтобы показать,
как правильно конструировать макросы для решения широкого круга задач.</P>

	<ul>
	<li>Макросы это программы, которые генерируют программы
	<li>Крупным планом: как работают макросы
	<li>Цитирование(Backquote) обратной кавычкой выглядит как шаблон подстановки
	<li>Помимо очевидного, часть 1: вычислить, а затем сгенерировать
	<li>Помимо очевидного, часть 2: макросы, которые определяют макросы
	<li>Хитрости торговли: избежать захвата с помощью исопользования GENSYM
	<li>Макросы против встраивания(inlining)
	</ul> 

<HR>
<a name="ch21"></a>
<li><a href="chapter21.html">Глава 21 - Необычные трюки с аргументами функций и
макросов</a> 

<P>Цель главы: описать список параметров лямбды. Показать, как их можно использовать
для увеличения ясности программ.</P>

	<ul>
	<li>Ключевые слова позволяют именовать ваши параметры
	<li>Значения по умолчанию, когда вы не хотите говорить
	<li>Добавьте некоторую структуру в ваши макросы, разбирая аргументы
	</ul> 

<HR>
<a name="ch22"></a>
<li><a href="chapter22.html">Глава 22 - Как найти обходной путь, Часть 3</a> 

<P>Цель главы: Научиться как узнавать об объектах и методах. Изучить
специализированные методы для изменения и мониторинга поведения программы без 
изменения исходного кода.</P>

	<ul>
	<li>Просмотрщики классов и методов помогут вам найти дорогу в море объектов	
	<li>ADVISE позволяет вам изменять повдение функции без изменения функции
	<li>WATCH позволяет вам открыть окно с интересными переменными
	</ul> 

<HR>
<a name="ch23"></a>
<li><a href="chapter23.html">Глава 23 - Совершать ошибки это ожидаемо; Восстановление, 
Божественно</a> 

<P>Цель главы: Показать как создать собственные механизмы обнаружения 
ошибок и восстановления.</P>

	<ul>
	<li>Сообщите о своих ошибках и впечатлите своих пользователей
	<li>Классифицируйта ошибки, используя условия(Conditions)
	<li>Восстановление из условий(Conditions) с помощью перезагрузки(Restarts)
	</ul> 

<HR>
<a name="ch24"></a>
<li><a href="chapter24.html">Глава 24 - FORMAT Говорит на другом языке</a> 

<P>Цель главы: Описать наиболее полезные функции(свойства) функции FORMAT.
</P>

	<ul>
	<li>FORMAT рифмуется с FORTRAN, вроде как...
	<li>Форматирование
	<li>Итерация
	<li>Условия(Conditionals)
	<li>Мутная пыль(Floobydust)
	</ul> 

<HR>
<a name="ch25"></a>
<li><a href="chapter25.html">Глава 25 - Соединение с Лиспа с Реальным Миром</a> 

<P>Цель главы: Описать в целом FFI, и привести примеры из реальных реализаций.
Показать как использовать обертки(wrappers) для вызова функций Си++. 
Показать как обратные вызовы позволяют программам на Си вызывать функции Лиспа.
Приведем пример использования доступа по TCP/IP.</P>

	<ul>
	<li>Интерфейс Внешних Функций(Foreign Function Interfaces) позволяет вам общаться с программами, написанными на	"внешних языках"
	<li>Немогли бы вы завернуть это, пожалуйста?
	<li>Я тебе перезвоню(I'll call you back)...
	<li>Сетевые интерфейсы: за этими четыремя стенами
	</ul> 

<HR>
<a name="ch26"></a>
<li><a href="chapter26.html">Глава 26 - Надеть счастливое лицо(счастливый интерфейс): Построители Интерфейса</a> 

<P>Цель главы: обсудить управляемые событиями интерфейсы и построители GUI
в целом, а затем показать примеры из основных настольных платформ Common Lisp. 
Завершим обсуждение независимыми от платформы GUI Лисп, такими как 
Garnet и CLIM.</P>

	<ul>
	<li>Управляемые событиями интерфейсы(Event-driven)
	<li>Программирование графики
	<li>Пример: Инструментарий интерфейсов MCL
	<li>Платформо независимые интерфейсы
	</ul> 

<HR>
<a name="ch27"></a>
<li><a href="chapter27.html">Глава 27 - Хороший Редактор стоит тысячи
нажатий клавиш</a> 

<P>Цель главы: Показать как простой синтаксис Лисп сочетается с встроенным
редактором, чтобы облегчить многие общие задачи написания программы на Лисп.
</P>

	<ul>
	<li>Простой синтаксис; умные редакторы
	<li>Соответствие и мигание(flashing)
	<li>Автоматический отступ
	<li>Завершение символов
	<li>Поиск определений
	<li>Онлайн документация
	<li>Доступ к инструментам отладки
	<li>Расширение редактора с помощью Лиспа
	</ul> 

<HR>
<a name="ch28"></a>
<li><a href="chapter28.html">Глава 28 - Практические приемы программирования</a> 

<P>Цель главы: Предоставить полезные рекомендации по стилю Lisp. Дать
практические советы по компромисам между отладкой, производительностью и
читаемостью.</P>

	<ul>
	<li>Элементы стиля Лисп
	<li>Списки свойств удобны для не больших (очень маленьких) баз данных
	<li>Объявления помогают компилятору, иногда
	<li>DEFVAR против DEFPARAMETER
	<li>Определяйте константы с помощью DEFCONSTANT
	<li>Знайте когда (не) использовать компилятор
	<li>Скорость против способности к отладке
	<li>Эффективность: обнаружить, проверить
	<li>Признавая не эффективность, профилирование; производительность против читаемости
	</ul> 

<HR>
<a name="ch29"></a>
<li><a href="chapter29.html">Глава 29 - Я думал, что теперь твоя очередь выносить
мусор</a> 

<P>Цель главы: описать преимущества и затраты на сборку мусора. 
Показать, как повысить производительность программы за счет уменьшения
количества мусора, который она генерирует.</P>

	<ul>
	<li>Что такое мусор?
	<li>Почему важен сбор мусора?
	<li>Как работает сборка мусора?
	<li>Какое влияние оказывает мусор на мою программу?
	<li>Как я могу уменьшить паузы сбора мусора в моей программе?
	</ul> 

<HR>
<a name="ch30"></a>
<li><a href="chapter30.html">Глава 30 - Полезные советы по отладке и проверке
ошибок</a> 

<P>Цель главы: Описать использование инструментов отладки Лисп.</P>

	<ul>
	<li>Поиск причины ошибки
	<li>Чтение трассы вызовов(backtraces), настройки компилятора для
отладки
	<li>Простые инструменты отладки
	<li>BREAK, PRINT
	<li>Мощные инструменты для трудных задач
	<li>TRACE, STEP, ADVISE, WATCH
	<li>Прямо в брюхо зверя
	<li>INSPECT, DESCRIBE
	<li>Продолжая с ошибками
	<li>Проблемы с нежелательными определениями
	<li>Проблемы в пакетах; определения методов
	<li>Проблемы с макросами
	<li>Проверки времени выполнения ловят "случаи которых не может быть" когда они
порисходят...
	<li>Используйте диспечеризацию метдов, а не условную диспетчеризацию(case dispatch)
	</ul> 

<HR>
<a name="ch31"></a>
<li><a href="chapter31.html">Глава 31 - Обработка больших проектов на 
Lisp</a> 

<P>Цель главы: Описать стратегии и инструменты, используемые для организации
программ на Лиспе для крупных проектов и коллективной работы.</P>

	<ul>
	<li>Пакеты хранят ваши и имена отдельно от моих имен
	<li>Сборщики систем позволяют описывать зависимости
	<li>Системы контроля версий отслеживают множество ревизий
	<li>Модули: еще один способ описания файловых зависимостей
	<li>PROVIDE и REQUIRE
	</ul> 

<HR>
<a name="ch32"></a>
<li><a href="chapter32.html">Глава 32 - Темные закоулки и Диковинки</a> 

<P>Цель главы: Описать некоторые функции Лисп, которые являются новыми, нестандартными, эксперементальными или противоречивыми.</P>

	<ul>
	<li>Расширенный LOOP: еще один маленький язык
	<li>TAGBODY: GO если нужно
	<li>Процессы и стековые группы: Манипулирование несколькими задачами
	<li>Последовательности: Еще один подход к итерации и фильтрации
	</ul> 

<HR>
<a name="ch33"></a>
<li><a href="chapter33.html">Глава 33 - Куда двигаться дальше</a> 

<P>Цель главы: Предоставить указатели на другие источники информации и продукты.</P>

	<ul>
	<li>Предложения для дальнейшего чтения
	<li>Интернет источники
	<li>Коммерческие поставщики
	</ul> 

<HR>
<a name="ch34"></a>
<li><a href="chapter34.html">Глава 34 - История Лиспа, или: Истоки
недоразумений</a> 

<P>Цель главы: Дать краткую историю развития Лисп, предоставив понимание некоторых давних заблуждений.</P>

	<ul>
	<li>Запись Джона Маккарти(John McCarthy)
	<li>Самые ранние реализации
	<li>Специальное оборудование
	<li>Расхождения диалектов
	<li>Директива DARPA
	<li>Восток против Запада и европейская конкуренция
	<li>Появление компиляторов для стандартного оборудования
	<li>Долгий путь к стандартизации
	<li>Уровень развития?
	</ul> 

<HR>
<a name="appA"></a>
<li><a href="appendix-a.html">Приложение A - Успешные приложения на Лисп</a> 

<P>Цель главы: Описать большие успешные приложения, созданные на Лиспе.</P>

	<ul>
	<li>Emacs
	<li>G2
	<li>AutoCad
        <li>Igor Engraver
        <li>Yahoo Store
	<li>...
	</ul> 
</ul> 

<hr>
<div align="center">
<a href="cover.html">Cover</a> <br> <a href="author.html">About the Author</a> 
</div>
<hr>
<address>
Copyright &copy; 1995-2001, David B. Lamkins<br>
All Rights Reserved Worldwide<br>
<br>
This book may not be reproduced without the written consent of its 
author.  Online distribution is restricted to the author's site.
</address>
</body> </html>