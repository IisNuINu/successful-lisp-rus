#
# NuINu <don't@send.my>, 2020.
#
#. extracted from in/chapter28.html
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-04-19 13:51+0300\n"
"PO-Revision-Date: 2020-06-12 20:01+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter28.html:5
msgid ""
"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/"
"html4/strict.dtd\">\n"
"<html><head>\n"
"<title>Successful Lisp - Chapter 28</title>\n"
"</head> "
msgstr ""
"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/"
"html4/strict.dtd\">\n"
"<html><head>\n"
"<META http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n"
"<title>Successful Lisp - Chapter 28</title>\n"
"</head> "

#: in/chapter28.html:8
msgid ""
"<body bgcolor=\"white\" text=\"black\">\n"
"<h1>Chapter 28 - Practical Techniques for Programming</h1> "
msgstr ""
"<body bgcolor=\"white\" text=\"black\">\n"
"<h1>Глава 28 - Практические приемы программирования</h1> "

#: in/chapter28.html:12
msgid ""
"<P>In this chapter, we'll learn some brief yet useful guidelines for\n"
"Lisp style, followed by practical advice on tradeoffs among\n"
"debugging, performance, and readability.</P>"
msgstr ""
"<P>\n"
"В этой главе мы изучим некоторые краткие, но полезные рекомендации по \n"
"стилю Lisp, а затем дадим практические советы по компромиссам между \n"
"отладкой, производительностью и удобочитаемостью.\n"
"</P>"

#: in/chapter28.html:14
msgid "<h2>Elements of Lisp style</h2>"
msgstr "<h2>Элементы стиля Лисп</h2>"

#: in/chapter28.html:22
msgid ""
"<p>The art of Lisp style is simpler and more fruitful than in most other\n"
"languages.  Lisp's simple, consistent syntax eliminates the need for the\n"
"rules of style that plague more complicated languages.  And the direct,\n"
"standardized availability of complex functionality within Lisp helps to\n"
"drive down the size of programs, thereby providing improved readability\n"
"through brevity.  (In my experience, a Lisp program may range in size\n"
"from 5 percent to 20 percent of an equivalent C++ program.)"
msgstr ""
"<p>\n"
"Искусство Лисп стиля проще и плодотворнее, чем в большинстве других "
"языков. \n"
"Простой, последовательный синтаксис Lisp устраняет необходимость в "
"правилах \n"
"стиля, которые мешают более сложным языкам. А прямая стандартизированная \n"
"доступность сложных функциональных возможностей в рамках Lisp помогает \n"
"уменьшить размер программ, тем самым обеспечивая улучшенную читаемость \n"
"за счет краткости. (По моему опыту, размер Лисп-программы может \n"
"варьироваться от 5 до 20 процентов от размера эквивалентной программы \n"
"на языке C++.)"

#: in/chapter28.html:30
msgid ""
"<p>Furthermore, the universal availability of Lisp-aware program editing\n"
"tools -- such as Emacs or its equivalent built into many Lisp IDEs --\n"
"means that you can let the computer handle the details of indentation \n"
"that are so important to the ability of a person to comprehend the\n"
"structure of a Lisp program.  I've said this before, but it bears \n"
"repeating: you should <em>not</em> be programming in Lisp without the\n"
"aid of a Lisp-aware editor."
msgstr ""
"<p>\n"
"Кроме того, универсальная доступность инструментов редактирования программ \n"
"с поддержкой Lisp, таких как Emacs или его эквивалент, встроенный во "
"многие \n"
"идентификаторы Lisp, означает, что вы можете позволить компьютеру "
"обрабатывать \n"
"детали отступов, которые так важны для способности человека понять "
"структуру \n"
"программы Lisp. Я уже говорил это раньше,но стоит повторить: вы не должны \n"
"программировать на Лиспе без помощи редактора, знающего Лисп."

#: in/chapter28.html:39
msgid ""
"<p>So, if we don't have to worry about conventions for spelling,\n"
"capitalization, indentation, and other such mundane details, then\n"
"what remains for us to discuss as elements of Lisp style? How about\n"
"things that are truly important? Lisp programming style is about the\n"
"choice of proper abstractions, and about communicating not just with\n"
"the compiler, but with other people who will eventually read your\n"
"program. (For that matter, good style will help you read your own\n"
"program some months or years in the future.)"
msgstr ""
"<p>\n"
"Итак, если нам не нужно беспокоиться о условностях написания, заглавных \n"
"буквах, отступах и других таких обыденных деталях, то что же нам остается \n"
"обсуждать про элементы стиля Lisp? А как насчет того, что действительно \n"
"важно? Стиль программирования Lisp - это выбор правильных абстракций и \n"
"общение не только с компилятором, но и с другими людьми, которые в \n"
"конечном итоге прочитают вашу программу. (Если уж на то пошло, хороший \n"
"стиль поможет вам прочитать вашу собственную программу через несколько \n"
"месяцев или лет в будущем.)"

#: in/chapter28.html:41
msgid ""
"<h2>Property lists are handy for small (very small) ad-hoc databases</h2>"
msgstr ""
"<h2>Списки свойств удобны для небольших (очень маленьких) специальных баз "
"данных</h2>"

#: in/chapter28.html:51
msgid ""
"<p>A long, long time ago the capabilities of a typical Lisp\n"
"implementation were very much less than what you'll find in any\n"
"Common Lisp system today. After all, Lisp has been around for over\n"
"forty years since John McCarthy first invented the notations (see <a\n"
"href=\"chapter34.html\">Chapter 34</a>). Strangely, when Lisp is\n"
"taught at all in computer science curricula, it is taught using a\n"
"circa-1965 view of the state of Lisp implementations: interpreted\n"
"execution, limited data structures, and no real application beyond\n"
"the manipulation of symbols."
msgstr ""
"<p>\n"
"Давным-давно возможности типичной реализации Lisp были намного меньше, \n"
"чем то, что вы найдете в любой обычной системе Lisp сегодня. В конце \n"
"концов, Лисп существует уже более сорока лет, с тех пор как Джон Маккарти \n"
"впервые изобрел эти обозначения (см. <a href=\"chapter34.html\">Главу 34</"
"a>). \n"
"Как ни странно, когда Лисп вообще преподается в учебных программах по \n"
"информатике, он преподается с использованием представления о состоянии \n"
"реализаций Лиспа примерно в 1965 году: интерпретируемое выполнение, \n"
"ограниченные структуры данных и отсутствие реального применения, кроме \n"
"манипулирования символами."

#: in/chapter28.html:56
msgid ""
"<p>Unfortunately, authors and publishers of Lisp textbooks did\n"
"little to help correct these misperceptions, ignoring Common Lisp\n"
"(and indeed, many of its recent forebears) in highly-recommened\n"
"Lisp textbooks published as recently as 1989."
msgstr ""
"<p>\n"
"К сожалению, авторы и издатели учебников по Лиспу мало что сделали, \n"
"чтобы исправить эти ошибочные представления, игнорируя Common Lisp \n"
"(и действительно, многие из его недавних предшественников) в настоятельно\n"
"рекомендованных учебниках по Лиспу, опубликованных совсем недавно, в \n"
"1989 году."

#: in/chapter28.html:63
msgid ""
"<p>In the bad old days -- when Lisp didn't have arrays, vectors, hash \n"
"tables, structures, or CLOS -- programmers learned to rely heavily on\n"
"property lists as an important mechanism for structuring data.  You'll\n"
"still find -- in bookstores and on the shelves of college libraries --\n"
"Lisp and AI books that recommend the use of property lists as the \n"
"underlying basis for looking up values identified by a symbolic key."
msgstr ""
"<p>\n"
"В старые недобрые времена -- когда в Lisp не было массивов, векторов, \n"
"хэш-таблиц, структур или CLOS -- программисты научились в значительной \n"
"степени полагаться на списки свойств(property lists) как на важный механизм\n"
"структурирования данных. Вы все еще найдете -- в книжных магазинах и на "
"полках\n"
"университетских библиотек -- книги Lisp и AI, которые рекомендуют "
"использовать \n"
"списки свойств в качестве базовой основы для поиска значений, "
"идентифицируемых\n"
"символическим ключом.\n"

#: in/chapter28.html:67
msgid ""
"<p>A property list is a list of alternating keys and values.  For example:\n"
"the list <code>(SEX MALE PARENTS (BOB JANE) OCCUPATION MUSICIAN)</code> \n"
"establishes these relations:"
msgstr ""
"<p>\n"
"Список свойств - это список чередующихся ключей и значений. Например: \n"
"список <code>(SEX MALE PARENTS (BOB JANE) OCCUPATION MUSICIAN)</code> \n"
"устанавливает эти отношения:"

#: in/chapter28.html:75
msgid ""
"<pre>\n"
"relation   value\n"
"---------- ----------\n"
"sex        male\n"
"parents    (bob jane)\n"
"occupation musician\n"
"</pre> "
msgstr ""

#: in/chapter28.html:80
msgid ""
"When you attach these relations to a symbol, say <code>JAMES</code>,\n"
"then you have a way to get information related to the symbol\n"
"<code>JAMES</code>, namely the properties having the names\n"
"<code>SEX</code>, <code>PARENTS</code>, and <code>OCCUPATION</code>."
msgstr ""
"Когда вы прикрепляете эти отношения к символу, скажем <code>JAMES</code>, \n"
"тогда у вас есть способ получить информацию, связанную с символом "
"code>JAMES</code>,\n"
"а именно свойства, имеющие имена пол(<code>SEX</code>), "
"родители(<code>PARENTS</code>)\n"
" и род занятий(<code>OCCUPATION</code>)"

#: in/chapter28.html:86
msgid ""
"<p>In Common Lisp you can retrieve a symbol's property using\n"
"<code>(GET</code> <i>symbol</i> <i>property-name</i><code>)</code>,\n"
"and set a property using <code>(SETF (GET</code> <i>symbol</i>\n"
"<code>property-name</code><code>)</code>\n"
"<i>property-value</i><code>)</code>. "
msgstr ""
"<p>\n"
"В Common Lisp вы можете получить значение свойства символа через \n"
"<code>(GET</code> <i>symbol</i> <i>property-name</i><code>)</code>\n"
"и установить значение свойства, используя <code>(SETF (GET</code> <i>symbol</"
"i>\n"
"<code>property-name</code><code>)</code> <i>property-value</i><code>)</"
"code>. "

#: in/chapter28.html:99
msgid ""
"<p>While property lists were useful substitutes for more capable\n"
"data structures in ancient Lisp implementations, they find few uses\n"
"in modern Lisp programs. One problem is efficiency. Every time you\n"
"ask Lisp to retrieve a property value, it must locate the symbol's\n"
"property list and then search the list for a matching key. If you\n"
"have five or six properties on a symbol, the search may or may not\n"
"be faster than using a hash table; the exact crossover point will\n"
"depend upon your particular Lisp implementation. The other problem\n"
"is that properties are shared among all parts of your program. It's\n"
"not too difficult to imagine two programmers using a property named\n"
"<code>COLOR</code> in two different ways in two parts of the same\n"
"program. Imagine their surprise when they discover the conflict..."
msgstr ""
"<p>\n"
"На то время  списки свойств были полезными заменителями более эффективных \n"
"структур данных в древних реализациях Lisp, они находят мало применения \n"
"в современных программах Lisp. Одна из проблем - это эффективность. Каждый "
"раз, \n"
"когда вы просите Lisp получить значение свойства, он должен найти список \n"
"свойств символа, а затем выполнить поиск в списке соответствующего ключа. \n"
"Если у вас есть пять или шесть свойств для символа, поиск может быть или \n"
"не быть быстрее, чем с помощью хэш-таблицы; точная точка пересечения будет \n"
"зависеть от вашей конкретной реализации Lisp. Другая проблема заключается \n"
"в том, что свойства являются общими для всех частей вашей программы. \n"
"Нетрудно представить себе двух программистов, использующих свойство "
"<code>COLOR</code>\n"
"двумя разными способами в двух частях одной и той же программы. "
"Представьте \n"
"себе их удивление, когда они обнаружат конфликт..."

#: in/chapter28.html:104
msgid ""
"<p>At any rate, you should become familiar with all of the\n"
"capabilities of Common Lisp, and learn to recognize that information\n"
"about older Lisp implementation which still haunts us through the\n"
"mists of history."
msgstr ""
"<p>\n"
"Во всяком случае, вы должны ознакомиться со всеми возможностями Common Lisp "
"и \n"
"научиться распознавать ту информацию о более старой реализации Lisp, "
"которая \n"
"все еще преследует нас сквозь туманы истории.\n"
"\n"

#: in/chapter28.html:106
msgid "<h2>Declarations help the compiler, sometimes</h2>"
msgstr "<h2>Объявления помогают компилятору, иногда</h2>"

#: in/chapter28.html:108
msgid "<p>Common Lisp defines the following declarations:"
msgstr "<p>Common Lisp определяет следующие объявления:"

#: in/chapter28.html:140
msgid ""
"<dl>\n"
"<dt>special\n"
"<dd>declares a variable to have dynamic (not lexical) scope\n"
"<dt>optimize\n"
"<dd>instructs the compiler how to weight the relative importance of\n"
" <ul>\n"
"  <li>speed\n"
"  <li>safety\n"
"  <li>space\n"
"  <li>debug\n"
"  <li>compilation-speed\n"
" </ul> \n"
"<dt>dynamic-extent\n"
"<dd>declares that the programmer expects the lifetime of a function\n"
"    or variable to end when control leaves the enclosing form\n"
"<dt>type\n"
"<dd>declares that a variable will always have values of a given type\n"
"<dt>ftype\n"
"<dd>declares that a function should expect arguments of specified\n"
"    types, and that the function will return values or given types\n"
"<dt>ignore\n"
"<dd>declares that a variable is not referenced\n"
"<dt>ignorable\n"
"<dd>declares that a variable may not be referenced\n"
"<dt>inline\n"
"<dd>declares that the programmer would like a function to\n"
"    be compiled as inline code\n"
"<dt>notinline\n"
"<dd>declares that the programmer does not want a function to\n"
"    be compiled as inline code\n"
"</dl> "
msgstr ""
"<dl>\n"
"<dt>special\n"
"<dd>объявляет переменную с динамической (не лексической) областью видимости\n"
"<dt>optimize\n"
"<dd>Инструктирует компилятор, как взвешивать относительную важность\n"
" <ul>\n"
"  <li>speed\n"
"  <li>safety\n"
"  <li>space\n"
"  <li>debug\n"
"  <li>compilation-speed\n"
" </ul> \n"
"<dt>dynamic-extent\n"
"<dd>объявляет, что программист ожидает, что время жизни функции или \n"
"    переменной закончится, когда управление покинет заключающую форму\n"
"<dt>type\n"
"<dd>dобъявляет, что переменная всегда будет иметь значения заданного типа\n"
"<dt>ftype\n"
"<dd>объявляет, что функция должна ожидать аргументы указанных типов и что \n"
"    функция будет возвращать значения или заданные типы\n"
"<dt>ignore\n"
"<dd>объявляет, что на переменную не ссылаются\n"
"<dt>ignorable\n"
"<dd>объявляет, что на переменную нельзя ссылаться\n"
"<dt>inline\n"
"<dd>объявляет, что программист хотел бы, чтобы функция была скомпилирована "
"как \n"
"встроенный код\n"
"<dt>notinline\n"
"<dd>объявляет, что программист не хочет, чтобы функция компилировалась как \n"
"встроенный код\n"
"</dl> "

#: in/chapter28.html:147
msgid ""
"<p>Of these, only the first and last <em>must</em> be implemented.\n"
"The rest are advisory; depending upon the implementation, the\n"
"compiler may or may not honor the given advice. If you've programmed\n"
"in other languages, you may find it strange that most of Lisp's\n"
"declarations are advisory rather than mandatory. So let's dig a bit\n"
"deeper and see what this really means to you."
msgstr ""
"<p>\n"
"Из них только первое и последнее должно быть реализовано. Остальные \n"
"рекомендации носят рекомендательный характер; в зависимости от реализации \n"
"компилятор может выполнять или не выполнять данный совет. Если вы \n"
"программировали на других языках, вам может показаться странным, \n"
"что большинство объявлений Lisp носят рекомендательный, а не \n"
"обязательный характер. Поэтому давайте копнем немного глубже \n"
"и посмотрим, что это действительно значит для вас."

#: in/chapter28.html:155
msgid ""
"<p>Lisp by default must have the <em>capability</em> to determine\n"
"the type of every variable at runtime. This is not to say that a\n"
"sufficiently smart compiler can't infer at compile time that a\n"
"variable will always be of a particular type and generate code that\n"
"does not need to check types at run time. However, an actual\n"
"\"sufficiently smart compiler\" remains an elusive creature, much like\n"
"the Yeti, Bigfoot and the Loch Ness Monster."
msgstr ""
"<p>\n"
"Lisp по умолчанию должен иметь возможность определять тип каждой \n"
"переменной во время выполнения. Это не означает, что достаточно \n"
"умный компилятор не может сделать вывод во время компиляции, что \n"
"переменная всегда будет иметь определенный тип и генерировать код, \n"
"который не нуждается в проверке типов во время выполнения. Однако\n"
" настоящий \"достаточно умный компилятор\" остается неуловимым существом, \n"
"очень похожим на Йети, снежного человека и Лох-Несское чудовище."

#: in/chapter28.html:161
msgid ""
"<p>Declarations allow the programmer to pass metainformation to the\n"
"compiler. This is not part of the program, but rather information\n"
"<em>about</em> the program. Declarations can help the compiler to\n"
"generate better code by providing information about the programmer's\n"
"<em>intent</em>. "
msgstr ""
"<p>\n"
"Объявления позволяют программисту передавать компилятору метаинформацию. \n"
"Это не часть программы, а скорее информация о программе. Объявления могут \n"
"помочь компилятору создать лучший код, предоставляя информацию о \n"
"намерениях программиста."

#: in/chapter28.html:173
msgid ""
"<p>For example, if you declare that a variable will always be a\n"
"<code>FIXNUM</code> (an integer value that fits in a single machine\n"
"word) then the compiler can emit code to load that variable directly\n"
"into a register in preparation for the next operation. If you\n"
"declare the result of the operation to also be a\n"
"<code>FIXNUM</code>, then the compiler can generate code to perform\n"
"the operation and store the result using simple machine instructions\n"
"without first checking the <code>actual</code> type of the value.\n"
"Given such declarations, a good Lisp compiler can generate code\n"
"comparable to a low-level language in which operations and types in\n"
"the language map directly onto the underlying machine."
msgstr ""
"<p>\n"
"Например, если вы объявите, что переменная всегда будет <code>FIXNUM</code>\n"
"(целочисленное значение, которое помещается в одно машинное слово), \n"
"то компилятор может выдать код для загрузки этой переменной "
"непосредственно \n"
"в регистр при подготовке к следующей операции. Если вы объявите результат \n"
"операции также фиксированным числом, то компилятор может сгенерировать \n"
"код для выполнения операции и сохранить результат, используя простые \n"
"машинные инструкции, без предварительной проверки фактического(<code>actual</"
"code>)\n"
"типа значения. Учитывая такие объявления, хороший компилятор Lisp может \n"
"генерировать код, сравнимый с низкоуровневым языком, в котором операции и \n"
"типы в языке сопоставляются непосредственно с базовой машиной."

#: in/chapter28.html:180
msgid ""
"<p>But there's a risk. If you declare certain types, and the\n"
"compiler emits code that optimizes the program according to your\n"
"declarations, and the program then <em>contradicts</em> those\n"
"declarations by providing a value of a different type at runtime,\n"
"then bad things will happen. Tell the compiler to expect two numbers\n"
"to add, then pass it a number and a symbol, and all bets are off."
msgstr ""
"<p>\n"
"Но тут есть определенный риск. Если вы объявляете определенные типы, \n"
"и компилятор выдает код, который оптимизирует программу в соответствии \n"
"с вашими объявлениями, а затем программа противоречит этим объявлениям, \n"
"предоставляя значение другого типа во время выполнения, то  будут "
"происходить\n"
"плохие вещи. Скажите компилятору, чтобы он ожидал сложения двух чисел, \n"
"затем передайте ему число и символ, и вас ждет крах."

#: in/chapter28.html:193
msgid ""
"<p>Fortunately, the declarations that guide the compiler are\n"
"themselves moderated by the <code>OPTIMIZE</code> declaration. The\n"
"<code>OPTIMIZE</code> declaration lets you instruct the compiler\n"
"about the relative importance of certain properties of the program.\n"
"You can specify the relative importance of the <code>SPEED</code>,\n"
"<code>SPACE</code>, and <code>SIZE</code> of the generated code. You\n"
"can specify whether you'd like to allow the compiler to spend extra\n"
"time doing a better job, or to emphasize\n"
"<code>COMPILATION-SPEED</code>. You can specify the importance of\n"
"being able to <code>DEBUG</code> your program, which may cause the\n"
"compiler to produce code that is simpler or interacts well with the\n"
"debugger."
msgstr ""
"<p>\n"
"К счастью, объявления, которыми руководствуется компилятор, сами \n"
"модерируются(управляются) объявлением <code>OPTIMIZE</code>. Объявление \n"
"<code>OPTIMIZE</code> позволяет проинструктировать компилятор об "
"относительной \n"
"важности определенных свойств программы. Вы можете указать относительную \n"
"важность <code>SPEED</code>, <code>SPACE</code>, и <code>SIZE</code>  \n"
"сгенерированного кода. Вы можете \n"
"указать, хотите ли вы позволить компилятору тратить дополнительное время \n"
"на выполнение лучшей работы или подчеркнуть <code>COMPILATION-SPEED</"
"code>. \n"
"Вы можете \n"
"указать важность возможности отладки(<code>DEBUG</code>) вашей программы, "
"что может привести к тому, что компилятор будет создавать код, который "
"является более простым \n"
"или хорошо взаимодействует с отладчиком."

#: in/chapter28.html:203
msgid ""
"<blockquote>\n"
"Values range from 0 to 3 for the <code>OPTIMIZE</code> declarations,\n"
"with 0 meaning \"totally unimportant\" and 3 meaning \"most important\".\n"
"The default value is 1, meaning \"of normal importance\".\n"
"Bear in mind that for something to be relatively more important, \n"
"something else must be less important; it won't give the compiler\n"
"any useful guidance to specify values of 3 for all of the \n"
"<code>OPTIMIZE</code> declarations.\n"
"</blockquote> "
msgstr ""
"<blockquote>\n"
"Значения варьируются от 0 до 3 для деклараций оптимизации(<code>OPTIMIZE</"
"code>), \n"
"причем 0 означает \"совершенно неважный\", а 3 - \"самый важный\". Значение "
"по \n"
"умолчанию равно 1, Что означает \"нормальной важности\". Имейте в виду, "
"что \n"
"для того, чтобы что-то было относительно более важным, что-то другое "
"должно \n"
"быть менее важным; это не даст компилятору никаких полезных указаний по \n"
"указанию значений 3 для всех объявлений <code>OPTIMIZE</code>\n"
"</blockquote> "

#: in/chapter28.html:212
msgid ""
"<p>Of all the <code>OPTIMIZE</code> declarations, the most important is\n"
"<code>SAFETY</code>, since this affects the amount of trust the\n"
"compiler is willing to extend to your type declarations. A high\n"
"value of <code>SAFETY</code> generally compels the compiler to check\n"
"the type of every value that it can't absolutely determine at\n"
"compile time. Lower <code>SAFETY</code> values put increasing weight\n"
"upon your abilities as a programmer to guarantee that type\n"
"declarations are correct, array bounds are always in range, etc."
msgstr ""
"<p>\n"
"Из всех объявлений <code>OPTIMIZE</code> наиболее важным является "
"безопасность\n"
"(<code>SAFETY</code>), поскольку это влияет на степень доверия, которое \n"
"компилятор готов распространить на ваши объявления типов. Высокое значение \n"
"безопасности(<code>SAFETY</code>) обычно заставляет компилятор проверять \n"
"тип каждого значения, которое он не может полностью определить во время "
"компиляции. \n"
"Более низкие значения безопасности(<code>SAFETY</code>) придают все больший "
"вес \n"
"вашим способностям программиста, гарантируя, что объявления типов верны, "
"границы \n"
"массива всегда находятся в диапазоне и т. д."

#: in/chapter28.html:216
msgid ""
"<p>The exact effect of declarations (with the exception of\n"
"<code>SPECIAL</code> and <code>NOTINLINE</code>) varies among Lisp\n"
"implementations; consult your reference manual for details."
msgstr ""
"<p>\n"
"Точный эффект деклараций (за исключением <code>SPECIAL</code> и \n"
"<code>NOTINLINE</code>) варьируется в зависимости от реализаций Lisp; \n"
"обратитесь к вашему справочному руководству для получения подробной \n"
"информации."

#: in/chapter28.html:218
msgid "<h2>DEFVAR versus DEFPARAMETER</h2>"
msgstr "<h2>DEFVAR против DEFPARAMETER</h2>"

#: in/chapter28.html:225
msgid ""
"<p>Although not required by the Common Lisp standard, almost all\n"
"implementations require that you load code from a file. (The one\n"
"exception that I know of is the Venue Medley environment, which\n"
"normally saves the entire Lisp world when you end a session. Medley\n"
"also keeps track of new definitions created in the listener and\n"
"allows you to save just those definitions to a file.) "
msgstr ""
"<p>\n"
"Хотя стандарт Common Lisp этого не требует, почти все реализации требуют \n"
"загрузки кода из файла. (Единственное исключение, о котором я знаю, - \n"
"это окружение Venue Medley, которое обычно спасает весь мир Lisp, когда вы \n"
"заканчиваете сеанс. Medley также отслеживает новые определения, созданные "
"в \n"
"прослушивателе, и позволяет сохранять только эти определения в файл.)"

#: in/chapter28.html:235
msgid ""
"<p>In a file-based Lisp environment, you'll normally add definitions\n"
"to a file of source code. One reason for so doing is to periodically\n"
"save your work; unless you're debugging FFI code or running buggy\n"
"Lisp code with a low optimization value for safety, your Lisp\n"
"environment will almost never crash.  However, other disasters can\n"
"happen -- another application could crash and bring down the system\n"
"in an unprotected OS such as the Mac OS or Windows, the power could\n"
"fail, or your cat could walk across the keyboard when you leave to\n"
"refill your coffee."
msgstr ""
"<p>\n"
"В файловой среде Lisp вы обычно добавляете определения в файл исходного "
"кода. \n"
"Одна из причин этого заключается в том, чтобы периодически сохранять свою "
"работу; \n"
"если вы не отлаживаете FFI-код или не запускаете глючный Lisp-код с низким \n"
"значением оптимизации для обеспечения безопасности, ваша среда Lisp почти \n"
"никогда не будет аварийно завершаться. Однако могут произойти и другие \n"
"катастрофы - другое приложение может разбиться и вывести из строя систему \n"
"в незащищенной операционной системе, такой как Mac OS или Windows, питание \n"
"может выйти из строя, или ваша кошка может ходить по клавиатуре, когда вы \n"
"уходите, чтобы наполнить свой кофе."

#: in/chapter28.html:244
msgid ""
"<p>As your program gets larger, you may find that it's useful to\n"
"reload an entire source file after making a series of changes. Most\n"
"Lisp environments also let you evaluate one definition at a time in\n"
"any open window. This is quite useful because you can edit, then\n"
"recompile, one definition at a time. But sometimes you'll forget,\n"
"and then it's easier to just reload the entire file than to spend\n"
"time figuring out which definition you might have forgotten to\n"
"recompile after last changing its definition."
msgstr ""
"<p>\n"
"По мере того как ваша программа становится больше, вы можете обнаружить, \n"
"что полезно перезагрузить весь исходный файл после внесения ряда "
"изменений. \n"
"Большинство сред Lisp также позволяют вычислять одно определение за один \n"
"раз в любом открытом окне. Это очень полезно, потому что вы можете "
"редактировать, \n"
"а затем перекомпилировать одно определение за раз. Но иногда вы забываете, "
"и \n"
"тогда проще просто перезагрузить весь файл, чем тратить время на выяснение "
"того, \n"
"какое определение вы, возможно, забыли перекомпилировать после последнего "
"изменения \n"
"его определения."

#: in/chapter28.html:258
msgid ""
"<p>But you may also be in the midst of debugging your program when\n"
"you'd like to reload its source code. If your program uses any\n"
"global variables to keep track of its state, you really <em>don't</em> \n"
"want to reinitialize these in the midst of your debugging session.\n"
"So, how do you handle this?  You could put definitions of your\n"
"program's state variables in a separate file, but that increases\n"
"your mental workload and increases debugging time by splitting clearly\n"
"interrelated parts of your program into two separate files.  (I know\n"
"that this is an accepted practice in many programming languages, but\n"
"it really does increase the amount of work you do as a programmer.\n"
"Imagine how much less pleasurable reading a novel would be if the novel\n"
"was delivered as a set of pamphlets, one per character, and you had to\n"
"follow page references to get to the next part of the dialog.)"
msgstr ""
"<p>\n"
"Но вы также можете быть в середине отладки вашей программы, когда вы \n"
"захотите перезагрузить ее исходный код. Если ваша программа использует \n"
"какие-либо глобальные переменные для отслеживания своего состояния, \n"
"вы действительно не хотите повторно инициализировать их в разгар \n"
"сеанса отладки. Итак, как вы справляетесь с этим? Вы можете поместить \n"
"определения переменных состояния вашей программы в отдельный файл, \n"
"но это увеличивает вашу умственную нагрузку и увеличивает время отладки, \n"
"разделяя ясно взаимосвязанные части вашей программы на два отдельных "
"файла. \n"
"(Я знаю, что это общепринятая практика во многих языках программирования, \n"
"но она действительно увеличивает объем работы, которую вы делаете как \n"
"программист. Представьте себе, насколько менее приятным было бы чтение "
"романа, \n"
"если бы он был представлен в виде набора брошюр, по одной на каждого "
"персонажа, \n"
"и вам пришлось бы следовать ссылкам на страницы, чтобы перейти к следующей \n"
"части диалога.)"

#: in/chapter28.html:265
msgid ""
"<p>Fortunately, Lisp has grown through decades of real-world programming\n"
"experience, and has a very simple mechanism to handle whether variables\n"
"get reinitialized or not when you load a file. You use <code>DEFVAR</code> \n"
"to declare variables with values that need to be initialized only once.\n"
"To declare a variable with an initial value that gets set every time its\n"
"defining form is evaluated, use <code>DEFPARAMETER</code>."
msgstr ""
"<p>\n"
"К счастью, Lisp вырос за десятилетия реального опыта программирования и \n"
"имеет очень простой механизм для обработки того, будут ли переменные "
"повторно\n"
"инициализированы или нет, когда вы загружаете файл. Вы используете DEFVAR "
"для \n"
"объявления переменных со значениями, которые должны быть инициализированы "
"только \n"
"один раз. Чтобы объявить переменную с начальным значением, которое "
"устанавливается \n"
"каждый раз при вычислении ее определяющей формы, используйте  "
"<code>DEFPARAMETER</code>."

#: in/chapter28.html:270
msgid ""
"<p>One final note: as a matter of form, you should name global variables\n"
"with a leading and trailing asterisk, as in <code>*MY-ADDRESS*</code>.\n"
"Think of this convention as a courtesy to those who will maintain your\n"
"code at some future date."
msgstr ""
"<p>\n"
"И последнее замечание: по форме вы должны называть глобальные переменные \n"
"с начальными и конечными звездочками, как в <code>*MY-ADDRESS*</code>. \n"
"Думайте об этом соглашении как о любезности по отношению к тем, кто \n"
"будет поддерживать ваш код в будущем."

#: in/chapter28.html:272
msgid "<h2>Define constants with DEFCONSTANT</h2>"
msgstr "<h2>Определяйте константы с помощью DEFCONSTANT</h2>"

#: in/chapter28.html:283
msgid ""
"<p>You should define global constants using\n"
"<code>DEFCONSTANT</code>. From the viewpoint of reading a Lisp\n"
"program, the distinction between <code>DEFPARAMETER</code> and\n"
"<code>DEFCONSTANT</code> is that the value defined by\n"
"<code>DEFPARAMETER</code> could concievably be altered by the user\n"
"after the program is compiled, but a <code>DEFCONSTANT</code> value\n"
"will <em>never</em> change. A good Lisp compiler will take advantage\n"
"of <code>DEFCONSTANT</code> declarations to perform classical\n"
"optimizations such as constant folding or compiling immediate load\n"
"instructions."
msgstr ""
"<p>\n"
"Вы должны определить глобальные константы с помощью <code>DEFCONSTANT</"
"code>. \n"
"С точки зрения чтения программы Lisp, различие между <code>DEFPARAMETER</"
"code> и\n"
"<code>DEFCONSTANT</code>заключается в том, что значение, определенное \n"
"<code>DEFPARAMETER</code>, может быть изменено пользователем после "
"компиляции \n"
"программы, но значение <code>DEFCONSTANT</code> никогда не изменится. "
"Хороший \n"
"компилятор Lisp использует преимущества  деклараций <code>DEFCONSTANT</code> "
"для\n"
"выполнения классических оптимизаций, таких как  свертка константных "
"вычислений или\n"
"компиляция инструкций немедленной загрузки."

#: in/chapter28.html:287
msgid ""
"<p>Fewer Lisp programmers follow a naming convention for constants.\n"
"The one I use puts a leading and trailing plus sign on the name of\n"
"the constant, as in <code>+RTS-OPCODE+</code>."
msgstr ""
"<p>\n"
"Меньше Лисп-программистов следуют соглашению об именовании констант. \n"
"Тот, который я использую, ставит начальный и конечный знак плюс к имени\n"
"константы, как в  <code>+RTS-OPCODE+</code>."

#: in/chapter28.html:289
msgid "<h2>Know when (not) to use the compiler</h2>"
msgstr "<h2>Знайте когда (не) использовать компилятор</h2>"

#: in/chapter28.html:294
msgid ""
"<p>Most Lisp systems include both an interpreter and a compiler;\n"
"when both are available, you'll normally find that it's easier to\n"
"debug interpreted code. Consult your vendor's documentation to \n"
"learn how to switch between the interpreter and the compiler."
msgstr ""
"<p>\n"
"Большинство систем Lisp включают в себя как интерпретатор, так и "
"компилятор; \n"
"когда они доступны, вы обычно обнаруживаете, что легче отлаживать "
"интерпретируемый \n"
"код. Обратитесь к документации вашего поставщика, чтобы узнать, как "
"переключаться \n"
"между интерпретатором и компилятором."

#: in/chapter28.html:298
msgid ""
"<p>Of course, when performance is important, you'll want to run\n"
"your code compiled once it's debugged.  But see the earlier cautions\n"
"about running buggy code with low safety settings."
msgstr ""
"<p>\n"
"Конечно, когда важна производительность, вы захотите запустить свой код, \n"
"скомпилированный после его отладки. Но смотрите более ранние "
"предостережения \n"
"о запуске багги кода с низкими настройками безопасности."

#: in/chapter28.html:311
msgid ""
"<p>When you're writing Lisp code to run on multiple platforms, it's\n"
"safest to assume that code will run interpreted unless you call\n"
"<code>COMPILE</code> or <code>COMPILE-FILE</code>. For this reason,\n"
"you should develop the practice of writing (or using) a system\n"
"definition procedure that first loads all of your Lisp source files,\n"
"then compiles them, then loads the compiled files. This is usually\n"
"overkill, but it's a very safe, conservative approach. With suitable\n"
"source code organization and proper use of <code>EVAL-WHEN</code>\n"
"you can reduce the number of source files that must first be loaded;\n"
"the main idea is to ensure that all macros are defined before\n"
"compiling code that uses the macros, but there are other possible\n"
"situations that can depend upon the current state of the Lisp world."
msgstr ""
"<p>\n"
"Когда вы пишете Lisp-код для запуска на нескольких платформах, безопаснее \n"
"всего предположить, что код будет работать интерпретируемо, если вы не \n"
"вызовете <code>COMPILE</code> или <code>COMPILE-FILE</code>. По этой "
"причине \n"
"вы должны разработать практику написания (или использования) процедуры "
"определения\n"
"системы, которая сначала загружает все исходные файлы Lisp, затем "
"компилирует их, \n"
"а затем загружает скомпилированные файлы. Обычно это перебор, но это очень "
"безопасный,\n"
"консервативный подход. При подходящей организации исходного кода и "
"правильном\n"
"использовании <code>EVAL-WHEN</code> вы можете уменьшить количество исходных "
"файлов,\n"
"которые должны быть загружены в первую очередь; основная идея состоит в том, "
"чтобы\n"
"убедиться, что все макросы определены до компиляции кода, который использует "
"макросы, \n"
"но есть и другие возможные ситуации, которые могут зависеть от текущего "
"состояния мира\n"
"Lisp."

#: in/chapter28.html:313
msgid "<h2>Speed vs. ability to debug</h2>"
msgstr "<h2>Скорость против способности к отладке</h2>"

#: in/chapter28.html:322
msgid ""
"<p>Interpreted programs are easier to debug because it's easier for\n"
"the debugger to access the actual source code at the point of an\n"
"error. Once you've compiled your program, the debugger typically has\n"
"less source information available; you may find yourself puzzling\n"
"over a transformed version of the source code or grovelling through\n"
"assembly-language instructions to find the source of the error.\n"
"Fortunately, the need for such low-level debugging will be rare if\n"
"you follow some simple advice:"
msgstr ""
"<p>\n"
"Интерпретируемые программы легче отлаживаются, потому что отладчику \n"
"легче получить доступ к фактическому исходному коду в момент ошибки. \n"
"После того как вы скомпилировали программу, отладчик обычно имеет меньше \n"
"доступной исходной информации; вы можете обнаружить, что ломаете голову \n"
"над преобразованной версией исходного кода или пресмыкаетесь перед \n"
"инструкциями на ассемблере, чтобы найти источник ошибки. К счастью, \n"
"необходимость в такой низкоуровневой отладке возникнет редко, если вы \n"
"будете следовать некоторым простым советам:"

#: in/chapter28.html:330
msgid ""
"<ol>\n"
"<li>Keep high <code>SAFETY</code> optimizations on untested code.\n"
"<li>If an interpreter is available to you, use it until your code is\n"
"    working well.\n"
"<li>If you have a compile-only environment, use lower optimization\n"
"    settings for <code>SPEED</code> and higher settings for <code>DEBUG</"
"code>.\n"
"</ol> "
msgstr ""
"<ol>\n"
"<li>Сохраняйте высокий уровень  <code>SAFETY</code> (безопасности) при\n"
"    оптимизации на непроверенном коде.\n"
"<li>Если вам доступен интерпретатор, используйте его до тех пор, пока ваш "
"код \n"
"    не будет работать хорошо.\n"
"<li>Если у вас есть среда только с компиляцией, используйте более низкие "
"параметры\n"
"    оптимизации для <code>SPEED</code> и более высокие параметры для "
"<code>DEBUG</code>.\n"
"</ol> "

#: in/chapter28.html:337
msgid ""
"<p>Once your code is running well, then you should compile it and\n"
"adjust the optimization declarations for performance. If you find\n"
"that simply compiling your program provides adequate performance,\n"
"leave it alone. If the performance of the compiled program falls far\n"
"below your expectations, first improve the algorithm; optimization\n"
"declarations typically have a fractional impact upon performance."
msgstr ""
"<p>\n"
"После того, как ваш код работает хорошо, вы должны скомпилировать \n"
"его и настроить объявления оптимизации для повышения производительности. \n"
"Если вы обнаружите, что простая компиляция вашей программы обеспечивает \n"
"достаточную производительность, оставьте ее в покое. Если "
"производительность\n"
"скомпилированной программы значительно ниже ваших ожиданий, сначала \n"
"улучшите алгоритм; объявления оптимизации обычно оказывают дробное \n"
"влияние на производительность."

#: in/chapter28.html:340
msgid ""
"<a name=\"efficiency\"></a> \n"
"<h2>Efficiency: spotting it, testing it</h2>"
msgstr ""
"<a name=\"efficiency\"></a> \n"
"<h2>Эффективность: обнаружить, проверить</h2>"

#: in/chapter28.html:348
msgid ""
"<p>The first rule of efficiency in any programming language is to\n"
"start with an efficient algorithm. It's a little harder to spot\n"
"inefficiencies in a Lisp program because the underlying operations\n"
"don't usually map directly onto a hardware instruction. But with a\n"
"certain amount of knowledge and practice, you should be able to tell\n"
"why the following four programs have radically different resource\n"
"requirements."
msgstr ""
"<p>\n"
"Первое правило эффективности в любом языке программирования-начинать \n"
"с эффективного алгоритма. Немного сложнее обнаружить неэффективность \n"
"в программе Lisp, потому что базовые операции обычно не отображаются \n"
"непосредственно на аппаратную инструкцию. Но с определенным количеством \n"
"знаний и практики вы должны быть в состоянии сказать, почему следующие \n"
"четыре программы имеют радикально отличающиеся требования к ресурсам.\n"

#: in/chapter28.html:354
msgid ""
"<p>These four programs return the sum of a list of numbers, but do\n"
"it in different ways.  In each case, we test the program with the\n"
"<code>TIME</code> form, which reports run time and memory allocation.\n"
"Each program is tested twice, once with a list of ten thousand elements, \n"
"then again with one hundred thousand."
msgstr ""
"<p>\n"
"Эти четыре программы возвращают сумму списка чисел, но делают это по-"
"разному. \n"
"В каждом случае мы тестируем программу с формой <code>TIME</code>, которая\n"
"сообщает о времени выполнения и выделении памяти. Каждая программа "
"тестируется \n"
"дважды, один раз со списком из десяти тысяч элементов, а затем со ста "
"тысячами."

#: in/chapter28.html:375
msgid ""
"<pre>\n"
"<i>;; Runtime increases as the square of the number of elements</i> \n"
"? (defun sum-list-bad-1 (list)\n"
"    (let ((result 0))\n"
"      (dotimes (i (length list))\n"
"        (incf result (elt list i)))\n"
"      result))\n"
"SUM-LIST-BAD-1\n"
"? (let ((list (make-list 10000 :initial-element 1)))\n"
"    (time (sum-list-bad-1 list)))\n"
"(SUM-LIST-BAD-1 LIST) took 2,199 milliseconds (2.199 seconds) to run.\n"
"Of that, 102 milliseconds (0.102 seconds) were spent in The Cooperative "
"Multitasking Experience.\n"
" 16 bytes of memory allocated.\n"
"10000\n"
"? (let ((list (make-list 100000 :initial-element 1)))\n"
"    (time (sum-list-bad-1 list)))\n"
"(SUM-LIST-BAD-1 LIST) took 336,650 milliseconds (336.650 seconds) to run.\n"
"Of that, 15,680 milliseconds (15.680 seconds) were spent in The Cooperative "
"Multitasking Experience.\n"
" 2,704 bytes of memory allocated.\n"
"100000"
msgstr ""

#: in/chapter28.html:392
msgid ""
"<i>;; Recursive version works when compiler does tail-call optimization</"
"i> \n"
"? (defun sum-list-bad-2 (list)\n"
"    (labels ((do-sum (rest-list sum)\n"
"               (if (null rest-list)\n"
"                 sum\n"
"                 (do-sum (rest rest-list) (+ sum (first rest-list))))))\n"
"      (do-sum list 0)))\n"
"SUM-LIST-BAD-2\n"
"? (let ((list (make-list 10000 :initial-element 1)))\n"
"    (time (sum-list-bad-2 list)))\n"
"(SUM-LIST-BAD-2 LIST) took 2 milliseconds (0.002 seconds) to run.\n"
"10000\n"
"? (let ((list (make-list 100000 :initial-element 1)))\n"
"    (time (sum-list-bad-2 list)))\n"
"(SUM-LIST-BAD-2 LIST) took 21 milliseconds (0.021 seconds) to run.\n"
"100000"
msgstr ""

#: in/chapter28.html:405
msgid ""
"<i>;; The recursive version can fail w/o tail-call optimization</i> \n"
"? (defun sum-list-bad-3 (list)\n"
"    (declare (optimize (debug 3)))  <i>; disable tail-call optimization</"
"i> \n"
"    (labels ((do-sum (rest-list sum)\n"
"               (if (null rest-list)\n"
"                 sum\n"
"                 (do-sum (rest rest-list) (+ sum (first rest-list))))))\n"
"      (do-sum list 0)))\n"
"SUM-LIST-BAD-3\n"
"? (let ((list (make-list 10000 :initial-element 1)))\n"
"    (time (sum-list-bad-3 list)))\n"
"&gt; Error: Stack overflow on control stack."
msgstr ""

#: in/chapter28.html:422
msgid ""
"<i>;; The iterative version is not as elegant, but it's fast!</i> \n"
"? (defun sum-list-good (list)\n"
"    (let ((sum 0))\n"
"      (do ((list list (rest list)))\n"
"          ((endp list) sum)\n"
"        (incf sum (first list)))))\n"
"SUM-LIST-GOOD\n"
"? (let ((list (make-list 10000 :initial-element 1)))\n"
"    (time (sum-list-good list)))\n"
"(SUM-LIST-GOOD LIST) took 1 milliseconds (0.001 seconds) to run.\n"
"10000\n"
"? (let ((list (make-list 100000 :initial-element 1)))\n"
"    (time (sum-list-good list)))\n"
"(SUM-LIST-GOOD LIST) took 10 milliseconds (0.010 seconds) to run.\n"
"100000\n"
"</pre> "
msgstr ""

#: in/chapter28.html:431
msgid ""
"<p>The first version, <code>SUM-LIST-BAD-1</code>, harbors a hidden\n"
"inefficiency: <code>(ELT LIST I)</code> must search\n"
"<code>LIST</code> from the beginning for each value of\n"
"<code>I</code>. In other words, <code>ELT</code> must examine one\n"
"element when <code>I</code> is 1, two elements when <code>I</code>\n"
"is 2, and so on. For a list of length <i>N</i>, <code>ELT</code>\n"
"will examine almost <i>N</i>-squared elements.  Have a look at the\n"
"runtimes for 1,000 and 10,000 elements."
msgstr ""
"<p>\n"
"Первая версия, <code>SUM-LIST-BAD-1</code>, скрывает скрытую "
"неэффективность: \n"
"<code>(ELT LIST I)</code> должен искать в списке (<code>LIST</code>) с "
"самого \n"
"начала для каждого значения <code>I</code>. другими словами, <code>ELT</"
"code> \n"
"должен исследовать один элемент, когда <code>I</code> равен 1, два "
"элемента, \n"
"когда <code>I</code> равен 2, и так далее. Для списка длины <i>N</i>, "
"<code>ELT</code>\n"
"будет рассматривать почти <i>N</i>-квадрат элементов. Взгляните на время "
"выполнения \n"
"для 1000 и 10 000 элементов.\n"

#: in/chapter28.html:437
msgid ""
"<p>The second version is coded using an awareness of how lists are\n"
"accessed; the helper function <code>DO-SUM</code> calls itself\n"
"recursively with the tail of the list it is given. In\n"
"<code>SUM-LIST-BAD-2</code>, the runtime increases linearly with the\n"
"length of the input list. So why is this a <b>bad</b> example?"
msgstr ""
"<p>\n"
"Вторая версия кодируется с помощью осознания того, как осуществляется \n"
"доступ к спискам; вспомогательная функция <code>DO-SUM</code> вызывает \n"
"себя рекурсивно с хвостом списка, который ей задан. В <code>SUM-LIST-BAD-2</"
"code>\n"
"Время выполнения увеличивается линейно с длиной входного списка. \n"
"Так почему же это плохой пример?"

#: in/chapter28.html:444
msgid ""
"<p><code>DO-SUM</code> calls itself as the last form it executes;\n"
"this is known as <em>tail recursion</em>. Some compilers can compile\n"
"tail recursion as a jump instruction instead of a function call;\n"
"this eliminates the growth of the control (function return) stack\n"
"that would otherwise occur in a recursive call. However, the Common\n"
"Lisp standard does not <em>require</em> that tail calls be optimized."
msgstr ""
"<p>\n"
"<code>DO-SUM</code> вызывает себя как последнюю форму, которую он "
"выполняет; \n"
"это известно как хвостовая рекурсия. Некоторые компиляторы могут "
"компилировать \n"
"хвостовую рекурсию как команду перехода вместо вызова функции; это "
"исключает \n"
"рост стека управления (возврат функции), который в противном случае "
"произошел бы при рекурсивном вызове. Однако стандарт Common Lisp не требует "
"оптимизации хвостовых \n"
"вызовов."

#: in/chapter28.html:452
msgid ""
"<p>The third version shows what can happen when the compiler does\n"
"not optimize tail recursion. The compiler in my Lisp system disables\n"
"tail recursion optimizations when the <code>DEBUG</code>\n"
"optimization is set to 3. Without tail recursion optimization,\n"
"<code>SUM-LIST-BAD-3</code> consumes a function call frame for each\n"
"recursive call, and the program fails -- exhausting stack space --\n"
"before reaching the end of the test list."
msgstr ""
"<p>\n"
"Третья версия показывает, что может произойти, если компилятор не \n"
"оптимизирует хвостовую рекурсию. Компилятор в моей системе Lisp \n"
"отключает оптимизацию хвостовой рекурсии, когда оптимизация <code>DEBUG</"
"code>\n"
"(отладки) установлена равной 3. Без оптимизации хвостовой рекурсии \n"
"<code>SUM-LIST-BAD-3</code>потребляет фрейм вызова функции для каждого \n"
"рекурсивного вызова, и программа терпит неудачу-исчерпывает пространство \n"
"стека-до достижения конца тестового списка."

#: in/chapter28.html:458
msgid ""
"<p>The final version, <code>SUM-LIST-GOOD</code>, uses iteration\n"
"instead of recursion for its control loop, and walks down the input\n"
"list element by element. It runs slightly faster than\n"
"<code>SUM-LIST-BAD-2</code> and doesn't fail if the compiler doesn't\n"
"support tail recursion optimization."
msgstr ""
"<p>\n"
"Заключительная версия,  <code>SUM-LIST-GOOD</code>, использует итерацию \n"
"вместо рекурсии для своего цикла управления и проходит по входному списку \n"
"элемент за элементом. Он работает немного быстрее, чем <code>SUM-LIST-BAD-2</"
"code>, \n"
"и не терпит неудачи, если компилятор не поддерживает оптимизацию хвостовой \n"
"рекурсии."

#: in/chapter28.html:460
msgid ""
"<h2>Recognizing inefficiency, profiling; performance vs. readability</h2>"
msgstr ""
"<h2>Признавая не эффективность, профилирование; производительность против "
"читаемости</h2>"

#: in/chapter28.html:464
msgid ""
"<p>Avoidance is the best defense against inefficiency. Use appropriate \n"
"data structures and control techniques. When you're not sure, put together\n"
"a <em>small</em> test program and time it with a variety of inputs."
msgstr ""
"<p>\n"
"Предотвращение -лучшая защита от неэффективности. Используйте "
"соответствующие \n"
"структуры данных и методы управления. Когда вы не уверены, составьте "
"небольшую \n"
"тестовую программу и время ее работы с различными входными данными."

#: in/chapter28.html:468
msgid ""
"<p>Every Common Lisp implementation will have the <code>TIME</code> macro\n"
"that we used to show the differences in the <code>SUM-LIST-</code><i>xxx</"
"i> \n"
"functions. You can use this to examine and tune small portions of a program."
msgstr ""
"<p>\n"
"Каждая реализация Common Lisp будет иметь макрос <code>TIME</code>, \n"
"который мы использовали для отображения различий в функциях \n"
"<code>SUM-LIST-</code><i>xxx</i>. Вы можете использовать его для изучения \n"
"и настройки небольших частей программы."

#: in/chapter28.html:476
msgid ""
"<p>Once you have assembled a larger program, you may need to find\n"
"the bottleneck that causes unexpectedly low performance. For this,\n"
"you'll need a profiler. A profiler watches the execution of your whole\n"
"program and generates a report to show where the program spends its time.\n"
"Some profilers also report on memory allocation. A profiler is not a\n"
"standard part of Lisp, but most vendors provide one.  Consult your\n"
"vendor's documentation."
msgstr ""
"<p>\n"
"После того как вы собрали большую программу, вам может понадобиться \n"
"найти узкое место, которое вызывает неожиданно низкую производительность. \n"
"Для этого вам понадобится профилировщик. Профилировщик следит за "
"выполнением \n"
"всей вашей программы и создает отчет, чтобы показать, где программа "
"проводит \n"
"свое время. Некоторые профили также сообщают о выделении памяти. "
"Профилировщик \n"
"не является стандартной частью Lisp, но большинство поставщиков "
"предоставляют \n"
"его. Обратитесь к документации вашего поставщика.\n"

#: in/chapter28.html:482
msgid ""
"<p>Lisp provides abstractions that help you solve problems. You'll\n"
"find that you don't have to make a tradeoff between readability and\n"
"performance; an efficient Lisp program is usually one that is\n"
"written using the most appropriate abstractions and operations to\n"
"solve a given problem."
msgstr ""
"<p>\n"
"Lisp предоставляет абстракции, которые помогут вам решить проблемы. \n"
"Вы обнаружите, что вам не нужно делать компромисс между удобочитаемостью \n"
"и производительностью; эффективная программа Lisp обычно написана с \n"
"использованием наиболее подходящих абстракций и операций для решения \n"
"данной проблемы."

#: in/chapter28.html:495
msgid ""
"<hr>\n"
"<div align=\"center\">\n"
"<a href=\"contents.html\">Contents</a> | <a href=\"cover.html\">Cover</a> "
"<br> \n"
"<a href=\"chapter27.html\">Chapter 27</a> | Chapter 28 | <a href=\"chapter29."
"html\">Chapter 29</a> \n"
"</div>\n"
"<hr>\n"
"<address>\n"
"Copyright &copy; 1995-2001, David B. Lamkins<br>\n"
"All Rights Reserved Worldwide<br>\n"
"<br>\n"
"This book may not be reproduced without the written consent of its author.  "
"Online distribution is restricted to the author's site.\n"
"</address> \n"
"</body> </html> "
msgstr ""
