<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<title>Successful Lisp - Chapter 17</title>
</head> 

<body bgcolor="white" text="black">
<h1>Глава 17 - Не все сравнения Одинаковы(Equal)</h1> 

<P>
До этого момента я показывал вам различные функции сравнения, не говоря на самом 
деле много о различиях между ними. В этой главе я (наконец) расскажу вам о том, 
как и почему функции сравнения отличаются друг от друга, и предложу некоторые 
рекомендации по их правильному использованию.

<h2>Чем дольше тест, тем больше он вам скажет</h2>

<p>
Lisp имеет основной набор функций сравнения, которые работают практически 
с любым типом объекта. Это:

<ul>
<li><code>EQ</code> 
<li><code>EQL</code> 
<li><code>EQUAL</code> 
<li><code>EQUALP</code> 
</ul> 

<p>
Тесты с более короткими названиями поддерживают более строгие определения равенства.
Тесты с более длительным сроком реализации менее ограничительные, возможно, более
интуитивные, определения равенства. Мы узнаем о каждом из четырех определений в 
последующих разделах.

<h2>EQ верно для идентичных символов</h2>

<p>
<code>EQ</code> истинен для одинаковых символов. На самом деле, 
это справедливо для любого идентичного объекта. Другими словами, 
объект равен самому себе. Даже составной объект, такой как список, 
является <code>EQ</code> для самого себя. (Но два списка не являются 
<code>EQ</code> только потому, что они выглядят одинаково при печати; 
они действительно должны быть одним и тем же списком, чтобы быть <code>EQ</code>.) 
Под "капотом" <code>EQ</code> просто сравнивает адреса памяти объектов. 

<p>
Причина того, что символы являются <em>EQ</em>, когда они имеют 
одно и то же имя (и находятся в одном пакете), заключается в том, 
что программа чтения Lisp интернирует(<em>interns</em>) символы, 
когда она их читает.  Когда читатель впервые видит символ, он 
его создает. При последующих появлениях читатель просто использует 
существующий символ.

<p>
<code>EQ</code> не гарантирует, что он будет верен для идентичных символов
или чисел. Это происходит это потому, что большинство систем Lisp не 
присваивают уникальный адрес памяти определенному числу или символу; 
числа и символы обычно создаются по мере необходимости и временно 
хранятся в аппаратных регистрах процессора.

<h2>EQL также истинен для одинаковых чисел и символьных знаков</h2>

<p>
<code>EQL</code>  сохраняет понятие равенства <code>EQ</code>, и 
расширяет его до одинаковых чисел и символов. Числа должны совпадать 
по значению и типу; таким образом, 0.0 <em>не</em> <code>EQL</code> 0. 
Символьные знаки должны быть действительно идентичны; EQL чувствителен 
к регистру.

<h2>EQUAL обычно истинно для вещей, которые печатаются одинаково</h2>

<p><code>EQ</code> и <code>EQL</code> обычно не верны для списков, 
которые печатают одно и то же. Списки, которые не являются <code>EQ</code>, 
но имеют одинаковую структуру, будут неразличимы при печати; 
они также будут <code>EQUAL</code>(равны).

<p>
Строки также считаются <code>EQUAL</code>(равными), если они печатают 
одно и то же. Как и в <code>EQL</code>, сравнение символьных знаков 
в строках чувствительно к регистру знаков.

<h2>EQUALP игнрорирует тип числа и регистр символов</h2>

<p>
<code>EQUALP</code> - это самая разрешающая из основных функций сравнения. 
Все, что <code>EQUAL</code>, также и <code>EQUALP</code>. Но <code>EQUALP</code> 
игнорирует различия в регистре между символьными знаками и применяет (безтиповое)
математическое понятие равенства к числам; таким образом, 0.0 <code>EQUALP</code>
(равно) 0.

<p>
Кроме того, <code>EQUALP</code> истинно, если соответствующие элементы 
<code>EQUALP</code>(равны) в следующих составных типах данных:

<ul>
<li>Массивах(Arrays)
<li>Структурах(Structures)
<li>Хеш-таблицах(Hash Tables)
</ul> 

<h2>Более длинные тесты идут медленне; надо знать что вы сравниваете</h2>

<p>
Обобщенность вышеприведенных тестов с длинными именами имеет свою цену. 
Они должны проверять типы своих аргументов, чтобы решить, какой вид 
равенства применим; это требует времени.

<p>
<code>EQ</code> не видит тип объекта; либо объекты являются одним 
и тем же объектом, либо они не являются таковыми. Этот вид теста 
обычно компилируется в одну или две машинные инструкции и очень быстр.


<p>
Вы можете избежать ненужных накладных расходов во время выполнения, 
используя наиболее ограничительный (самый короткий по имени) тест, 
который соответствует вашим потребностям.

<h2>Специализированные тесты работают быстрее на более ограниченных 
типах данных</h2>

<p>
Если вы заранее знаете тип ваших данных, вы можете использовать специальные 
сравнения для проверки этого конкретного типа данных. Тесты доступны для 
символьных знаков, строк, списков и чисел. И, конечно, существуют также 
сравнения для других отношений, помимо равенства.

<ul>
<li>Символьные знаки(Characters)
<ul>
 <li><code>CHAR=</code> 
 <li><code>CHAR/=</code> 
 <li><code>CHAR&lt;</code> 
 <li><code>CHAR&lt;=</code> 
 <li><code>CHAR&gt;</code> 
 <li><code>CHAR&gt;=</code> 
 <li><code>CHAR-EQUAL</code> 
 <li><code>CHAR-NOT-EQUAL</code> 
</ul> 
<li>Строки(Strings)
<ul>
 <li><code>STRING=</code> 
 <li><code>STRING/=</code> 
 <li><code>STRING&lt;</code> 
 <li><code>STRING&lt;=</code> 
 <li><code>STRING&gt;</code> 
 <li><code>STRING&gt;=</code> 
 <li><code>STRING-EQUAL</code> 
 <li><code>STRING-NOT-EQUAL</code> 
</ul> 
<li>Списки(Lists)
<ul>
 <li><code>TREE-EQUAL</code> 
</ul> 
<li>Числа(Numbers)
<ul>
 <li>=
 <li>/=
 <li>&lt;
 <li>&lt;=
 <li>&gt;
 <li>&gt;=
</ul> 
</ul> 

<hr>
<div align="center">
<a href="contents.html">Contents</a> | <a href="cover.html">Cover</a> <br> 
<a href="chapter16.html">Chapter 16</a> | Chapter 17 | <a href="chapter18.html">Chapter 18</a> 
</div>
<hr>
<address>
Copyright &copy; 1995-2001, David B. Lamkins<br>
All Rights Reserved Worldwide<br>
<br>
This book may not be reproduced without the written consent of its author.  Online distribution is restricted to the author's site.
</address> 
</body> </html>