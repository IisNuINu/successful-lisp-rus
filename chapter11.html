<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Successful Lisp - Chapter 11</title>
</head> 

<body bgcolor="white" text="black">
<h1>Глава 11 - Разрушающее Изменение</h1> 

<p>Присваивание сильно отличается от привязки, и во многих случаях 
приводит к программам, которые труднее понять. Несмотря на это, 
есть (иногда) причины предпочесть присваивание. В этой главе мы 
рассмотрим присваивание и его связь с разрушающей модификацией 
данных. Мы также рассмотрим несколько функций Lisp, реализующих 
разрушающую модификацию.

<h2>Простое присваивание это разрушающее изменение</h2>

<p>Каждый раз, когда ваша программа вызывает <code>SETQ</code> или
<code>SETF</code>, она присваивает новое значение существующему 
хранилищу, уничтожая значение, которое ранее было в этом расположении. 
Как мы увидим в этой главе, использование присваивания сопряжено 
как с рисками, так и с выгодами; вы должны понимать компромиссы, 
чтобы написать Лисп-код, который является одновременно правильным 
и эффективным.

<h2>Риски присваивания</h2>

<p>
Каждый раз, когда вы определяете функцию, использующую переменные, 
эти переменные либо связанны(<code>bound</code>), либо свободны(
<code>free</code>). Связанная переменная возникает в форме привязки, 
которая возникает в определении функции. Форма привязки- это просто форма,
которая создает новую ассоциацию(связь) между именем переменной и местом хранения
ее значения; наиболее распространенными формами привязки являются 
<code>LET</code> и список аргументов в <code>DEFUN</code> или 
<code>LAMBDA</code>.


<blockquote> Есть небольшое терминологическое противоречие в 
использовании слова "связанный"(<em>bound</em>). Конфликт всегда 
разрешается контекстом употребления слова, но вы должны быть 
осведомлены о двух значениях. В этой главе мы говорим исключительно 
о том, что имя переменной привязано к месту хранения ее значения; 
когда мы говорим, что Lisp создает привязку для переменной, 
мы имеем в виду, что он создает <em>новое</em> место для хранения 
значения под заданным именем.

<p>Другой смысл привязки(<em>bound</em>)-не обсуждавшийся ранее 
в этой главе - это привязка <em>значения</em> к месту хранения; 
Lisp поддерживает понятие несвязанного - или несуществующего -
значения.
</blockquote> 

<a name="closures"></a> 
<p>Переменная является <em>свободной</em> внутри функции, если 
функция не предоставляет формы привязки для имени переменной. 
В следующем примере переменная <code>E</code> свободна в обеих 
функциях <code>CLOSURE-1</code> и <code>CLOSURE-2</code>.

<pre>
? (let ((e 1))
    (defun closure-1 () e))
CLOSURE-1
? (closure-1)
1
? e
Error: unbound variable
</pre> 

<p>Итак, что же происходит, когда функция должна ссылаться 
на свободную переменную? Lisp создает замыкание(<em>closure</em>), которое 
захватывает привязки свободных переменных для функции. Переменные, свободные
в пределах функции, на само деле имеют привязки, но привязки находятся 
вне определения функции. Когда Lisp выполняет функцию, он находит 
свободные переменные в замыкании. (Более подробно мы рассмотрим замыкания 
в <a href="chapter15.html">главе 15</a>.)

<p>Замыкания важны, потому что они позволяют функции захватывать
(<code>capture</code>) и сохранять лексические привязки. Взгляните 
еще раз на приведенный выше пример. Когда мы вычисляли 
<code>(CLOSURE-1)</code>, переменная <code>E</code> больше не была 
видна в приглашении верхнего уровня. Но поскольку функция имела 
замыкание для этой переменной, она все еще имела доступ к ее привязке.

<p>Давайте немного расширим предыдущий пример.

<pre>
? (let ((e 1))
    (defun closure-1 () e)
    (setq e 7)
    (defun closure-2 () e))
CLOSURE-2
? (closure-1)
7
? (closure-2)
7
</pre> 

<p>Вы понимаете, почему <code>(CLOSURE-1)</code> вернуло 7, а не 1? 
Мы создали привязку для переменной <code>E</code> и дали ей начальное 
значение 1. Даже если <code>CLOSURE-1</code> был определен, когда
значение <code>E</code> было равно 1,это не имеет значения: замыкание
захватывает привязку - связь между именем и местом хранения. Когда 
мы присвоили 7 в качестве значения <code>E</code> (непосредственно перед
определением <code>CLOSURE-2</code>), мы изменили только одно место 
хранения для этой привязки. Поскольку свободная переменная <code>E</code>
обеих функций замкнута на одну и ту же привязку, они должны получить одно 
и то же значение.

<p>Это поведение может быть использовано с хорошим эффектом.

<pre>
? (let ((counter 0))
    (defun counter-next ()
      (incf counter))
    (defun counter-reset ()
      (setq counter 0)))
COUNTER-RESET
? (counter-next)
1
? (counter-next)
2
? (counter-next)
3
? (counter-next)
4
? (counter-reset)
0
? (counter-next)
1
</pre> 

<p>
Однако некоторые формы итераций Lisp связывают свои переменные итерации 
только один раз, а затем присваивают новые значения на последующих 
итерациях. <code>DO</code> и <code>DO*</code> присваивают своим переменным
итерации. <code>DOLIST</code> и <code>DOTIMES</code> могут присвоить своим
итерационным переменным (и, вероятно, будут присваивать в любой реализации,
потому что это более эффективно). Вы должны иметь это в виду, если пишете 
код, который создает замыкание для переменной итерации. Этот пример
иллюстрирует этот момент (см. <a href="chapter12.html">Главу 12</a>, 
Если вы хотите прочитать <code>MAPCAR</code>):

<pre>
<i>; Closure captures assigned variable -- probably wrong</i> 
? (let ((fns ()))
    (dotimes (i 3)
      (push #'(lambda () i) fns))
    (mapcar #'funcall fns))
(3 3 3)
<i>; New bindind created for each captured variable</i> 
? (let ((fns ()))
    (dotimes (i 3)
      (let ((i i))
        (push #'(lambda () i) fns)))
    (mapcar #'funcall fns))
(2 1 0)
</pre> 

<p>Мы видели, что присваивание может вызвать неожиданное поведение 
при наличии замыканий. Присваивание также может вызвать проблемы при
использовании разделяемых(общих) данных.

<pre>
? (defun nil-nth (n l)
    "Set nth element of list to nil and return modified list."
    (setf (nth n l) nil)
    l)
NIL-NTH
? (defparameter *my-list* (list 1 2 3 4))
*MY-LIST*
? (nil-nth 1 *my-list*)
(1 NIL 3 4)
? *MY-LIST*
(1 NIL 3 4)
</pre> 

<blockquote> 
Предупреждение: Если вы привыкли программировать на языке, который 
позволяет изменять параметры функции по ссылке, предыдущий фрагмент 
кода может показаться вам очень соблазнительным. Мой совет заключается 
в том, чтобы отбросить все мысли об использовании этого метода для 
эмуляции параметров по ссылкам и использовать множественные значения 
(<a href="chapter03-09.html">Глава 3, Урок 9</a>), чтобы безопасно и 
эффективно возвращать несколько результатов из функции.
 </blockquote> 

<p>Приведенный выше пример не является ошибочным, но он опасен. 
За исключением очень особых ситуаций, мы хотели бы, чтобы наши 
функции принимали Аргументы и возвращали значения. Проблема с 
<code>NIL-NTH</code> заключается в том, что он присваивает новое 
значение в списке, передаваемом в качестве параметра. В нашем 
примере этот список является глобальным и может быть раздяем с
другими частями программы. Если все, что мы действительно хотели 
сделать, это получить копию списка аргументов с N-м элементом, 
равным <code>NIL</code>, то мы не должны были изменять переданный 
аргумент. Вот лучший способ реализовать <code>NIL-NTH</code>:

<pre>
? (defun nil-nth (n l)
    "Return list with nth element set to nil."
    (if (zerop n)
      (cons nil (rest l))
      (cons (car l) (nil-nth (1- n) (rest l)))))
NIL-NTH
? (defparameter *my-list* (list 1 2 3 4))
*MY-LIST*
? (nil-nth 1 *my-list*)
(1 NIL 3 4)
? *MY-LIST*
(1 2 3 4)
</pre> 

<h2>Изменение против копирования: проблема эффективности</h2>

<p>Если присваивание чревато опасностью, то почему бы просто не убрать
его из языка? Есть две причины: выразительность и оперативность. 
Присваивание-это самый простой способ изменить общие(разделяемые) данные. 
И присваивание более эффективно, чем привязка. Привязка создает новое 
место хранения, которое выделяет хранилище, которое использует 
дополнительную память (если привязка никогда не выходит за пределы области
действия) или добавляет нагрузку сборщику мусора (если привязка в конечном 
итоге выходит за пределы области действия).

<h2>Изменение списков с помощью разрушающих функций</h2>

<p>
Некоторые операции над списками (и последовательностями-см. 
<a href="chapter12.html">Главу 12</a>) имеют как разрушающие,
так и неразрушающие аналоги.

<pre>
Nondestructive    Destructive
--------------    -----------
SUBLIS            NSUBLIS
SUBST             NSUBST
SUBST-IF          NSUBST-IF
SUBST-IF-NOT      NSUBST-IF-NOT
APPEND            NCONC
REVAPPEND         NRECONC
BUTLAST           NBUTLAST
INTERSECTION      NINTERSECTION
SET-DIFFERENCE    NSET-DIFFERENCE
SET-EXCLUSIVE-OR  NSET-EXCLUSIVE-OR
UNION             NUNION

REVERSE           NREVERSE
REMOVE            DELETE
REMOVE-IF         DELETE-IF
REMOVE-IF-NOT     DELETE-IF-NOT
SUBSTITUTE        NSUBSTITUTE
SUBSTITUTE-IF     NSUBSTITUTE-IF
SUBSTITUTE-IF-NOT NSUBSTITUTE-IF-NOT
REMOVE-DUPLICATES DELETE-DUPLICATES
</pre> 

<p>Все эти пары имеют одно и то же отношение: разрушающая версия может 
быть быстрее, но также может изменить общую структуру. Рассмотрим, например,
<code>APPEND</code> и <code>NCONC</code>. Оба они добавляют списки,
предоставленные в качестве своих аргументов.

<pre>
? (append (list 1 2 3) (list 4 5 6))
(1 2 3 4 5 6)
? (nconc (list 1 2 3) (list 4 5 6))
(1 2 3 4 5 6)
</pre> 

<p>Но <code>NCONC</code> может разрушающе изменить все, кроме конечного
(последнего) списка; он может изменить хвост каждого списка, чтобы указать 
на начало следующего списка.. 

<pre>
? (defparameter list1 (list 1 2 3))
LIST1
? (defparameter list2 (list 4 5 6))
LIST2
? (append list1 list2)
(1 2 3 4 5 6)
? list1
(1 2 3)
? list2
(4 5 6)
? (nconc list1 list2)
(1 2 3 4 5 6)
? list1
(1 2 3 4 5 6) <i>; Oops - compare to previous result!</i> 
? list2
(4 5 6)
</pre> 

<h2>RPLACA, RPLACD, SETF ...; (круговые списки)circularity</h2>

<p>Список строится из  <code>CONS</code> ячеек. Каждый  CONS состоит 
из двух частей, <code>CAR</code> и <code>CDR</code> (см 
<a href="chapter03-04.html">Глава 3, Урок 4</a>). CAR содержит данные 
для одного элемента списка, а CDR содержит CONS, которые составляют 
голову/начало оставшейся части списка(rest).

<p><img src="gifs/list-box-and-arrow.gif">

<p>
Используя <code>RPLACA</code> и <code>RPLACD</code> для изменения 
двух полей CONS, мы можем (разрушающе)изменить нормальную структуру 
списка. Например, мы могли бы вырезать второй элемент списка следующим образом:

<pre>
? (defparameter *my-list* (list 1 2 3 4))
*MY-LIST*
? (rplacd *my-list* (cdr (cdr *my-list*)))
(1 3 4)
? *my-list*
(1 3 4)
</pre> 

<p>Мы также можем использовать эти "операторы препарирования списков" 
для создания круговых списков.

<pre>
? (let ((l (list 1)))
    (rplacd l l)
    l)
(1 1 1 1 1 1 1 1 ... <i>; Continues until interrupt or stack overflow</i> 
? (let ((l (list 2)))
    (rplaca l l)
    l)
(((((((((((((((( ... <i>; Continues until interrupt or stack overflow</i> 
</pre> 

<p><img src="gifs/rplaca-rplacd.gif">

<p>Мы можем получить тот же эффект, используя <code>(SETF CAR)</code> 
вместо <code>RPLACA</code> и <code>(SETF CDR)</code> вместо 
<code>RPLACD</code>. 

<pre>
(rplaca cons object) <i>is</i> (setf (car cons) object)
(rplacd cons object) <i>is</i> (setf (cdr cons) object)
</pre> 

<p>Хорошая вещь в нотации <code>SETF</code> заключается в том, 
что он легко обобщается на другие методы доступа к списку, такие как, 
<code>NTH</code>, <code>LAST</code>, <code>NTHCDR</code>, и
<code>FOURTH</code>.

<h2>Место против значения: разрушающие функции не всегда имеют
желаемый побочный эффект</h2>

<p>
Неразрушающая функция, такая как <code>REVERSE</code>, всегда 
возвращает только что построенный результат, поэтому никогда не 
возникает никаких вопросов, кроме того, что вам нужно обратить 
внимание на результат. Но разрушающая функция, такая как 
<code>NREVERSE</code>, иногда изменяет свой аргумент таким образом, 
что измененный аргумент идентичен результату функции. Это приводит 
некоторых программистов к предположению, что разрушающие функции 
<em>всегда</em> изменяют аргумент, чтобы соответствовать результату. 
К сожалению, это не так; переходим ко второму важному пункту об 
использовании разрушающих функций: вы должны использовать результат
разрушающей функции так же, как вы использовали бы результат ее 
неразрушающего аналога.

<blockquote> Это также относится к <code>SORT</code> и
<code>STABLE-SORT</code>, которые являются разрушающими и 
не имеют неразрушающего аналога. </blockquote> 

<h2>Разница/контраст, например между PUSH и DELETE</h2>

<p>Вот пример, показывающий, почему вы не должны зависеть от 
побочных эффектов <code>DELETE</code>.

<pre>
? (defparameter *my-list (list 1 2 3 4))
*MY-LIST*
? (delete 3 *my-list*)
(1 2 4)
? *my-list*
(1 2 4)
? (delete 1 *my-list*)
(2 4)
? *my-list*
(1 2 4) <i>; Not the same as function result</i> 
</pre> 

<p>Но некоторые макросы, например <code>PUSH</code> и <code>POP</code>,
принимают место в качестве аргумента и организуют обновление места 
с правильным значением.

<pre>
? (defparameter *stack* ())
*STACK*
? (push 3 *stack*)
(3)
? (push 2 *stack*)
(2 3)
? (push 1 *stack*)
(1 2 3)
? *stack*
(1 2 3)
? (pop *stack*)
1
? *stack*
(2 3)
</pre> 

<h2>Разделяемые(Shared) и постоянные(constant) данные: 
Опасность разрушающих изменений</h2>

<p>Когда вы используете разрушающие функции, вы должны быть уверены, 
что изменяете только те данные, которые ваша программа создала во 
время выполнения. Вот пример того, что может произойти, если вы 
разрушающе измените постоянный список.

<pre>
? (defun stomp-a-constant ()
    (let ((l '(1 2 3))) <i>; compile-time constant data</i> 
      (print l)
      (setf (second l) nil) <i>; destructive modification</i> 
      l))
STOMP-A-CONSTANT
? (stomp-a-constant)
(1 2 3)
(1 NIL 3)
? (stomp-a-constant)
(1 NIL 3)
(1 NIL 3)
</pre> 

<p>Эта функция эффективно модифицирует себя, поскольку она 
изменяет постоянные данные, которые привязаны к переменной <code>L</code>.
Эффекты этого изменения проявляются в первой строке вывода 
при втором запуске (и во всех последующих запусках).


<p>Если вы замените <code>'(1 2 3)</code> (который может быть 
скомпилирован в постоянные данные) на <code>(list 1 2 3)</code> 
(который всегда создает свежий список во время выполнения), 
то поведение функции будет идентичным как при первом, так и при
всех  последующих запусках.

<hr>
<div align="center">
<a href="contents.html">Contents</a> | <a href="cover.html">Cover</a> <br> 
<a href="chapter10.html">Chapter 10</a> | Chapter 11 | <a href="chapter12.html">Chapter 12</a> 
</div>
<hr>
<address>
Copyright &copy; 1995-2001, David B. Lamkins<br>
All Rights Reserved Worldwide<br>
<br>
This book may not be reproduced without the written consent of its author.  Online distribution is restricted to the author's site.
</address> 
</body> </html>