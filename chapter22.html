<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Successful Lisp - Chapter 22</title>
</head> 

<body bgcolor="white" text="black">
<h1>Глава 22 - Как найти обходной путь, Часть 3</h1> 

<P>
В <a href="chapter10.html">Главе 10</a> мы узнали о двух функциях, 
которые можно использовать для изучения объектов Lisp: <code>DESCRIBE</code> и 
<code>INSPECT</code>. Они доступны в каждой реализации, так что вы должны
научиться как их использовать, даже просто на тот случай, если когда-нибудь 
окажетесь  за консолью перед новой и неизвестной системой Lisp.


<p>
Некоторые системы Lisp предлагают дополнительные инструменты, которые не 
являются частью ANSI Common Lisp. Иногда дополнительные инструменты встроены, 
а в других случаях они предоставляются поставщиком, но не устанавливаются по 
умолчанию. В этой главе я расскажу вам немного об этих инструментах, чтобы 
вы знали, что искать.

<p>
В дополнение к изучению структуры и взаимосвязей объектов иногда полезно 
"hook in/подсоединиться" к поведению определенных функций. Возможно, вы 
просто захотите узнать, когда- или вызывается ли- функция с определенными аргументами. 
Трассировка(<code>TRACE</code>) всегда в вашем распоряжении (см.
<a href="chapter16.html">Главу 16</a>), но вы можете быть заинтересованы только 
в одном конкретном вызове из тысяч; создание выходных данных трассировки (не говоря уже о том, 
чтобы просеивать их позже) может занять очень много времени. В таких случаях некоторые 
реализации Lisp позволяют <em>advise</em>(советовать новое поведение?) существующую функцию без изменения ее 
исходного кода.

<h2>Просмотрщики классов и методов помогут вам найти дорогу в море объектов</h2>

<p>
Когда вы программируете большую систему с помощью CLOS, особенно если 
система развивается с течением времени, как это делают многие, вам 
понадобится инструмент, который поможет вам изучить отношения между классами. 
Некоторые системы Lisp предоставляют браузер, который отображает эти отношения 
графически. Вот пример того, что браузер моей системы отображает подклассы
класса <code>ARRAY</code>:

<p><img src="gifs/array-class-hierarchy.gif">

<p>
Еще один полезный инструмент, браузер методов, позволяет изучить 
все специализации конкретного метода. Браузер может позволить вам 
фильтровать по определенным квалификаторам (мы узнали о квалификаторах в 
<a href="chapter14.html">Главе 14</a>) и почти наверняка предоставит 
вам навигационный доступ к определениям выбранных методов. Вот список из 
браузера методов в моей системе Lisp; я запросил список всех методов 
<i>INITIALIZE-INSTANCE</i>, имеющих квалификатор <code>:AROUND</code>:

<p><img src="gifs/method-browser-list.gif">

<p>
Помните, что методы не принадлежат классам, поэтому у нас есть 
отдельные браузеры. (Некоторые браузеры дают вам возможность перемещаться 
по совпадающим связям между классами и методами, например, изучая классы, 
используемые для специализации аргументов к методу.)

<h2>ADVISE позволяет вам изменять повдение функции без изменения функции</h2>

<p>
Некоторые системы Lisp включают в себя возможность <code>ADVISE</code>. 
Она позволяет перехватывать вызовы существующих функций. Вы можете предоставить код, 
который проверяет (и, возможно, изменяет) Аргументы и результаты функции. 
<code>ADVISE</code> имеет много применений, большинство из них придумано под 
влиянием момента. Тем не менее, одним из распространенных способов использования 
<code>ADVISE</code> является реализация <code>TRACE</code> или
<code>BREAK</code> , которые обусловлены конкретными аргументами 
или результатами.

<p>
Синтаксис и параметры <code>ADVISE</code> варьируются от системы к системе. 
Вот пример определения <code>ADVISE</code> в одной конкретной реализации:

<pre>
(advise fibonacci
        (when (zerop (first arglist)) (break))
        :when :before
        :name :break-on-zero)
</pre> 

<p>
В этом примере показано, как можно advise функцию <code>FIBONACCI</code>, 
добавляя код, который вызывает(break) в отладчик, когда первый аргумент 
<code>FIBONACCI</code> равен нулю. Обратите внимание, что нам не нужно 
никаких знаний или доступа к исходному коду <code>FIBONACCI</code>, 
чтобы добавить этот advise.


<p>
Эта конкретная реализация <code>ADVISE</code> связывает список 
всех аргументов инспектируемой(advised) функции  в переменную с 
именем <code>ARGLIST</code>. Аргументы ключевые слова объявляют, 
что форма advise  <code>(WHEN (ZEROP (FIRST ARGLIST)) (BREAK))</code> 
должна выполняться <em>перед</em> каждым вызовом <code>FIBONACCI</code>. 
Advice имеет название <code>:BREAK-ON-ZERO</code>; это имя используется 
при удалении advise (обычно через форму <code>UNADVISE</code>) или 
при переопределении поведения конкретного advise.

<h2>WATCH позволяет вам открыть окно с интересными вам переменными</h2>

<p>
Инструмент наблюдения(<em>watch</em>), который реже встречается в системах Lisp, 
позволяет отображать текущее состояние переменной во время выполнения программы. 
Детали сильно различаются. Реализация может дать вам выборочное отображение 
в реальном времени или замедлить работу программы, чтобы дать вам точное отображение 
каждого изменения. Иногда наблюдатель(watcher) интегрируется с отладчиком или степпером, 
а в других случаях он является независимым инструментом. Обратитесь к документации 
вашего поставщика, чтобы узнать, есть ли в вашей системе Lisp инструмент наблюдения(watch).

<hr>
<div align="center">
<a href="contents.html">Contents</a> | <a href="cover.html">Cover</a> <br> 
<a href="chapter21.html">Chapter 21</a> | Chapter 22 | <a href="chapter23.html">Chapter 23</a> 
</div>
<hr>
<address>
Copyright &copy; 1995-2001, David B. Lamkins<br>
All Rights Reserved Worldwide<br>
<br>
This book may not be reproduced without the written consent of its author.  Online distribution is restricted to the author's site.
</address> 
</body> </html>