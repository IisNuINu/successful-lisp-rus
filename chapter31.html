<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<title>Successful Lisp - Chapter 31</title>
</head> 

<body bgcolor="white" text="black">
<h1>Глава 31 - Обработка больших проектов на 
Lisp</h1> 

<P>
Эта книга-в первую очередь учебник, призванный дать вам достаточно понимания Lisp, 
чтобы начать писать свои собственные программы. В конце концов, вы окажетесь в 
ситуации, когда вам придется сотрудничать с другими программистами, чтобы 
реализовать более крупную систему. Стратегии и инструменты, используемые 
для организации программ Lisp для крупных проектов и командных усилий, 
аналогичны тем, которые используются для других языков. Главное отличие 
заключается в том, что инструменты координации являются частью той же 
среды, в которой вы разрабатываете свою программу.

<h2>Пакеты хранят ваши и имена отдельно от моих имен</h2>

<p>
Одна из первых задач при групповой разработке - избегать коллизий пространств имен. 
Вам не нужно опрашивать всех остальных программистов, чтобы убедиться, что никто 
еще не использовал имя, которое вы собираетесь дать программе, которую 
собираетесь написать. Это прервало бы не только ход ваших мыслей, но и 
всех программистов. Альтернатива-игнорировать проблему пространства имен 
и разрешать коллизии во время интеграции - еще более непривлекательна.

<p>
Один из проверенных и верных подходов, используемый во многих организациях, 
заключается в том, чтобы дать каждой подсистеме уникальный префикс для ее 
экспортируемых имен. Ваша работа как программиста заключается в том, чтобы 
прикрепить соответствующий префикс к имени каждой подпрограммы, которую вы 
пишете для данной подсистемы. Как и другие подходы, этот одновременно раздражает 
и хрупок. Префиксы, как правило, являются аббревиатурами (для экономии набора текста);
проектировщики систем, как правило, особенно плохо предвидят будущие события-
в конечном счете, вам придется делать исключения из правила именования префиксов, 
чтобы приспособиться к новым разработкам, и с этими исключениями приходит 
дополнительное умственное усилие отслеживать другую часть информации, которая 
не имеет ничего общего с решением проблемы.

<p>
Объектно-ориентированные языки, по крайней мере, дают вам область 
действия класса для именования, но это только отдаляет стратегию 
предотвращения конфликтов куда-то еще.

<p>
Система пакетов Lisp (см. <a href="chapter03-10.html">Главу 3, Урок 10</a>) 
позволяет разбивать пространства имен на разделы независимо от других языковых
конструкций. Если вы действительно хотите дать каждому программисту свободу 
творить без накладных расходов на координацию по вопросам, не связанным с 
решением проблем,вы можете дать каждому программисту свой собственный пакет. 
Когда подсистемы будут завершены, вы можете выполнить интеграцию, обратившись 
к квалифицированным именам общедоступных API каждой подсистемы. При использовании 
этого подхода нет никаких когнитивных накладных расходов при построении подсистемы,
никаких переделок, необходимых при интеграции, и никаких накладных расходов времени
выполнения в поставляемом продукте.

<p>
Пакет ключевых слов (помните, что ключевые слова-это символы с пустым 
именем пакета, например <code>:FOO</code>) полезен для символов, которые 
используются только для их идентификации. Без связанного кода или данных 
символ может быть легко разделен между всеми подсистемами.

<h2>Сборщики систем позволяют описывать зависимости</h2>

<p>
Лисп еще не имеет стандартного декларативного способа описания процесса 
построения системы из ее исходных файлов(книга очень старая, см. ASDF). 
В большинстве проектов используется один из двух подходов:


<ol>
<li>создание системного загрузчика на основе форм загрузки  <code>LOAD</code> 
    (а иногда и компиляции <code>COMPILE-FILE</code>)
<li>использование доморощенного или заимствованного декларативного 
    системного конструктора
</ol> 

<p>
Оба подхода имеют свои достоинства. Для небольших систем вполне применим 
наивный подход, основанный на <code>LOAD</code>. По мере того как системы 
становятся больше, вы обнаружите растущее давление для перезагрузки 
минимального набора файлов, необходимых для обновления вашего рабочего образа 
Lisp из измененных источников. А введение определений макросов означает, что файлы,
использующие макросы, должны будут перезагружаться всякий раз, когда исходный код
определения макросов изменяется. В конечном счете, сложность отслеживания этих
зависимостей с помощью специального кода загрузчика перевесит боль построения, 
обучения или адаптации декларативного системного конструктора.

<p>
Существует несколько таких программ, которые в совокупности называются 
<code>DEFSYSTEM</code>. Некоторые производители Лисп включает <code>DEFSYSTEM</code>
с их продуктом. Другие доступны в виде исходного кода с сайтов архива Lisp. 
Настройка или адаптация обычно требуется для <code>DEFSYSTEM</code>, которые 
не поставляются поставщиком; было бы разумно посмотреть, адаптировал ли кто-то 
уже <code>DEFSYSTEM</code> к вашей конкретной среде.


<p>
Далее в этой главе мы рассмотрим еще один способ отслеживания 
зависимостей файлов.

<h2>Системы контроля версий отслеживают множество ревизий</h2>

<p>
Вы когда-нибудь меняли файл, сохраняли его, а затем обнаруживали, что сломали 
что-то настолько сильно, что вам захотелось вернуться к предыдущей версии файла 
и начать все сначала? В этом вам может помочь система управления исходным кодом.


<p>
В Lisp нет стандарта для управления исходным кодом, и вряд ли он появится 
в ближайшее время. Системы управления исходным кодом обычно предоставляются 
в качестве важного инструмента программирования, независимого от среды Lisp. 
Некоторые поставщики Lisp предлагают способ управления системой управления 
исходным кодом из среды Lisp.

<p>
Для проектов, в которых участвует более одного программиста, система управления 
исходным кодом дает дополнительные преимущества; большинство таких систем 
позволяют программисту зарезервировать файл, который он намеревается 
отредактировать. Зарезервированный файл не может быть отредактирован 
никаким другим программистом. Кроме того, процесс резервирования файла 
обычно создает локальную редактируемую копию для программиста, вносящего 
изменения; другие программисты видят предыдущую, неотредактированную 
копию файла. Когда программист завершает (и, конечно же, тестирует) 
изменения, он возвращает завершенный файл в систему управления исходным 
кодом, что делает новое содержимое файла доступным для всех программистов 
и позволяет любому человеку зарезервировать файл для нового раунда обновлений.

<p>
Я настоятельно рекомендую вам найти и использовать систему управления 
исходным кодом. Эти усилия принесут дивиденды за то время, которое 
вы не потратите на восстановление утраченных изменений исходного кода.

<h2>Модули: еще один способ описания файловых зависимостей</h2>

<p>
Lisp на самом деле имеет рудиментарную систему поддержания зависимостей 
файлов. Я не упоминал о системе модулей ранее, потому что она устарела; 
она может быть удалена, заменена или дополнена в какой-то будущей редакции 
спецификации Lisp. Я также не упомянул модульную систему, потому что она 
имеет довольно ограниченную выразительную силу. Модульная система лучше 
всего подходит для готовых, стабильных систем; она не обладает достаточной
функциональностью, чтобы поддерживать инкрементную разработку программ 
полезным образом. Учитывая все эти предостережения, давайте кратко 
рассмотрим их ...

<h2>PROVIDE и REQUIRE</h2>

<p>
<code>PROVIDE</code> и <code>REQUIRE</code> -это единственный 
стандартизированный интерфейс для модульной системы Lisp. 
Форма <code>(REQUIRE</code> <i>name</i><code>)</code> сообщает Lisp, 
что необходим файл, связанный с именем <i>name</i>, если он уже 
загружен, <code>REQUIRE</code> ничего не делает, иначе он загружает файл. 
Загруженный файл должен в какой-то точке содержать форму верхнего уровня 
<code>(PROVIDE</code> <i>name</i><code>)</code>; она информирует систему 
модулей о том, что модуль, связанный с <i>name</i>, был загружен.


<p>
Средства, с помощью которых система Lisp находит файл в соответствии с именем
(<i>name</i>), зависят от реализации; обычно имя сопоставляется с исходным или 
объектным файлом в текущем каталоге.

<p>
Самая большая проблема с этой модульной системой заключается в том, 
что она не предназначена для обработки инкрементных изменений программы; 
она лучше подходит для загрузки завершенной, стабильной системы. Как 
только необходимый файл будет загружен,он никогда не будет перезагружен. 
(Ваш поставщик может предоставить вам достаточно информации, чтобы 
переопределить это поведение, но вы не можете полагаться на него.)


<p>
Конечно, если вы используете специальный загрузчик или <code>DEFSYSTEM</code> 
во время разработки программы, то есть мало причин не поставлять систему, 
используя тот же подход к загрузке. Более того, некоторые среды Lisp 
позволяют вам сбросить образ вашего мира Lisp на диск, что позволяет 
загружать систему без наличия исходных или объектных файлов вообще. 
В любом случае, нет никаких веских причин использовать <code>PROVIDE</code> 
и <code>REQUIRE</code>.

<hr>
<div align="center">
<a href="contents.html">Contents</a> | <a href="cover.html">Cover</a> <br> 
<a href="chapter30.html">Chapter 30</a> | Chapter 31 | <a href="chapter32.html">Chapter 32</a> 
</div>
<hr>
<address>
Copyright &copy; 1995-2001, David B. Lamkins<br>
All Rights Reserved Worldwide<br>
<br>
This book may not be reproduced without the written consent of its author.  Online distribution is restricted to the author's site.
</address> 
</body> </html>