<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<title>Successful Lisp - Chapter 20</title>
</head> 

<body bgcolor="white" text="black">
<h1>Глава 20 - Этикет(свод правил правильных действий) Макросов</h1> 

<P>
Макросы в Lisp гораздо более эффективны, чем макросы в других языках программирования. 
Вместо того, чтобы просто предоставлять простую стенографическую нотацию, макросы Lisp 
дают вам возможность действительно расширить язык. В этой главе мы познакомимся с 
возможностями макросов по преобразованию программы, так как увидим, как правильно 
строить макросы для решения самых разнообразных задач.

<h2>Макросы это программы, которые генерируют программы</h2>

<p>
Упомяните макросы большинству программистов, возможно даже вам, 
и первое, что приходит на ум, - это подстановка строк - вы используете 
макрос, чтобы склеить несколько параметров по-новому, возможно, с небольшим 
количеством принятий решений во время компиляции. А из-за типичного (в других 
языках, кроме Lisp) несоответствия между макроязыком и языком программирования 
сложность написания макроса возрастает гораздо быстрее, чем его сложность.

<p>
На Лиспе макросы это Lisp программы, которые порождают другие программы 
на Лиспе. Сгенерированный код Lisp имеет полностью заключенную в скобки нотацию, 
как и макрос, который генерирует код. В простейшем случае макрос заменяет 
формы внутри шаблона, четко устанавливая визуальное соответствие между 
генерирующим и генерируемым кодом. Сложные макросы могут использовать 
всю мощь языка Lisp для генерации кода в соответствии с параметрами макросов; 
часто шаблонная форма оборачивается в код, который создает соответствующие подформы, 
но даже этот подход является всего лишь типичным шаблоном использования, а не 
требованием (или ограничением) макросреды Lisp.

<p>
В следующих разделах мы рассмотрим механизм, с помощью которого система 
Lisp преобразует код, созданный макросом, а затем рассмотрим несколько 
все более сложных примеров макросов. Мы закончим эту главу сравнением 
макросов с использованием встроенных объявлений функций.



<h2>Крупным планом: как работают макросы</h2>

<p>
Вы определяете макрос с помощью формы <code>DEFMACRO</code>, например:

<pre>
(defmacro <i>name</i> (<i>arguments</i> ...)
  <i>body</i>)
</pre> 

<p>
<code>DEFMACRO</code>  похож на <code>DEFUN</code>, но вместо того, чтобы 
возвращать значения, тело <code>DEFMACRO</code> возвращает форму Lisp. 
(Как мы вскоре увидим, существует очень простой способ генерировать эту форму 
с выбранными подформами, замененными параметрами из вызова макроса или 
вычисленными программой макроса.)

<p>
Ваша программа "вызывает" макрос точно так же, как она вызывает функцию, 
но поведение совершенно другое. Во-первых, ни один из параметров макроса 
не вычисляется. Никогда. Параметры макроса буквально привязаны к соответствующим 
аргументам в определении макроса. Если вы передадите <code>(* 7 (+ 3 2))</code> 
в макрос, аргумент в теле определения макроса будет привязан к списку литералов 
<code>(* 7 (+ 3 2))</code>, а не значению 35.

<p>
Затем вызывается <em>macro expander</em>(расширитель макроса), который 
получает все фактические параметры, привязанные к их соответствующим аргументам, 
как указано в форме <code>DEFMACRO</code>. Расширитель макроса - это просто 
тело формы <code>DEFMACRO</code>, которая является просто кодом Lisp; 
единственная загвоздка заключается в том, что система Lisp ожидает, что 
расширитель макроса вернет форму Lisp.

<p>
Затем система Lisp вычисляет некоторую форму, которую возвращает расширитель макроса. 
Если возвращаемая форма является макросом, она также расширяется. В противном случае 
форма вычисляется по правилам, которые мы впервые изучили в  
<a href="chapter03-02.html">главе 3, Урок 2</a>.

<blockquote>
Предыдущий абзац является концептуально правильным. Однако реализация 
Lisp может расширять макросы в разное время. Макрос может быть расширен 
только один раз, когда ваша программа компилируется. Или же он может быть 
расширен при первом использовании по мере запуска вашей программы, и 
расширение может быть кэшировано для последующего повторного использования. 
Или макрос может быть расширен каждый раз, когда он используется. Правильно 
написанный макрос будет вести себя одинаково во всех этих реализациях..
</blockquote> 

<p>В <a href="chapter21.html">Главе 21</a> мы подробно остановимся на 
некоторых вещах, которые вы можете выразить с помощью списков аргументов.

<h2>Цитирование(Backquote) обратной кавычкой выглядит как шаблон подстановки</h2>

<p>
Самый простой способ создать форму в теле вашего расширителя макросов 
- это использовать макрос чтения <em>backquote</em> (<code>`</code>). 
Он ведет себя как макрос чтения <em>quote</em> (<code>'</code>), 
за исключением тех случаев, когда в форме обратной кавычки
появляется запятая (<code>,</code>).

<blockquote>
Запятая допускается только в форме обратной кавычки. Если вы используете 
запятую в форме кавычек, Lisp будет сигнализировать об ошибке при 
чтении формы.
</blockquote> 

<p>
Как и quote, backquote(обратная цитата) подавляет вычисления. Но запятая в 
форме с backquote(обратными кавычками) "разрешает" вычисление 
только для последущей подформы.

<pre>
? `(The sum of 17 and 83 is ,(+ 17 83))
(THE SUM OF 17 AND 83 IS 100)
</pre> 

<p>
Сравните предыдущий пример, в котором использовалась backquote(обратная кавычка),
с аналогичной формой, использующей quote(кавычку) (и опуская запятую).

<pre>
? '(The sum of 17 and 83 is (+ 17 83))
(THE SUM OF 17 AND 83 IS (+ 17 83))
</pre> 

<p>
Вы, вероятно, можете себе представить, как backquote и comma(запятая) предоставляют 
шаблону возможности подстановки. Это как раз то, что нам нужно для нашего макрорасширителя. 
Вот несколько простых примеров.

<pre>
<i>; Define the macro</i> 
? (defmacro swap (a b) <i>; NOTE: This is a restricted version of ROTATEF</i> 
    `(let ((temp ,a))
       (setf ,a ,b)
       (setf ,b temp)))
SWAP

<i>; First invocation</i> 
? (let ((x 3)
        (y 7))
    (swap x y) <i>; macro call</i> 
    (list x y))
(7 3)
<i>; Let's see the form generated by SWAP:</i> 
? (pprint (macroexpand-1 '(swap x y)))

(LET ((TEMP X))
  (SETF X Y)
  (SETF Y TEMP))

<i>; Second invocation</i> 
? (let ((c (cons 2 9))) <i>; (2 . 9)</i> 
    (swap (car c) (cdr c))
    c)
(9 . 2)
<i>; And the expansion of its macro call</i> 
? (pprint (macroexpand-1 '(swap (car c) (cdr c))))

(LET ((TEMP (CAR C)))
  (SETF (CAR C) (CDR C))
  (SETF (CDR C) TEMP))

<i>; Here's the second invocation again, "macroexpanded" by hand.</i> 
? (let ((c (cons 2 9)))
    (LET ((TEMP (CAR C)))
      (SETF (CAR C) (CDR C))
      (SETF (CDR C) TEMP))
    c)
(9 . 2)
</pre> 

<p>
<code>(PPRINT (MACROEXPAND-1 '<i>macro-call</i>))</code>  - это очень 
удобный инструмент для просмотра того, какую форму генерирует ваш расширитель макросов. 
(Не волнуйтесь, если вывод из вашей системы Lisp выглядит не совсем так, как показано здесь; 
могут быть некоторые различия в компоновке.)

<p>
Когда вы смотрите на эти примеры, важно отметить, что:

<ol>
<li>аргументы макроса получают буквальное представление своих фактических 
параметров из вызова макроса, и

<li>аргументы макроса, которым предшествует запятая в форме обратной кавычки, 
заменяются литеральным представлением параметра из вызова макроса.
</ol> 

<p>
Вот еще несколько определений макросов. Поэкспериментируйте с ними в вашей системе Lisp, 
чтобы увидеть, что они делают.

<pre>
(defmacro sortf (place)
  `(setf ,place (sort ,place)))

(defmacro togglef (place)
  `(setf ,place (not ,place)))

(defmacro either (form1 form2)
  <i>; (random 2) returns 0 or 1</i> 
  `(if (zerop (random 2)) ,form1 ,form2))
</pre> 

<h2>Не очевидное, часть 1: вычислить, а затем сгенерировать</h2>

<p>
Макросы начинают становиться интересными, когда они делают больше, 
чем простая текстовая подстановка. В этом разделе мы рассмотрим реальный 
пример использования макроса для расширения Lisp в проблемной области. 
В дополнение к предоставлению расширителя макросов, наш новый макрос 
автоматически создаст среду/окружение, на которую будет ссылаться расширитель. 
В нашем примере будет показано, как перемещать вычисления из среды выполнения на
время компиляции и как обмениваться информацией, вычисленной во время компиляции.

<p>
Предположим, вы работаете над интерактивной игрой, которая широко 
использует тригонометрическую функцию <em>sine r</em> в вычислении 
движения и взаимодействия игроков. Вы уже определили, что вызов функции 
Lisp <code>SIN</code> занимает слишком много времени; вы также знаете, 
что ваша программа будет работать просто отлично с приблизительными результатами 
для вычисления <em>sine r</em>. вы хотели бы определить макрос <code>LOOKUP-SIN</code>
для выполнения поиска в таблице во время выполнения; вы также хотели бы скрыть детали 
генерации таблиц, детали реализации, с которыми вы предпочли бы не загромождать 
исходный код вашей программы.

<p>
Ваш макрос будет вызваный как 
<code>(LOOKUP-SIN</code> <var>radians</var> <var>divisions</var><code>)</code>, 
где <var>radians</var> всегда находится в диапазоне от нуля до одной четверти pi, 
а <var>divisions</var>-это количество дискретных значений, доступных как результат
<code>LOOKUP-SIN</code>. Во время выполнения расширитель макросов просто вычислит 
индекс в таблице подстановки и вернет значение из этой таблицы. Таблица будет сгенерирована 
во время компиляции (в большинстве систем Lisp). Кроме того, для заданного значения 
делений(<var>divisions</var>) в вызове макроса будет сгенерирована только одна таблица.

<p>
Вот вам и код. Комментарии и строки документации должны помочь вам понять код, 
когда вы его читаете. Я приведу дальнейшие объяснения ниже.

<pre>
<i>;; This is where we cache all of the sine tables generated</i> 
<i>;; during compilation. The tables stay around at runtime</i> 
<i>;; so they can be used for lookups.</i> 
(defvar *sin-tables* (make-hash-table)
  "A hash table of tables of sine values. The hash is keyed
by the number of entries in each sine table.")

<i>;; This is a helper function for the LOOKUP-SIN macro.</i> 
<i>;; It is used only at compile time.</i> 
(defun get-sin-table-and-increment (divisions)
  "Returns a sine lookup table and the number of radians quantized
by each entry in the table. Tables of a given size are reused.
A table covers angles from zero to pi/4 radians."
  (let ((table (gethash divisions *sin-tables* :none))
        (increment (/ pi 2 divisions)))
    (when (eq table :none)
      <i>;; Uncomment the next line to see when a table gets created.</i> 
      <i>;;(print '|Making new table|)</i> 
      (setq table
            (setf (gethash divisions *sin-tables*)
                  (make-array (1+ divisions) :initial-element 1.0)))
      (dotimes (i divisions)
        (setf (aref table i)
              (sin (* increment i)))))
    (values table increment)))

<i>;; Macro calls the helper at compile time, and returns an</i> 
<i>;; AREF form to do the lookup at runtime.</i> 
(defmacro lookup-sin (radians divisions)
  "Return a sine value via table lookup."
  (multiple-value-bind (table increment)
                       (get-sin-table-and-increment divisions)
    `(aref ,table (round ,radians ,increment))))
</pre> 

<p>
Если вы все еще не видите смысла всего этого кода после прочтения
введения к этому разделу и комментариев в коде, вот он: 
когда ваша программа запускается, она выполняет только <code>AREF</code> 
(и связанный с ним <code>ROUND</code>), чтобы найти значение <em>sin r</em>.

<pre>
? (pprint (macroexpand-1 '(lookup-sin (/ pi 4) 50)))

(AREF #(0.0 0.0314107590781283 0.06279051952931337 
        <i>[additional entries not shown]</i> 
        0.9980267284282716 0.9995065603657316 1.0)
      (ROUND (/ PI 4) 0.031415926535897934))
<i>;; Note that the macro call makes no mention of a lookup table.</i> 
<i>;; Tables are generated as-needed by (and for) the compiler.</i> 
? (lookup-sin (/ pi 4) 50)
0.7071067811865476
</pre> 

<p>В макрорасширении <code>#(...)</code>- это печатное представление таблицы поиска 
для 50 делений четверти круга. Эта таблица хранится в хэш-таблице <code>*SIN-TABLES*</code>,
где она совместно используется каждым вызовом макроса 
<code>(LOOKUP-SIN</code> <var>angle</var> <code>50)</code>. Нам даже не нужно делать хэш-поиск во время выполнения, потому что расширитель макросов захватил свободную 
<code>TABLE</code> из формы  <code>MULTIPLE-VALUE-BIND</code> в 
<code>LOOKUP-SIN</code>.

<h2>Не очевидное, часть 2: макросы, которые определяют макросы</h2>

<p>
Макросы, которые определяют макросы, используются нечасто, отчасти потому, 
что трудно придумать хорошее применение для этой техники, а отчасти потому, 
что ее трудно использовать правильно. Следующий макрос, основанный на примере 
книги <a href="chapter33.html#graham94">Пола Грэма "On Lisp"</a> , может быть 
использован для определения синонимов имен функций Lisp, макросов и 
специальных форм.

<pre>
? (defmacro defsynonym (old-name new-name)
    "Define OLD-NAME to be equivalent to NEW-NAME when used in
the first position of a Lisp form."
    `(defmacro ,new-name (&amp;rest args)
       `(,',old-name ,@args)))
DEFSYNONYM
? (defsynonym make-pair cons)
MAKE-PAIR
? (make-pair 'a 'b)
(A . B)
</pre> 

<p>
Макросы всегда немного опасны, потому что код, содержащий вызов макроса, 
не обновляется автоматически при изменении определения макроса. Вы всегда 
можете установить свое собственное соглашение, чтобы помочь вам помнить, 
что вам нужно перекомпилировать определенный код после изменения определения 
макроса. Но всегда есть вероятность, что вы забудете или совершите ошибку.

<p>
В конечном счете, вероятность того, что вы случайно получите код, 
который был скомпилирован со старой версией макроса, прямо пропорциональна тому, 
как часто вы будете менять макрос. Мне, вероятно, никогда не придется менять 
макрос <code>LOOKUP-SIN</code> из предыдущего раздела, Как только он будет 
определен и заработает. С другой стороны, такой макрос, как <code>DEFSYNONYM</code>, 
практически напрашивается на повторное использование при создании нового кода. 
Если вы измените свое мнение о старом имени, чтобы связать его с заданным новым 
именем, весь ваш ранее скомпилированный код будет по-прежнему ссылаться на
 старое имя, которое вы выбрали ранее.

<pre>
<i>;; WARNING: This example illustrates a practice to avoid!</i> 

<i>;; Here's some core algorithm</i> 
? (defun process-blah-using-algorithm-zark (...) ...)
PROCESS-BLAH-USING-ALGORITHM-ZARK

<i>;; And here's where I use the algorithm, perhaps calling it</i> 
<i>;; from many other places in DO-STUFF besides the one I've shown.</i> 
? (defun do-stuff (...)
    ...
    (process-blah-using-algorithm-zark ...)
    ...)
DO-STUFF
<i>;; Try it out...</i> 
? (do-stuff ...)
[results based upon process-blah-using-algorithm-zark]
<i>;; OK, this looks good.  But I think I'll clean up the</i> 
<i>;; appearance of DO-STUFF by defining an abbreviation</i> 
<i>;; for that really long core algorithm name.</i> 
? (defsynonym process-blah-using-algorithm-zark proc)
PROC
<i>;; Now I'll rewrite DO-STUFF to use the abbreviation.</i> 
? (defun do-stuff (...)
    ...
    (proc ...)
    ...)
DO-STUFF
<i>;; And make sure it still works.</i> 
? (do-stuff ...)
[results based upon process-blah-using-algorithm-zark]

<i>... Some time later ...</i> 

<i>;; Oh, here's a better core algorithm.</i> 
? (defun process-blah-using-algorithm-glonkfarkle (...) ...)
PROCESS-BLAH-USING-ALGORITHM-GLONKFARKLE
<i>;; I'll change the synonym for PROC to 'be' the new algorithm.</i> 
? (defsynonym process-blah-using-algorithm-glonkfarkle proc)
PROC

<i>... Some time later ...</i> 

<i>;; Time to use DO-STUFF again...</i> 
? (do-stuff ...)
[results based upon process-blah-using-algorithm-zark]
<i>;; Hey!! These results don't seem to use the new algorithm.</i> 
<i>;; What could be wrong?  The code LOOKS right...</i> 
</pre> 

<p>Проблема, конечно, заключается в том, что второе использование <code>DEFSYNONYM</code> 
переопределило макрос <code>PROC</code>, и я не заметил, что <code>DO-STUFF</code> нужно было
перекомпилировать, чтобы подхватить измененное определение.

<blockquote> 
Мой совет: не пытайтесь быть умным, используя макросы, такие как <code>DEFSYNONYM</code>. 
Придерживайтесь описательных имен настолько длинных, насколько это необходимо, и 
используйте редактор, поддерживающий завершение символов (см. 
<a href="chapter27.html">Главу 27</a>). Помните, что есть только один способ не 
сокращать имя; использование сокращений увеличивает вероятность того, что вы будете 
использовать неправильное имя.
</blockquote> 

<h2>Хитрости торговли: избежать захвата с помощью исопользования GENSYM</h2>

<p>
Вы должны быть осторожны, когда определяете макрос, который вводит новые переменные 
в его расширении. Макрос <code>REPEAT</code>, приведенный ниже, предлагает нам сокращенный 
способ повторения тела кода определенное количество раз.

<pre>
? (defmacro repeat (times &amp;body body)
    `(dotimes (x ,times)
       ,@body))
REPEAT
? (repeat 3 (print 'hi))

HI
HI
HI
NIL
</pre> 

<p>
Этот код, кажется, делает правильные вещи, но переменная <code>X</code> будет 
вызывать проблемы. Следующий пример <em>должен</em> дать нам те же результаты, 
что и предыдущий.

<pre>
? (setq x 'hi)
HI
? x
HI
? (repeat 3 (print x))

0
1
2
NIL
</pre> 

<p>
Переменная <code>X</code> в расширителе макросов затеняет
глобальный <code>X</code>, на который мы пытались ссылаться в теле. 
Другой способ сказать это состоит в том, что <code>X</code> свободен 
в теле формы <code>REPEAT</code>, но он был захвачен определением <code>X</code>
в макрорасширителе; это препятствует тому, чтобы тело формы достигло 
предполагаемой переменной <code>X</code>.

<p>
Очевидным решением является использование другого имени переменной 
в расширителе макросов - такого, которое не будет конфликтовать с 
любым именем, которое мы когда-либо будем использовать в нашем коде, 
вызывающем макрос <code>REPEAT</code>. Вы можете подумать, что какое-то 
соглашение об именовании будет работать, но всегда есть шанс, что какой-то 
программист придет позже и нарушит это соглашение. Нам нужен надежный подход.


<p>
Lisp предоставляет функцию <code>GENSYM</code> для генерации символов, 
которые <em>гарантированно</em> будут уникальными. Ни один программист 
никогда не сможет написать имя символа, которое конфликтует с символом, 
созданным <code>GENSYM</code>. Вот как мы используем <code>GENSYM</code>
для создания имени переменной, необходимой в расширителе макросов для 
макроса <code>REPEAT</code>.

<pre>
? (defmacro repeat (times &amp;body body)
    (let ((x (gensym)))
      `(dotimes (,x ,times)
         ,@body)))
REPEAT
? x
HI
? (repeat 3 (print x))

HI
HI
HI
NIL
</pre> 

<p>
С помощью этого нового макроса <code>REPEAT</code> мы вычисляем новый 
символ в форме <code>LET</code> и подставляем этот символ в форме 
расширения макроса. Чтобы понять, почему это работает, давайте рассмотрим 
расширение:

<pre>
? (macroexpand-1 '(repeat 5 (print x))
(DOTIMES (#:G8524 5) (PRINT X))
</pre> 

<p>
<code>#:G8524</code> это уникальный неинтернированный(<em>uninterned</em>) символ. 
Вы можете видеть, что он неинтернирован по префиксу <code>#:</code>. Но как Лисп 
гарантирует уникальность этого символа? Считыватель Lisp гарантирует, что любой 
символ, который он читает с префиксом <code>#:</code>, уникален. 
Сравните следующее:

<pre>
? (eq 'a 'a)
T
? (eq '#:a '#:a)
NIL
</pre> 

<p>
Несмотря на то, что символы <code>#:A</code> печатаются одинаково, 
они отличаются.

<p>
Генерация имен переменных для использования в расширителях макросов имеет 
другое применение. Следующее определение макроса имеет тонкую проблему:

<pre>
? (defmacro cube (n)
    `(* ,n ,n ,n))
CUBE
? (cube 3)
27
? (let ((n 2))
    (cube (incf n)))
60
</pre> 

<p>
Во втором случае <code>(INCF N)</code> должен был предоставить <code>CUBE</code>
значение 3, и результат должен был быть идентичен первому тесту. Давайте еще раз 
взглянем на расширение, чтобы увидеть, что произошло.

<pre>
? (macroexpand-1 '(cube (incf n)))
(* (INCF N) (INCF N) (INCF N))
</pre> 

<p>
Проблема очевидна: аргумент <code>CUBE</code>  
<code>(INCF N)</code> вычисляется несколько раз. Как правило, это плохо, 
потому что это нарушает наши предположения о том, как Lisp вычисляет формы. 
Мы исправляем эту проблему, организуя для расширителя макросов вычисление 
аргумента <code>CUBE</code> только один раз.


<pre>
? (defmacro cube (n)
    (let ((x (gensym)))
      `(let ((,x ,n))
         (* ,x ,x ,x))))
CUBE
? (let ((n 2))
    (cube (incf n)))
27
</pre> 

<p>
Мы создали уникальный символ вне расширителя макросов, а затем использовали 
этот символ в расширителе в качестве имени переменной для хранения результата 
вычисления аргумента <code>CUBE</code>. Форма <code>LET</code> в расширителе макросов - 
это единственное место, где ссылаются на аргумент <code>CUBE</code>, поэтому он 
вычисляется ровно один раз для каждого вызова <code>CUBE</code>.

<h2>Макросы против встраивания(inlining)</h2>

<p>
Lisp позволяет встраивать функции с помощью компилятора. Другими словами, 
вместо компиляции вызова функции компилятор может заменить его на тело функции, 
тем самым экономя накладные расходы на вызов функции. Замена тела функции обычно 
обходится дорого с точки зрения пространства, так как код тела функции обычно длиннее 
кода ее вызывающей последовательности.

<p>
Важно понимать, что Lisp <em>позволяет</em> функциям быть встраиваемыми. 
Как и все другие объявления - за исключением объявления <code>SPECIAL</code>  -
<code>INLINE</code>(встроенное) объявление может рассматриваться компилятором 
как рекомендательное или полностью игнорироваться.

<p>
Вот несколько примеров того, как встроить функцию. В первом случае функция <code>F</code>
встроена везде, где она используется (при условии, что компилятор поддерживает встраивание функций). 
Во втором случае функция <code>P</code> компилируется с информацией для поддержки встраивания, но
встраивается только при наличии объявления, как в функции <code>Q</code>.

<pre>
<i>; Case 1 -- F may always be inlined</i> 
(declaim (inline f))
(defun f (...) ...)

(defun g (...)
  (f ...)
  ...)

(defun h (...)
  (f ...)
  ...)

<i>; Case 2 - P may be inlined only following a declaration</i> 
(declaim (inline p))
(defun p (...) ...)
(declaim (notinline p))

(defun q (...) 
  (declare (inline p))
  (p ...) <i>; inlined</i> 
  ...)

(defun r (...)
  (p ...) <i>; not inlined</i> 
  ...)
</pre> 

<p>
Макросы могут использоваться вместо <code>INLINE</code> деклараций 
в тех случаях, когда код обязательно <em>должен</em> быть встроен, 
несмотря на наличие (или отсутствие) поддержки функции встраивания
у компилятора.

<p>
В целом, однако, вы должны использовать макросы для расширения языка, 
а не для взлома эффективности. Риск того, что вы забудете выполнить перекомпиляцию 
после изменения определения макроса, может привести к трудноопределяемым ошибкам, 
которые приведут к затратам многих усилий по разработке.

<blockquote> 
Мой совет: не используйте макросы в качестве замены встраивания, 
если вы не можете найти другого способа достичь желаемой производительности; 
конечно, такие усилия должны основываться на результатах профилирования 
вашего кода (см. <a href="chapter28.html">Главу 28</a>) и предпочтительно 
только тогда, когда ваш код уже стабилен и отлажен. Вы также должны 
пересмотреть свое решение с каждым новым выпуском вашего компилятора Lisp и 
всякий раз, когда вы переносите свою программу на другую платформу Lisp.
 </blockquote> 

<hr>
<div align="center">
<a href="contents.html">Contents</a> | <a href="cover.html">Cover</a> <br> 
<a href="chapter19.html">Chapter 19</a> | Chapter 20 | <a href="chapter21.html">Chapter 21</a> 
</div>
<hr>
<address>
Copyright &copy; 1995-2001, David B. Lamkins<br>
All Rights Reserved Worldwide<br>
<br>
This book may not be reproduced without the written consent of its author.  Online distribution is restricted to the author's site.
</address> 
</body> </html>