#
# NuINu <don't@send.my>, 2020.
#
#. extracted from in/chapter14.html
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-04-19 13:50+0300\n"
"PO-Revision-Date: 2020-06-12 19:54+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter14.html:5
msgid ""
"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/"
"html4/strict.dtd\">\n"
"<html><head>\n"
"<title>Successful Lisp - Chapter 14</title>\n"
"</head> "
msgstr ""
"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/"
"html4/strict.dtd\">\n"
"<html><head>\n"
"<META http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n"
"<title>Successful Lisp - Chapter 14</title>\n"
"</head> "

#: in/chapter14.html:8
msgid ""
"<body bgcolor=\"white\" text=\"black\">\n"
"<h1>Chapter 14 - Can Objects Really Behave Themselves?</h1> "
msgstr ""
"<body bgcolor=\"white\" text=\"black\">\n"
"<h1>Глава 14 - Могут ли объекты иметь собственное \n"
"поведение?</h1> "

#: in/chapter14.html:13
msgid ""
"<P>This chapter continues the treatment of CLOS (the Common Lisp\n"
"Object System) that we began in <a href=\"chapter07.html\">Chapter\n"
"7</a>, in which we saw how objects store data. In this chapter we'll\n"
"learn about how objects get their behaviors."
msgstr ""
"<P>Эта глава продолжает рассмотрение CLOS (Common Lisp Object System), \n"
"которое мы начали в <a href=\"chapter07.html\">Главе 7</a>, в которой мы "
"видели, \n"
"как объекты хранят данные. В этой главе мы узнаем о том, как объекты "
"получают \n"
"свое поведение."

#: in/chapter14.html:15
msgid "<h2>Generic functions give objects their behaviors</h2>"
msgstr "<h2>Обобщенные функции дают объектам их поведение</h2>"

#: in/chapter14.html:21
msgid ""
"<p>A generic function provides behavior based upon the type of an\n"
"object. The behavior is selected according to the types of the arguments\n"
"to the generic function. The generic function dispatches control to a\n"
"particular method that provides the best match to the argument types\n"
"that you use to invoke the generic function."
msgstr ""
"<p>\n"
"Обобщенная функция обеспечивает поведение, основыванное на типе объекта. \n"
"Поведение выбирается в соответствии с типами аргументов обобщенной "
"функции. \n"
"Обобщенная функция передает управление определенному методу, который "
"обеспечивает \n"
"наилучшее соответствие типам аргументов, используемых для вызова обобщенной "
"функции."

#: in/chapter14.html:23
msgid "<p><img src=\"gifs/simple-gf-invocation.gif\">"
msgstr ""

#: in/chapter14.html:33
msgid ""
"<p>You define a method using Lisp's <code>DEFMETHOD</code> macro.  In its\n"
"simplest form, <code>DEFMETHOD</code> expects a name and a <em>specialized</"
"em> \n"
"lambda list.  The specialized lambda list is similar to the list of formal\n"
"parameters you supply for a <code>LAMBDA</code> or <code>DEFUN</code> form;\n"
"the difference is that you can specify the type of each parameter.  The\n"
"method will only be invoked when the generic function call (which looks\n"
"<em>exactly</em> like a function call) specifies parameters that are \n"
"of matching types.  To specialize a parameter in a <code>DEFMETHOD</code> \n"
"form, simply name the parameter and its type in a list.  For example:"
msgstr ""
"<p>\n"
"Вы определяете метод с помощью макроса  Lisp <code>DEFMETHOD</code>. \n"
"В своей простейшей форме <code>DEFMETHOD</code> ожидает имя и \n"
"специализирующий(конкретизирующий обобщенную функцию) лямбда-список. \n"
"Специализирующий лямбда-список аналогичен списку формальных параметров, \n"
"который вы предоставляете для  форм <code>LAMBDA</code> или <code>DEFUN</"
"code>; \n"
"разница заключается в том, что вы можете указать тип каждого параметра. "
"Метод \n"
"будет вызываться только тогда, когда вызов обобщенной функции (который "
"выглядит точно \n"
"так же, как вызов функции) задает параметры, соответствующие типам его "
"лямбда-\n"
"списка. Чтобы специализировать параметр в форме <code>DEFMETHOD</code> , \n"
"просто назовите параметр и его тип в списке. Например:"

#: in/chapter14.html:38
msgid ""
"<pre>\n"
"(defmethod method1 ((param1 number) (param2 string)) ...)\n"
"(defmethod method2 ((param2 float) (param2 sequence)) ...)\n"
"</pre> "
msgstr ""

#: in/chapter14.html:42
msgid ""
"<p>You can also leave the type of a parameter unspecified by just\n"
"giving its name; this kind of parameter will match <em>any</em> data type.\n"
"In this example, the first parameter is not specialized:"
msgstr ""
"<p>\n"
"Вы также можете оставить тип параметра неопределенным, просто указав его "
"имя; \n"
"этот тип параметра будет соответствовать любому типу данных. В этом примере "
"первый \n"
"параметр не является специализированным:"

#: in/chapter14.html:46
msgid ""
"<pre>\n"
"(defmethod method3 (param1 (param2 vector)) ...)\n"
"</pre> "
msgstr ""

#: in/chapter14.html:58
msgid ""
"<p>Note that the parameter types do not <em>have</em> to be CLOS\n"
"class types. If you <em>want</em> to specialize a method to one\n"
"particular CLOS class, you can specialize one of the arguments to\n"
"that class, as we saw in the first figure in this chapter. If you\n"
"have specialized one parameter to a CLOS class, and leave the other\n"
"parameters unspecialized, then you've emulated the single-dispatch\n"
"method common to certain \"classic\" object-based programming\n"
"languages. In this limited case you can think of a method as being\n"
"associated with a class.  We'll see in the next section that this\n"
"association breaks down when we associate a method with multiple\n"
"classes."
msgstr ""
"<p>\n"
"Обратите внимание, что типы параметров не обязательно должны быть типами \n"
"классов CLOS. Если вы хотите специализировать метод для одного конкретного \n"
"класса CLOS, вы можете специализировать один из аргументов для этого "
"класса, \n"
"как мы видели на первом рисунке в этой главе. Если вы специализировали "
"один \n"
"параметр для класса CLOS, а остальные параметры оставили "
"неспециализированными, \n"
"то вы эмулировали метод одиночной отправки(single-dispatch), общий для "
"некоторых\n"
"\"классических\" объектно-ориентированных языков программирования. В этом "
"ограниченном\n"
"случае вы можете думать о методе как о связанном с классом. В следующем "
"разделе \n"
"мы увидим, что эта ассоциация разрушается, когда мы связываем метод с "
"несколькими\n"
"классами."

#: in/chapter14.html:69
msgid ""
"<p>You're probably wondering how generic functions get created, when all\n"
"you do is to define methods. When you define a method, Lisp creates a\n"
"generic function if one does not already exist. When Lisp creates this\n"
"generic function for you, it makes note of the name, the number of\n"
"required and optional arguments, and the presence and names of keyword\n"
"parameters. When you create another method of the same name, it must\n"
"agree with the generic function on the details of the parameters which\n"
"were recorded in the generic function.  This agreement is called \n"
"<em>lambda list congruence</em> -- Lisp will signal an error if you\n"
"attempt to create a new method with a non-congruent lambda list."
msgstr ""
"<p>\n"
"Вы, вероятно, задаетесь вопросом, как создаются обобщенные функции, когда \n"
"все, что вы делаете, - это определяете методы. При определении метода Lisp \n"
"создает обобщенную функцию, если она еще не существует. Когда Lisp создает "
"эту\n"
"обобщенную универсальную функцию для вас, он отмечает имя, количество "
"обязательных и необязательных аргументов, а также наличие и имена ключевых "
"параметров. Когда вы \n"
"создаете другой метод с таким же именем, он должен согласовать с обобщенной "
"функцией\n"
"детали параметров, которые были записаны в обобщенной функции. Это "
"соглашение называется\n"
"Lambda list congruence(совпадение лямбда-списков) - Lisp будет "
"сигнализировать об ошибке,\n"
"если вы попытаетесь создать новый метод с несоответсвующим лямбда-списком."

#: in/chapter14.html:71
msgid "<h2>The line between methods and objects blurs for multimethods</h2>"
msgstr ""
"<h2>Граница между методами и объектами размывается для мультиметодов</h2>"

#: in/chapter14.html:76
msgid ""
"<p>A multimethod is a method that is selected based upon the types of\n"
"two or more of its arguments. When you have a method that is selected\n"
"for two or more classes, then we can't really say that a class (or an\n"
"object, which is an instance of that class) \"has\" a particular method."
msgstr ""
"<p>\n"
"Мультиметод - это метод, который выбирается на основе типов двух или более \n"
"его аргументов. Если у вас есть метод, выбранный для двух или более "
"классов, \n"
"то мы не можем действительно сказать, что класс (или объект, который "
"является \n"
"экземпляром этого класса) \"имеет\" определенный метод."

#: in/chapter14.html:78
msgid "<h2>Methods on non-objects?  So where does the method live?</h2>"
msgstr "<h2>Методы на не-объектах?  Так где же живет этот метод?</h2>"

#: in/chapter14.html:84
msgid ""
"<p>The association of methods to classes gets even more tenuous when\n"
"we consider that one or more of a method's arguments may specialize\n"
"on an object that is not a class. If we expect to find some convenient\n"
"way to say that a method \"belongs to\" a particular class, we're simply\n"
"not going to find it."
msgstr ""
"<p>\n"
"Связь методов с классами становится еще более слабой, если учесть, что "
"один \n"
"или несколько аргументов метода могут специализироваться на объекте, "
"который \n"
"не является классом. Если мы рассчитываем найти какой-то удобный способ "
"сказать, \n"
"что метод \"принадлежит\" определенному классу, мы просто не найдем его."

#: in/chapter14.html:89
msgid ""
"<p>Simpler (and less capable) object systems than CLOS <em>do</em> \n"
"associate a method with a particular class.  CLOS does not.  This is\n"
"an important point, so let me rephrase it: CLOS methods are <em>not</em> \n"
"a part of any class for which they may provide services."
msgstr ""
"<p>\n"
"Более простые (и менее выразительные) объектные системы, чем CLOS, "
"действительно \n"
"связывают метод с определенным классом. CLOS - нет. Это важный момент, "
"поэтому \n"
"позвольте мне перефразировать его: методы CLOS не являются частью какого - "
"либо класса, \n"
"для которого они могут предоставлять услуги."

#: in/chapter14.html:96
msgid ""
"<p>A method is a part of a generic function. The generic function analyzes\n"
"the actual parameters and selects a method to invoke based upon a match\n"
"between actual parameters and specialized lambda lists in the method\n"
"definitions.  And, to reiterate the point made in the previous paragraph,\n"
"generic functions are <em>not a part of</em> of any classes upon which the\n"
"generic function's methods operate."
msgstr ""
"<p>\n"
"Метод - это часть обобщенной функции. Обобщенная функция анализирует \n"
"фактические параметры и выбирает метод для вызова на основе соответствия \n"
"между фактическими параметрами и специализированными(указанными) лямбда-"
"списками \n"
"в определениях методов. И, повторяя замечание, сделанное в предыдущем "
"параграфе, \n"
"обобщенные функции <em>не являются частью</em> каких-либо классов, над "
"которыми \n"
"работают методы обобщенной функции."

#: in/chapter14.html:98
msgid "<h2>Generic functions work by dispatching on argument specializers</h2>"
msgstr ""
"<h2>Обобщенные функции работают путем диспетчеризации по указанным "
"аргументам</h2>"

#: in/chapter14.html:106
msgid ""
"<p>When you define a method, the types of its parameters (in the\n"
"specialized lambda list) declare that the method may be invoked only\n"
"by parameters of the same, or more specific, types. For example, if\n"
"a parameter is specialized on the type <code>NUMBER</code>, it can\n"
"match <code>INTEGER</code>, <code>FIXNUM</code>, <code>FLOAT</code>,\n"
"<code>BIGNUM</code>, <code>RATIONAL</code>, <code>COMPLEX</code>, or\n"
"any other proper subtype of <code>NUMBER</code>."
msgstr ""
"<p>\n"
"При определении метода обявляют типы его параметров (в специализирующем \n"
"лямбда-списке), так что метод может быть вызван только при использовании "
"параметров\n"
"того же или более специфического типа. Например, если параметр "
"специализируется\n"
"типом <code>NUMBER</code>, он может соответствовать\n"
"<code>INTEGER</code>, <code>FIXNUM</code>, <code>FLOAT</code>,\n"
"<code>BIGNUM</code>, <code>RATIONAL</code>, <code>COMPLEX</code>, \n"
"или каким либо другим подтипом <code>NUMBER</code>."

#: in/chapter14.html:109
msgid ""
"<p>But what if you define two methods that could match the same types?\n"
"Consider the following definitions."
msgstr ""
"<p>\n"
"Но что делать, если вы определяете два метода, которые могут "
"соответствовать \n"
"одним и тем же типам? Рассмотрим следующие определения."

#: in/chapter14.html:117
msgid ""
"<pre>\n"
"(defmethod op2 ((x number)  (y number))  ...) <i>; method 1</i> \n"
"(defmethod op2 ((x float)   (y float))   ...) <i>; method 2</i> \n"
"(defmethod op2 ((x integer) (y integer)) ...) <i>; method 3</i> \n"
"(defmethod op2 ((x float)   (y number))  ...) <i>; method 4</i> \n"
"(defmethod op2 ((x number)  (y float))   ...) <i>; method 5</i> \n"
"</pre> "
msgstr ""

#: in/chapter14.html:123
msgid ""
"<p>A call of the form <code>(OP2 11 23)</code> potentially matches\n"
"methods 1 and 3, because the arguments are both of type <i>INTEGER</i>,\n"
"which is a subtype of <code>NUMBER</code>.  CLOS resolves ambiguity\n"
"by choosing the more specific match, thus method 3 is selected for\n"
"a call of <code>(OP2 11 23)</code>."
msgstr ""
"<p>\n"
"Вызов формы <code>(OP2 11 23)</code> потенциально соответствует \n"
"методам 1 и 3, поскольку оба аргумента имеют тип <i>INTEGER</i>, \n"
"который является подтипом <code>NUMBER</code>. CLOS разрешает \n"
"неоднозначность, выбирая более конкретное совпадение, таким образом, \n"
"метод 3 выбирается для вызова <code>(OP2 11 23)</code>."

#: in/chapter14.html:131
msgid ""
"<p>The same resolution strategy chooses method 5 for <code>(OP2 13\n"
"2.9)</code>, method 4 for <code>(OP2 8.3 4/5)</code>, and method 1\n"
"for <code>(OP2 5/8 11/3)</code>.  The general rule is that CLOS selects\n"
"a method based upon the most specific matching types, and an argument\n"
"is always more specific than the arguments to its right.  The second\n"
"part of this rule means that arguments on the left serve as tiebreakers\n"
"for those futher to the right.  Consider these methods:"
msgstr ""
"<p>\n"
"Та же стратегия разрешения выбирает метод 5 для <code>(OP2 13 2.9)</code>, \n"
"метод 4 для <code>(OP2 8.3 4/5)</code> и метод 1 для <code>(OP2 5/8 11/3)</"
"code>. \n"
"Общее правило состоит в том, что CLOS выбирает метод, основанный на "
"наиболее \n"
"специфичных типах соответствия, и левый аргумент всегда более специфичен, \n"
"чем аргументы справа от него. Вторая часть этого правила означает, что "
"аргументы \n"
"слева служат тай-брейкерами(уточнениями) для тех, кто находится дальше "
"справа. Рассмотрим эти методы:"

#: in/chapter14.html:137
msgid ""
"<pre>\n"
"(defmethod Xop2 ((x number)  (y number))  ...) <i>; method 1</i> \n"
"(defmethod Xop2 ((x float)   (y number))  ...) <i>; method 2</i> \n"
"(defmethod Xop2 ((x number)  (y float))   ...) <i>; method 3</i> \n"
"</pre> "
msgstr ""

#: in/chapter14.html:142
msgid ""
"<p>A call of <code>(XOP2 5.3 4.1)</code> will invoke method 2. Both\n"
"method 2 and method 3 are more specific than method 1. Method 2 has\n"
"a more specialized type in the first argument position when compared\n"
"to method 3, so method 2 is the one that is invoked. "
msgstr ""
"<p>\n"
"Вызов <code>(XOP2 5.3 4.1)</code> вызовет метод 2. И Метод 2, и метод 3 \n"
"более специфичны, чем метод 1. Метод 2 имеет более специализированный тип \n"
"в первой позиции аргумента по сравнению с методом 3, поэтому вызывается \n"
"метод 2."

#: in/chapter14.html:145
msgid ""
"<p>In addition to dispatching based upon argment types, CLOS can\n"
"dispatch based upon specific objects."
msgstr ""
"<p>\n"
"Помимо диспетчеризации на основе типов аргументов, CLOS может выполнять \n"
"диспетчеризацию на основе конкретных объектов."

#: in/chapter14.html:160
msgid ""
"<pre>\n"
"? (defmethod idiv ((numerator integer) (denominator integer))\n"
"    (values (floor numerator denominator)))\n"
"#&lt;STANDARD-METHOD IDIV (INTEGER INTEGER)&gt;\n"
"? (defmethod idiv ((numerator integer) (denominator (eql 0)))\n"
"    nil)\n"
"#&lt;STANDARD-METHOD IDIV (INTEGER (EQL 0))&gt;\n"
"? (idiv 4 3)\n"
"1\n"
"? (idiv 6 2)\n"
"3\n"
"? (idiv 4 0)\n"
"NIL\n"
"</pre> "
msgstr ""

#: in/chapter14.html:166
msgid ""
"<p>Here we've specialized on the integer 0. You can specialize on any\n"
"object that can be distinguished using the <code>EQL</code> predicate.\n"
"Numbers, symbols and object instances can all be tested in this way.\n"
"See <a href=\"chapter17.html\">Chapter 17</a> for more information on the\n"
"<code>EQL</code> predicate."
msgstr ""
"<p>\n"
"Здесь мы специализировались на целочисленном значении 0. Вы можете \n"
"специализироваться на любом объекте, который можно выделить с помощью \n"
"предиката <code>EQL</code>. Числа, символы и экземпляры объектов могут \n"
"быть проверены таким образом. См. <a href=\"chapter17.html\">Главу 17</a> \n"
"для получения дополнительной информации по предикату <code>EQL</code>."

#: in/chapter14.html:168
msgid ""
"<h2>Object inheritance matters after all; finding the applicable method</h2>"
msgstr ""
"<h2>В конце концов наследование объектов имеет значение; поиск подходящих "
"методов</h2>"

#: in/chapter14.html:171
msgid ""
"<p>A class is a type, and a subclass is a subtype. So when you define\n"
"these classes:"
msgstr ""
"<p>\n"
"Класс - это тип, а подкласс-это подтип. Поэтому, когда вы определяете \n"
"эти классы:"

#: in/chapter14.html:176
msgid ""
"<pre>\n"
"(defclass c1 () ...)\n"
"(defclass c2 (c1) ...)\n"
"</pre> "
msgstr ""

#: in/chapter14.html:181
msgid ""
"<p>then <code>C2</code> is a subclass of <code>C1</code>. If you then use\n"
"the types <code>C1</code> and <code>C2</code> as specializers in a method\n"
"definition, <code>C2</code> will be a more specific type (see the previous\n"
"section) than <code>C1</code>."
msgstr ""
"<p>\n"
"тогда <code>C2</code> - это подкласс <code>C1</code>. Если затем вы "
"используете \n"
"типы <code>C1</code> и <code>C2</code> в качестве специализации для "
"определения \n"
"метода, то <code>C2</code> будет более специфичным типом \n"
"(см. предыдущий раздел), чем <code>C1</code>."

#: in/chapter14.html:185
msgid ""
"<p>But what if you define classes that inherit from more than one class?\n"
"How do you decide which class is more specific than another?  Consider\n"
"the following class definitions:"
msgstr ""
"<p>\n"
"Но что делать, если вы определяете классы, которые наследуются от \n"
"более чем одного класса? Как вы решаете, какой класс более специфичен, \n"
"чем другой? Рассмотрим следующие определения классов:"

#: in/chapter14.html:195
msgid ""
"<pre>\n"
"(defclass c1 () ...)\n"
"(defclass c2 () ...)\n"
"(defclass c3 (c1) ...)\n"
"(defclass c4 (c2) ...)\n"
"(defclass c5 (c3 c2) ...)\n"
"(defclass c6 (c5 c1) ...)\n"
"(defclass c7 (c4 c3) ...)\n"
"</pre> "
msgstr ""

#: in/chapter14.html:199
msgid ""
"<p>These definitions give us an inheritance hierarchy that looks\n"
"like this; bold lines link a subclass to the first parent class,\n"
"while lighter lines link to the second parent class:"
msgstr ""
"<p>\n"
"Эти определения дают нам иерархию наследования, которая выглядит следующим "
"образом: \n"
"жирные линии связывают подкласс с первым родительским классом, \n"
"а более светлые линии - со вторым родительским классом:"

#: in/chapter14.html:201
msgid "<p><img src=\"gifs/multiple-inheritance-graph.gif\">"
msgstr ""

#: in/chapter14.html:204
msgid ""
"<p>Now consider the following method definitions, which specialize\n"
"on this class hierarchy:"
msgstr ""
"<p>\n"
"Теперь рассмотрим следующие определения методов, которые специализируются \n"
"на этой иерархии классов:"

#: in/chapter14.html:209
msgid ""
"<pre>\n"
"(defmethod m1 ((x c1)) ...) <i>; method 1</i> \n"
"(defmethod m1 ((x c2)) ...) <i>; method 2</i> \n"
"</pre> "
msgstr ""

#: in/chapter14.html:218
msgid ""
"<p>It's clear that calling <code>M1</code>'s generic function with \n"
"an object of type <code>C1</code> or <code>C3</code> will invoke\n"
"method 1, and that calling the generic function with an object of\n"
"type <code>C2</code> or <code>C4</code> will invoke method 2.  But \n"
"what happens if we call <code>M1</code>'s generic function with an \n"
"object of type <code>C5</code>, <code>C6</code>, or <code>C7</code>?\n"
"These classes all inherit -- directly or indirectly -- from <em>both</em> \n"
"<code>C1</code> and <code>C2</code>."
msgstr ""
"<p>Ясно, что вызов обобщенной функции <code>M1</code> с объектом типа \n"
"<code>C1</code> или <code>C3</code> вызовет метод 1,\n"
"а вызов обобщенной функции с объектом типа <code>C2</code> или <code>C4</"
"code> \n"
"вызовет метод 2. Но что произойдет, если мы вызовем обобщенную функцию M1 \n"
"с объектом типа  <code>C5</code>, <code>C6</code>, или <code>C7</code>? \n"
"Все эти классы наследуются-прямо или косвенно-как от \n"
"<code>C1</code>, так и от <code>C2</code>.\n"

#: in/chapter14.html:228
msgid ""
"<p>If we invoke the generic function <code>M1</code> with an object\n"
"of type <code>C5</code>, <code>C6</code>, or <code>C7</code>, CLOS\n"
"must decide whether to invoke method 1 or method 2. (It can't do\n"
"both.) This decision is based upon some measure of whether\n"
"<code>C1</code> or <code>C2</code> is a more specific parent class.\n"
"The measure is based upon the position of the parent class in the\n"
"<em>class precedence list</em> of the subclass. Here are the class\n"
"precedence lists (CPLs) for <code>C5</code>, <code>C6</code>, and\n"
"<code>C7</code>:"
msgstr ""
"<p>\n"
"Если мы вызываем обобщенную функцию <code>M1</code> с объектом типа \n"
"<code>C5</code>, <code>C6</code>, или <code>C7</code> CLOS должен решить, \n"
"следует ли вызывать метод 1 или Метод 2. (Он не может делать и то, и "
"другое.) \n"
"Это решение основано на некоторой мере того, является ли \n"
"<code>C1</code> или <code>C2</code> более конкретным родительским классом. \n"
"Мера основана на положении родительского класса в списке предшествования/"
"приоритетов\n"
"классов(<em>class precedence list</em>) подкласса. Вот списки "
"предшествования классов\n"
"(CPLs) для <code>C5</code>, <code>C6</code>, и\n"
"<code>C7</code>:"

#: in/chapter14.html:236
msgid ""
"<pre>\n"
"Class   CPL\n"
"-----   ---\n"
"C5      (C5 C3 C1 C2)\n"
"C6      (C6 C5 C3 C1 C2)\n"
"C7      (C7 C4 C2 C3 C1)\n"
"</pre> "
msgstr ""

#: in/chapter14.html:244
msgid ""
"<p>Classes near the beginning of the CPL are more specific, so\n"
"<code>C5</code> and <code>C6</code> are more specific to\n"
"<code>C1</code> and <code>C7</code> is more specific to\n"
"<code>C2</code>. Therefore, calling the <code>M1</code> generic\n"
"function with an object of type <code>C5</code> or <code>C6</code>\n"
"will invoke method 1. Calling <code>M1</code> with an object of type\n"
"<code>C7</code> will invoke method 2."
msgstr ""
"<p>\n"
"Классы в начале CPL(списке предшествования классов) являются более "
"конкретными, \n"
"так что <code>C5</code> и <code>C6</code> являются более конкретными для\n"
"<code>C1</code> и <code>C7</code> являются более конкретными для <code>C2</"
"code>. \n"
"Поэтому вызов их обобщенной функции  <code>M1</code> с объектом типа \n"
"<code>C5</code> или <code>C6</code> вызовет метод 1. \n"
"Вызов <code>M1</code> с объектом типа <code>C7</code> вызовет метод 2."

#: in/chapter14.html:253
msgid ""
"<p>The next question you should ask is \"how <em>does</em> CLOS\n"
"determine the CPL?\" There is, of course, an algorithm for computing\n"
"the CPL -- you can find this described in a Lisp reference manual.\n"
"Or you can define some classes and ask Lisp to tell you the CPL;\n"
"most implementations include a function named\n"
"<code>CLASS-PRECEDENCE-LIST</code> that expects a class\n"
"<em>object</em> as its only argument (use <code>FIND-CLASS</code> to\n"
"get the class object from its name) and returns a CPL. "
msgstr ""
"<p>\n"
"Следующий вопрос, который вы должны задать: \"как CLOS определяет CPL?"
"\"Конечно, \n"
"существует алгоритм вычисления CPL - вы можете найти его описание в "
"справочном \n"
"руководстве Lisp. Или вы можете определить некоторые классы и спросить Лисп, "
"чтобы \n"
"он сказал вам их CPL; большинство реализаций включают в себя функцию с "
"именем\n"
"<code>CLASS-PRECEDENCE-LIST</code>, которая ожидает объект класса в качестве "
"своего\n"
"единственного аргумента (используйте <code>FIND-CLASS</code>, чтобы "
"получить \n"
"объект класса по его названию) и возвращает CPL."

#: in/chapter14.html:258
msgid ""
"<pre>\n"
"? (class-precedence-list (find-class 'c6))\n"
"(C6 C5 C3 C1 C2)\n"
"</pre> "
msgstr ""

#: in/chapter14.html:262
msgid ""
"<p>Design conservatively with multiple inheritance, and you\n"
"shouldn't have to depend upon knowledge of the algorithm by which\n"
"CLOS computes the CPL."
msgstr ""
"<p>Проектируйте консервативно с множественным наследованием, и вам не "
"придется \n"
"зависеть от знания алгоритма, с помощью которого CLOS вычисляет CPL."

#: in/chapter14.html:264
msgid "<h2>Method combinations offer further choices</h2>"
msgstr ""
"<h2>Комбинации методов предлагают дополнительные варианты выбора\n"
"</h2>"

#: in/chapter14.html:271
msgid ""
"<p>If you define methods as we've seen throughout this chapter, the\n"
"generic function that gets created will offer a capability called\n"
"<em>standard</em> method combination.  The methods that we've so far\n"
"used have all been <em>primary</em> methods.  Under standard method\n"
"combination, we can also define <em>before</em>, <em>after</em>, and\n"
"<em>around</em> methods which get combined with the primary method."
msgstr ""
"<p>\n"
"Если вы определяете методы, как мы видели в этой главе, то создаваемая \n"
"обобщенная функция будет предлагать возможность, называемую стандартной \n"
"комбинацией методов. Все методы, которые мы до сих пор использовали, были \n"
"первичными методами. В рамках стандартной комбинации методов мы также "
"можем \n"
"определить методы \"до\"(<em>before</em>), \"после\"(<em>after</em>) и \n"
"\"вокруг\"(<em>around</em>), которые объединяются с \n"
"первичным/основным методом."

#: in/chapter14.html:275
msgid ""
"<p>To define a <em>before</em>, <em>after</em>, or <em>around</em>\n"
"method we add a corresponding keyword (a <em>method qualifier</em>)\n"
"to our <code>DEFMETHOD</code> form, like this:"
msgstr ""
"<p>Чтобы определить метод <em>before</em>, <em>after</em>, или <em>around</"
"em>, \n"
"мы добавляем соответствующее ключевое слово (квалификатор метода) в нашу "
"форму \n"
"<code>DEFMETHOD</code>, например:"

#: in/chapter14.html:281
msgid ""
"<pre>\n"
"(defmethod madness :before (...) ...)\n"
"(defmethod madness :after  (...) ...)\n"
"(defmethod madness :around (...) ...)\n"
"</pre> "
msgstr ""

#: in/chapter14.html:284
msgid ""
"<p>Let's take a look at standard method combination in action.  We'll begin\n"
"with the <code>:BEFORE</code> and <code>:AFTER</code> methods."
msgstr ""
"<p>Давайте рассмотрим комбинацию стандартных методов в действии. Мы начнем \n"
"с методов <code>:BEFORE</code> и <code>:AFTER</code>."

#: in/chapter14.html:301
msgid ""
"<pre>\n"
"<i>; Define a primary method</i> \n"
"? (defmethod combo1 ((x number)) (print 'primary) 1)\n"
"#&lt;STANDARD-METHOD COMBO1 (NUMBER)&gt;\n"
"<i>; Define before methods</i> \n"
"? (defmethod combo1 :before ((x integer)) (print 'before-integer) 2)\n"
"#&lt;STANDARD-METHOD COMBO1 :BEFORE (INTEGER)&gt;\n"
"? (defmethod combo1 :before ((x rational)) (print 'before-rational) 3)\n"
"#&lt;STANDARD-METHOD COMBO1 :BEFORE (RATIONAL)&gt;\n"
"<i>; Define after methods</i> \n"
"? (defmethod combo1 :after ((x integer)) (print 'after-integer) 4)\n"
"#&lt;STANDARD-METHOD COMBO1 :AFTER (INTEGER)&gt;\n"
"? (defmethod combo1 :after ((x rational)) (print 'after-rational) 5)\n"
"#&lt;STANDARD-METHOD COMBO1 :AFTER (RATIONAL)&gt;\n"
"<i>; Try it</i> \n"
"? (combo1 17)"
msgstr ""

#: in/chapter14.html:309
msgid ""
"BEFORE-INTEGER\n"
"BEFORE-RATIONAL\n"
"PRIMARY\n"
"AFTER-RATIONAL\n"
"AFTER-INTEGER\n"
"1\n"
"? (combo 4/5)"
msgstr ""

#: in/chapter14.html:315
msgid ""
"BEFORE-RATIONAL\n"
"PRIMARY\n"
"AFTER-RATIONAL\n"
"1\n"
"</pre> "
msgstr ""

#: in/chapter14.html:325
msgid ""
"<p>When we call <code>COMBO1</code>, CLOS determines which methods\n"
"are applicable. As we learned earlier, only one primary method is\n"
"applicable. But, as we saw in the call to <code>(COMBO1 17)</code>,\n"
"we can have multiple applicable <code>:BEFORE</code> and\n"
"<code>:AFTER</code> methods. Because integer is a subtype of\n"
"rational, an integer argument to <code>COMBO1</code>, the\n"
"<code>:BEFORE</code> and <code>:AFTER</code> methods that specialize\n"
"on <code>INTEGER</code> and <code>RATIONAL</code> arguments are\n"
"applicable."
msgstr ""
"<p>Когда мы вызываем <code>COMBO1</code>, CLOS определяет, какие методы \n"
"применимы. Как мы узнали ранее, применим только один основной метод. \n"
"Но, как мы видели в вызове to <code>(COMBO1 17)</code>, у нас может \n"
"быть несколько применимых методов <code>:BEFORE</code> и <code>:AFTER</"
"code>. \n"
"Поскольку integer - это подтип rational, и аргумент для \n"
"<code>COMBO1</code> целочисленный, применимы методы <code>:BEFORE</code> \n"
"и <code>:AFTER</code>, специализирующиеся на целочисленных и рациональных "
"аргументах."

#: in/chapter14.html:335
msgid ""
"<p>So CLOS has now determined a set of applicable methods: a primary\n"
"method and some before and after methods. The standard method\n"
"combination determines the order in which these methods get invoked.\n"
"First, <em>all</em> of the applicable <code>:BEFORE</code> methods\n"
"are invoked, with the more specific methods invoked <em>first</em>.\n"
"Then the applicable primary method is invoked. Next, all of the\n"
"applicable <code>:AFTER</code> methods are invoked, with the more\n"
"specific methods invoked <em>last</em>. Finally, the value of the \n"
"primary method is returned as the value of the generic function."
msgstr ""
"<p>\n"
"Так CLOSE определил набор применимых методов: первичный метод и \n"
"некоторые методы до и после него. Стандартная комбинация методов \n"
"определяет порядок, в котором эти методы вызываются. Во-первых, \n"
" будут вызваны все применимые методы <code>:BEFORE</code>, более\n"
"конкретные методы, вызываются первыми. Затем вызывается соответствующий \n"
"первичный метод. Далее вызвываются все применимые методы <code>:AFTER</"
"code>, \n"
"причем более конкретные методы вызываются последними. Наконец, значение \n"
"первичного метода возвращается как значение универсальной функции.\n"

#: in/chapter14.html:342
msgid ""
"<p><code>:BEFORE</code> and <code>:AFTER</code> methods are often\n"
"used to add extra behaviors to a method. They typically introduce\n"
"some kind of side effect -- by doing I/O, by changing global state,\n"
"or by altering slots of one or more of the objects passed as\n"
"parameters. There are three actions not available to\n"
"<code>:BEFORE</code> and <code>:AFTER</code> methods:"
msgstr ""
"<p>\n"
"<code>:BEFORE</code> и <code>:AFTER</code>  методы часто используются \n"
"для добавления дополнительных поведений к методу. Они обычно вводят \n"
"какой-то побочный эффект - выполняя ввод-вывод, изменяя глобальное \n"
"состояние или изменяя слоты одного или нескольких объектов, передаваемых \n"
"в качестве параметров. Существует три действия, недоступные для методов \n"
"<code>:BEFORE</code> и <code>:AFTER</code>"

#: in/chapter14.html:348
msgid ""
"<ol>\n"
"<li>They can't alter the parameters seen by other applicable methods.\n"
"<li>They can't alter which of the applicable methods are actually invoked.\n"
"<li>They can't alter the value returned from the generic function.\n"
"</ol> "
msgstr ""
"<ol>\n"
"<li>Они не могут изменить параметры, видимые другими применимыми методами.\n"
"<li>Они не могут изменить, какой из применимых методов фактически "
"вызывается.\n"
"<li>Они не могут изменить значение, возвращаемое из обобщенной функции.\n"
"</ol> "

#: in/chapter14.html:353
msgid ""
"<p>But the standard method combination offers a third kind of\n"
"qualified method, the <code>:AROUND</code> method, that can perform\n"
"all of these actions. An <code>:AROUND</code> method is defined using\n"
"a method qualifier, just as you might expect:"
msgstr ""
"<p>Но стандартная комбинация методов предлагает третий вид \n"
"квалифицированного метода, метод <code>:AROUND</code>, который может \n"
"выполнять все эти действия. <code>:AROUND</code> метод определяется \n"
"с помощью квалификатора метода, как и следовало ожидать:"

#: in/chapter14.html:357
msgid ""
"<pre>\n"
"(defmethod madness :around (...) ...)\n"
"</pre> "
msgstr ""

#: in/chapter14.html:367
msgid ""
"<p>When a generic function has one or more <code>:AROUND</code>\n"
"methods defined, the most specific applicable <code>:AROUND</code>\n"
"method is invoked first, even if there are applicable\n"
"<code>:BEFORE</code> methods. At this point, the\n"
"<code>:AROUND</code> method has complete control -- if it simply\n"
"returns, then <em>none</em> of the other applicable methods will be\n"
"invoked. Normally an <code>:AROUND</code> method calls\n"
"<code>CALL-NEXT-METHOD</code> which allows control to proceed\n"
"through other applicable methods."
msgstr ""
"<p>\n"
"Если обобщенная функция имеет один или несколько определенных методов \n"
"<code>:AROUND</code>, то сначала вызывается наиболее специлизированный/"
"конкретный\n"
"метод <code>:AROUND</code>, даже если есть применимые методы <code>:BEFORE</"
"code>. \n"
"На этом этапе метод <code>:AROUND</code> имеет полный контроль - если он "
"просто \n"
"возвращается, то ни один из других применимых методов не будет вызван. "
"Обычно \n"
"метод <code>:AROUND</code> вызывает метод <code>CALL-NEXT-METHOD</code>, "
"который \n"
"позволяет осуществлять управление с помощью других применимых методов."

#: in/chapter14.html:377
msgid ""
"<p><code>CALL-NEXT-METHOD</code> calls the next most specific\n"
"<code>:AROUND</code> method; if there are no less specific\n"
"applicable <code>:AROUND</code> methods, then\n"
"<code>CALL-NEXT-METHOD</code> invokes all of the applicable before,\n"
"primary, and after methods exactly as detailed above. The value\n"
"returned by the most specific <code>:AROUND</code> method is\n"
"returned by the generic function; typically you'll use the value --\n"
"or some modification thereof -- returned by\n"
"<code>CALL-NEXT-METHOD</code>."
msgstr ""
"<p>\n"
"<code>CALL-NEXT-METHOD</code>  вызывает следующий наиболее \n"
"специфичный метод <code>:AROUND</code>; если нет менее специфичных \n"
"применимых методов <code>:AROUND</code>, то <code>CALL-NEXT-METHOD</code> \n"
"вызывает все применимые методы before, primary и after точно так же, \n"
"как описано выше. Значение, возвращаемое наиболее специфичным методом\n"
"<code>:AROUND</code>, возвращается обобщенной функцией; обычно вы будете \n"
"использовать значение - или его некоторую модификацию - возвращаемое "
"методом \n"
"<code>CALL-NEXT-METHOD</code>."

#: in/chapter14.html:382
msgid ""
"<p>If you call <code>CALL-NEXT-METHOD</code> without arguments, it\n"
"uses the arguments of the current method. But you can call\n"
"<code>CALL-NEXT-METHOD</code> with arguments, and change the\n"
"parameters seen by the called method(s)."
msgstr ""
"<p>Если вы вызываете <code>CALL-NEXT-METHOD</code> без аргументов, \n"
"он использует аргументы текущего метода. Но вы можете вызвать метод \n"
"<code>CALL-NEXT-METHOD</code> с аргументами и изменить параметры, \n"
"видимые вызываемым методом(ами)."

#: in/chapter14.html:413
msgid ""
"<pre>\n"
"<i>; Define a primary method</i> \n"
"? (defmethod combo2 ((x number)) (print 'primary) 1)\n"
"#&lt;STANDARD-METHOD COMBO2 (NUMBER)&gt;\n"
"<i>; Define before methods</i> \n"
"? (defmethod combo2 :before ((x integer)) (print 'before-integer) 2)\n"
"#&lt;STANDARD-METHOD COMBO2 :BEFORE (INTEGER)&gt;\n"
"? (defmethod combo2 :before ((x rational)) (print 'before-rational) 3)\n"
"#&lt;STANDARD-METHOD COMBO2 :BEFORE (RATIONAL)&gt;\n"
"<i>; Define after methods</i> \n"
"? (defmethod combo2 :after ((x integer)) (print 'after-integer) 4)\n"
"#&lt;STANDARD-METHOD COMBO2 :AFTER (INTEGER)&gt;\n"
"? (defmethod combo2 :after ((x rational)) (print 'after-rational) 5)\n"
"#&lt;STANDARD-METHOD COMBO2 :AFTER (RATIONAL)&gt;\n"
"<i>; Define around methods</i> \n"
"? (defmethod combo2 :around ((x float))\n"
"    (print 'around-float-before-call-next-method)\n"
"    (let ((result (call-next-method (float (truncate x)))))\n"
"      (print 'around-float-after-call-next-method)\n"
"      result))\n"
"#&lt;STANDARD-METHOD COMBO2 :AROUND (FLOAT)&gt;\n"
"? (defmethod combo2 :around ((x complex)) (print 'sorry) nil)\n"
"#&lt;STANDARD-METHOD COMBO2 :AROUND (COMPLEX)&gt;\n"
"? (defmethod combo2 :around ((x number))\n"
"    (print 'around-number-before-call-next-method)\n"
"    (print (call-next-method))\n"
"    (print 'around-number-after-call-next-method)\n"
"    99)\n"
"<i>; Try it</i> \n"
"? (combo2 17)"
msgstr ""

#: in/chapter14.html:424
msgid ""
"AROUND-NUMBER-BEFORE-CALL-NEXT-METHOD \n"
"BEFORE-INTEGER \n"
"BEFORE-RATIONAL \n"
"PRIMARY \n"
"AFTER-RATIONAL \n"
"AFTER-INTEGER \n"
"1 \n"
"AROUND-NUMBER-AFTER-CALL-NEXT-METHOD \n"
"99\n"
"? (combo2 4/5)"
msgstr ""

#: in/chapter14.html:433
msgid ""
"AROUND-NUMBER-BEFORE-CALL-NEXT-METHOD \n"
"BEFORE-RATIONAL \n"
"PRIMARY \n"
"AFTER-RATIONAL \n"
"1 \n"
"AROUND-NUMBER-AFTER-CALL-NEXT-METHOD \n"
"99\n"
"? (combo2 82.3)"
msgstr ""

#: in/chapter14.html:442
msgid ""
"AROUND-FLOAT-BEFORE-CALL-NEXT-METHOD \n"
"AROUND-NUMBER-BEFORE-CALL-NEXT-METHOD \n"
"PRIMARY \n"
"1 \n"
"AROUND-NUMBER-AFTER-CALL-NEXT-METHOD \n"
"AROUND-FLOAT-AFTER-CALL-NEXT-METHOD \n"
"99\n"
"? (combo2 #c(1.0 -1.0))"
msgstr ""

#: in/chapter14.html:446
msgid ""
"SORRY \n"
"NIL\n"
"</pre> "
msgstr ""

#: in/chapter14.html:452
msgid ""
"<p>One thing you <em>can't</em> do is to provide arguments to \n"
"<code>CALL-NEXT-METHOD</code> that would change the applicable methods.\n"
"In other words, you need to preserve the type of methods even as you\n"
"change their values.  For example, the following redefinition of\n"
"one of the <code>COMBO2</code> example methods won't work:"
msgstr ""
"<p>\n"
"Одна вещь, которую вы не можете сделать, - это предоставить аргументы \n"
"для вызова метода <code>CALL-NEXT-METHOD</code, которые изменили бы \n"
"применимые методы. Другими словами, вы должны сохранять тип методов \n"
"даже при изменении их значений. Например, следующее переопределение \n"
"одного из методов примера <code>COMBO2</code> не будет работать:"

#: in/chapter14.html:460
msgid ""
"<pre>\n"
"? (defmethod combo2 :around ((x float))\n"
"    (call-next-method (floor x))) <i>; FLOOR returns an integer</i> \n"
"#&lt;STANDARD-METHOD COMBO2 :AROUND (FLOAT)&gt;\n"
"? (combo2 45.9)\n"
"Error: applicable methods changed\n"
"</pre> "
msgstr ""

#: in/chapter14.html:462
msgid "<h2>Nothing is cast in stone; a peek at the metaobject protocol</h2>"
msgstr "<h2>Ничто не выбито на камне; Взгляд на метаобъектный протокол</h2>"

#: in/chapter14.html:469
msgid ""
"<p>The metaobject protocol (MOP) is a collection of functions that\n"
"expose much of the underlying workings of CLOS. We've already seen\n"
"one function that belongs to the MOP:\n"
"<code>CLASS-PRECEDENCE-LIST</code>.  Some MOP functions, like \n"
"<code>CLASS-PRECEDENCE-LIST</code>, give you visibility into the inner\n"
"workings of CLOS.  Here are some examples:"
msgstr ""
"<p>\n"
"Протокол метаобъектов(metaobject protocol = MOP) - это набор функций, "
"которые\n"
"раскрывают большую часть лежащую в основе работы CLOS. Мы уже видели одну \n"
"функцию, которая принадлежит к MOP <code>CLASS-PRECEDENCE-LIST</code>. "
"Некоторые \n"
"функции MOP, такие как <code>CLASS-PRECEDENCE-LIST</code>, дают вам "
"возможность\n"
"заглянуть внутрь работы CLOS. Вот несколько примеров:"

#: in/chapter14.html:478
msgid ""
"<pre>\n"
"Function                    Argument   Returns\n"
"--------                    --------   -------\n"
"CLASS-DIRECT-SUBCLASSES     a class    a list of the immediate subclasses\n"
"CLASS-DIRECT-SUPERCLASSES   a class    a list of the immediate superclasses\n"
"CLASS-DIRECT-SLOTS          a class    a list of non-inherited slots\n"
"CLASS-DIRECT-METHODS        a class    a list of non-inherited methods\n"
"</pre> "
msgstr ""

#: in/chapter14.html:487
msgid ""
"<p>Other MOP functions let you change the underlying behavior of\n"
"CLOS. You can use this capability to extend CLOS -- perhaps to\n"
"implement a persistent object store -- or to alter the behavior to\n"
"more closely correspond to a different kind of object system. Such\n"
"changes are far beyond the scope of this book. Also, you should be\n"
"aware that the MOP is <em>not</em> (yet, as of early 1999) a\n"
"standard part of CLOS, and there is no definition of the MOP\n"
"recognized by any national or international standards body."
msgstr ""
"<p>\n"
"Другие функции MOP позволят вам изменить поведение CLOS. Вы можете \n"
"использовать эту возможность для расширения CLOS - возможно, для \n"
"реализации постоянного хранилища объектов - или для изменения поведения, \n"
"чтобы оно более точно соответствовало другому типу объектной системы. \n"
"Подобные изменения выходят далеко за рамки данной книги. Кроме того, \n"
"вы должны знать, что MOP не является (пока, по состоянию на начало 1999 "
"года) \n"
"стандартной частью CLOS, и нет никакого определения MOP, признанного \n"
"каким-либо национальным или международным органом по стандартизации."

#: in/chapter14.html:493
msgid ""
"<p>So far, the defining document for the MOP is <a\n"
"href=\"chapter33.html#kiczales91\">The Art of the Metaobject\n"
"Protocol</a>. Most Lisp vendors provide at least a partial MOP\n"
"implementation; you should probably start with the vendor's\n"
"documentation if you're interested in the MOP."
msgstr ""
"<p>\n"
"До сих пор определяющим документом для MOP является \n"
"<a href=\"chapter33.html#kiczales91\">The Art of the Metaobject\n"
"Protocol</a>. Большинство поставщиков Lisp предоставляют по крайней мере \n"
"частичную реализацию MOP; вероятно, вам следует начать с документации "
"поставщика, \n"
"если вы заинтересованы в MOP."

#: in/chapter14.html:506
msgid ""
"<hr>\n"
"<div align=\"center\">\n"
"<a href=\"contents.html\">Contents</a> | <a href=\"cover.html\">Cover</a> "
"<br> \n"
"<a href=\"chapter13.html\">Chapter 13</a> | Chapter 14 | <a href=\"chapter15."
"html\">Chapter 15</a> \n"
"</div>\n"
"<hr>\n"
"<address>\n"
"Copyright &copy; 1995-2001, David B. Lamkins<br>\n"
"All Rights Reserved Worldwide<br>\n"
"<br>\n"
"This book may not be reproduced without the written consent of its author.  "
"Online distribution is restricted to the author's site.\n"
"</address> \n"
"</body> </html> "
msgstr ""
