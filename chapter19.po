#
# NuINu <don't@send.my>, 2020.
#
#. extracted from in/chapter19.html
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-04-19 13:51+0300\n"
"PO-Revision-Date: 2020-06-01 11:40+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter19.html:5
msgid ""
"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/"
"html4/strict.dtd\">\n"
"<html><head>\n"
"<title>Successful Lisp - Chapter 19</title>\n"
"</head> "
msgstr ""

#: in/chapter19.html:8
msgid ""
"<body bgcolor=\"white\" text=\"black\">\n"
"<h1>Chapter 19 - Streams</h1> "
msgstr ""
"<body bgcolor=\"white\" text=\"black\">\n"
"<h1>Глава 19 - Потоки</h1> "

#: in/chapter19.html:20
msgid ""
"<p>All of the I/O functions in Lisp accept a stream argument. In\n"
"some cases (e.g. <code>READ</code> and <code>PRINT</code>) the\n"
"stream argument is optional; by default, input comes from the\n"
"<code>*STANDARD-INPUT*</code> stream (normally connected to the\n"
"keyboard) and output goes to the <code>*STANDARD-OUTPUT*</code>\n"
"stream (normally connected to the display). You can redirect I/O by\n"
"either providing optional stream arguments to <code>READ</code> and\n"
"<code>PRINT</code> (as well as other I/O functions), or by binding\n"
"<code>*STANDARD-INPUT*</code> and <code>*STANDARD-OUTPUT*</code> to\n"
"different streams. (We'll see both of these approaches used in the\n"
"following examples.)"
msgstr ""
"<p>Все функции ввода-вывода в Lisp принимают аргумент поток(stream). В "
"некоторых случаях \n"
"(например, <code>READ</code> и <code>PRINT</code>) аргумент stream "
"является \n"
"необязательным; по умолчанию вход поступает из потока <code>*STANDARD-"
"INPUT*</code>\n"
"(обычно подключенного к клавиатуре), а выход - из потока <code>*STANDARD-"
"OUTPUT*</code>\n"
"(обычно подключенного к дисплею). Вы можете перенаправить ввод-вывод, либо "
"предоставив\n"
"дополнительные аргументы потока для чтения и печати (а также другие функции "
"ввода-вывода), либо связав <code>*STANDARD-INPUT*</code> и <code>*STANDARD-"
"OUTPUT*</code> с различными\n"
"потоками. (Мы увидим оба этих подхода, используемые в следующих примерах.)"

#: in/chapter19.html:22
msgid "<h2>Streams provide a pipe to supply or accept data</h2>"
msgstr ""
"<h2>Потоки предоставляют канал для передачи\n"
" и приема данных</h2>"

#: in/chapter19.html:29
msgid ""
"<p>Throughout the preceding chapters of this book, streams have\n"
"been involved whenever we've seen an example that does input or\n"
"output -- and <em>all</em> of the examples do I/O, if you count our\n"
"interactions with the listener. A Lisp stream can provide (source)\n"
"or consume (sink) a sequence of bytes or characters. (Remember the\n"
"Lisp definition of byte: a byte can contain any number of bits.)"
msgstr ""
"<p>\n"
"На протяжении всех предыдущих глав этой книги потоки были задействованы \n"
"всякий раз, когда мы видели пример, который делает ввод или вывод - и все \n"
"примеры делают ввод/вывод, если считать наши взаимодействия со слушателем. \n"
"Поток Lisp может предоставлять (источник) или потреблять (приемник) "
"последовательность\n"
"байтов или символов. (Вспомните определение байта в Лиспе: байт может "
"содержать любое\n"
"количество битов.)"

#: in/chapter19.html:39
msgid ""
"<p>Some I/O functions accept <code>T</code> or <code>NIL</code> as a\n"
"stream designator. <code>T</code> is a synonym for\n"
"<code>*TERMINAL-IO*</code>, a bidirectional (input <em>and</em>\n"
"output) stream which conventionally reads from\n"
"<code>*STANDARD-INPUT*</code> and writes to\n"
"<code>*STANDARD-OUTPUT*</code>. <code>NIL</code> is a synonym for\n"
"<code>*STANDARD-INPUT*</code> when used in a context which expects\n"
"an input stream, or for <code>*STANDARD-OUTPUT*</code> when used in\n"
"a context which expects an output stream."
msgstr ""
"<p>\n"
"Некоторые функции ввода-вывода принимают <code>T</code> или <code>NIL</"
"code> \n"
"в качестве обозначения потока. <code>T</code> - это синоним <code>*TERMINAL-"
"IO*</code>,\n"
"двунаправленного (входного и выходного) потока, который обычно считывает "
"данные из\n"
"<code>*STANDARD-INPUT*</code> и записывает их в <code>*STANDARD-OUTPUT*</"
"code>. \n"
"<code>NIL</code> - это синоним <code>*STANDARD-INPUT*</code> при "
"использовании в \n"
"контексте, который ожидает получить входной поток, или для <code>*STANDARD-"
"OUTPUT*</code>\n"
"при использовании в контексте которого ожидает поток вывода."

#: in/chapter19.html:48
msgid ""
"<blockquote>\n"
"<code>FORMAT</code> (which we've already seen in several examples, and\n"
"will examine in depth in <a href=\"chapter24.html\">Chapter 24</a>) expects\n"
"as its first argument a stream, a <code>T</code>, a <code>NIL</code>, or\n"
"a string with a fill pointer.  In this case, however, the <code>NIL</code> \n"
"designator causes <code>FORMAT</code> to return a string, rather than write\n"
"to <code>*STANDARD-OUTPUT*</code> as is the case for other I/O functions.\n"
"</blockquote> "
msgstr ""
"<blockquote>\n"
"<code>FORMAT</code> (который мы уже видели в нескольких примерах и "
"подробно \n"
"рассмотрим в <a href=\"chapter24.html\">Главе 24</a>) ожидает в качестве "
"своего \n"
"первого аргумента поток, <code>T</code>,  <code>NIL</code> или строку с "
"указателем\n"
"заполнения. Однако в этом случае обозначитель NIL заставляет формат "
"возвращать строку, а не записывать в *STANDARD-OUTPUT*, как это имеет место "
"для других функций ввода-вывода.\n"
"</blockquote> "

#: in/chapter19.html:55
msgid ""
"<p>The power of streams comes from the ability to associate a stream\n"
"with a file, a device (such as keyboard, display, or network), or a\n"
"memory buffer. Program I/O can be directed at will by simply\n"
"creating the appropriate type of stream for your program to use. The\n"
"I/O implementation is abstracted away by the stream so your program\n"
"won't have to be concerned with low-level details."
msgstr ""
"<p>\n"
"Мощь потоков происходит от способности связывать поток с файлом, "
"устройством \n"
"(например, клавиатурой, дисплеем или сетью) или буфером памяти. "
"Программный \n"
"ввод-вывод может быть направлен по желанию, просто созданием "
"соответствующего\n"
"типа потока для использования вашей программой. Реализация ввода-вывода \n"
"абстрагируется потоком, поэтому вашей программе не придется беспокоиться \n"
"о низкоуровневых деталях."

#: in/chapter19.html:73
msgid ""
"<p>Lisp also provides a number of special-purpose streams which\n"
"serve to combine or manipulate other streams in novel ways. A\n"
"<code>TWO-WAY-STREAM</code> combines a separate input stream and\n"
"output stream into an I/O stream. A <code>BROADCAST-STREAM</code>\n"
"sends output to zero or more output streams; think of this as a\n"
"bit-bucket when used with zero streams, and a broadcaster when used\n"
"with multiple streams. A <code>CONCATENATED-STREAM</code> accepts\n"
"input requests on behalf of zero or more input streams; when one\n"
"stream's input is exhausted, the <code>CONCATENATED-STREAM</code>\n"
"begins reading from its next input stream. An\n"
"<code>ECHO-STREAM</code> is like a <code>TWO-WAY-STREAM</code>, with\n"
"the added feature that anything your program reads from the\n"
"<code>TWO-WAY-STREAM</code>'s input stream automatically gets echoed\n"
"to the corresponding output stream. Finally, a\n"
"<code>SYNONYM-STREAM</code> is an alias for another stream; the\n"
"alias can be changed at runtime without creating a new\n"
"<code>SYNONYM-STREAM</code>."
msgstr ""
"<p>\n"
"Lisp также предоставляет ряд специальных потоков, которые служат для \n"
"объединения или манипулирования другими потоками новыми способами. \n"
"<code>TWO-WAY-STREAM</code>(Двусторонний поток) объединяет отдельный \n"
"входной поток и выходной поток в поток ввода-вывода. \n"
"<code>BROADCAST-STREAM</code>(Широковещательный поток) отправляет \n"
"выходные данные в ноль или более выходных потоков; думайте об этом \n"
"как о мусорном ведре, когда он используется с нулем потоков, и о \n"
"вещателе, когда он используется с несколькими потоками. \n"
"<code>CONCATENATED-STREAM</code>(Объединенный поток) принимает входные \n"
"запросы от имени нуля или более входных потоков; когда входные данные \n"
"одного потока исчерпаны, объединенный поток начинает считывание из \n"
"своего следующего входного потока. \n"
"<code>ECHO-STREAM</code>(Эхо-поток) подобен двустороннему потоку, \n"
"с добавленной функцией, что все, что ваша программа считывает из \n"
"входного потока двухстороннего потока, автоматически получает эхо \n"
"в соответствующий выходной поток. Наконец, \n"
"<code>SYNONYM-STREAM</code>(синоним-поток) - это псевдоним для \n"
"другого потока; псевдоним может быть изменен во время выполнения \n"
"без создания нового <code>SYNONYM-STREAM</code>."

#: in/chapter19.html:75
msgid "<p>Quite a few I/O functions operate directly on streams:"
msgstr ""
"<p>Довольно много функций ввода-вывода работают непосредственно на потоках:\n"

#: in/chapter19.html:77
msgid "<p>"
msgstr ""

#: in/chapter19.html:82
msgid ""
"<dl>\n"
"<dt><code>READ-BYTE</code> <i>stream &amp;optional eof-error-p eof-value</"
"i> \n"
"    and <code>READ-CHAR</code> <i>&amp;optional stream eof-error-p eof-value "
"recursive-p</i>  \n"
"<dd>Reads a byte or a character from an input stream."
msgstr ""
"<dl>\n"
"<dt><code>READ-BYTE</code> <i>stream &amp;optional eof-error-p eof-value</"
"i> \n"
"    and <code>READ-CHAR</code> <i>&amp;optional stream eof-error-p eof-value "
"recursive-p</i>  \n"
"<dd>Считывает байт или символьный знак из входного потока."

#: in/chapter19.html:86
msgid ""
"<dt><code>WRITE-BYTE</code> <i>byte stream</i> \n"
"    and <code>WRITE-CHAR</code> <i>char &amp;optional stream</i> \n"
"<dd>Writes a byte or a character to an output stream."
msgstr ""
"<dt><code>WRITE-BYTE</code> <i>byte stream</i> \n"
"    and <code>WRITE-CHAR</code> <i>char &amp;optional stream</i> \n"
"<dd>Записывает байт или символьный знак в выходной поток."

#: in/chapter19.html:93
msgid ""
"<dt><code>READ-LINE</code> <i>&amp;optional stream eof-error-p eof-value "
"recursive-p</i>\n"
"    and <code>WRITE-LINE</code> <i>string &amp;optional stream &amp;key "
"start end</i> \n"
"<dd>Read or write a line of text, terminated by a newline.  (The newline\n"
"is consumed and discarded on input, and added to output.) The \n"
"<code>:START</code> and <code>:END</code> keyword arguments let you \n"
"limit the portion of the string written by <code>WRITE-LINE</code>."
msgstr ""
"<dt><code>READ-LINE</code> <i>&amp;optional stream eof-error-p eof-value "
"recursive-p</i>\n"
"    и <code>WRITE-LINE</code> <i>string &amp;optional stream &amp;key start "
"end</i> \n"
"<dd>Читает или пишет строку текста, заканчивающуюся новой строкой. (Знак\n"
"новая строка считывается и отбрасывается на входе, или добавляется к "
"выводу.) \n"
"Аргументы ключевых слов <code>:START</code> и <code>:END</code> позволяют "
"ограничить\n"
"часть строки, написанной <code>WRITE-LINE</code>.."

#: in/chapter19.html:96
msgid ""
"<dt><code>WRITE-STRING</code> <i>string &amp;optional stream &amp;key start "
"end</i> \n"
"<dd>Like <code>WRITE-LINE</code>, but does not append a newline to output."
msgstr ""
"<dt><code>WRITE-STRING</code> <i>string &amp;optional stream &amp;key start "
"end</i> \n"
"<dd>Как и <code>WRITE-STRING</code>,но не добавляет знак новой строки при "
"выводе."

#: in/chapter19.html:103
msgid ""
"<dt><code>PEEK-CHAR</code> <i>&amp;optional peek-type stream eof-error-p eof-"
"value recursive-p</i>\n"
"<dd>Reads a character from an input stream without consuming the character.\n"
"(The character remains available for the next input operation.) Optional\n"
"argument <i>peek-type</i> alters <code>PEEK-CHAR</code>'s behavior to first\n"
"skip whitespace (<i>peek-type</i> <code>T</code>) or to first skip forward \n"
"to some specified character (<i>peek-type</i> a character)."
msgstr ""
"<dt><code>PEEK-CHAR</code> <i>&amp;optional peek-type stream eof-error-p eof-"
"value recursive-p</i>\n"
"<dd>Считывает символьный знак из входного потока, \n"
"не потребляя(извлекая) его. (Знак остается доступным для следующей \n"
"операции ввода.) Опционный <i>peek-type</i>-тип аргумента изменяет \n"
"поведение <code>PEEK-CHAR</code>, чтобы пропускать начальный пробел \n"
"(<i>peek-type</i> <code>T</code>) или пропустить первые знаки\n"
"заданного символьного знака (<i>peek-type</i>  character/символьный знак)."

#: in/chapter19.html:107
msgid ""
"<dt><code>UNREAD-CHAR</code> <i>character &amp;optional stream</i> \n"
"<dd>Pushes a character (which must be the character most recently read)\n"
"back onto the front of an input stream, where it remains until read again."
msgstr ""
"<dt><code>UNREAD-CHAR</code> <i>character &amp;optional stream</i> \n"
"<dd>Выталкивает знак (который должен быть последним прочитанным знаком) \n"
"обратно в переднюю часть входного потока, где он остается до тех пор, \n"
"пока не будет прочитан снова."

#: in/chapter19.html:111
msgid ""
"<dt><code>LISTEN</code> <i>&amp;optional stream</i> \n"
"<dd>Returns true if data is available (e.g. a yet-to-be-read keystroke or\n"
"unconsumed file data) on an input stream."
msgstr ""
"<dt><code>LISTEN</code> <i>&amp;optional stream</i> \n"
"<dd>Возвращает значение true, если во входном потоке имеются данные \n"
"(например, еще не прочитанные нажатия клавиш или неиспользуемые файловые "
"данные)."

#: in/chapter19.html:115
msgid ""
"<dt><code>READ-CHAR-NO-HANG</code> <i>&amp;optional stream eof-error-p eof-"
"value recursive-p</i>\n"
"<dd>If a character is available on the input stream, return the character.\n"
"Otherwise, return <code>NIL</code>."
msgstr ""
"<dt><code>READ-CHAR-NO-HANG</code> <i>&amp;optional stream eof-error-p eof-"
"value recursive-p</i>\n"
"<dd>Если символьный знак доступен во входном потоке, возвращает его. \n"
"В противном случае возвращает <code>NIL</code>."

#: in/chapter19.html:123
msgid ""
"<dt><code>TERPRI</code> <i>&amp;optional stream</i> \n"
"    and <code>FRESH-LINE</code> <i>&amp;optional stream</i> \n"
"<dd><code>TERPRI</code> unconditionally writes a newline to an output\n"
"stream. <code>FRESH-LINE</code> writes a newline unless it can determine\n"
"that the output stream is already at the beginning of a new line; \n"
"<code>FRESH-LINE</code> returns <code>T</code> if it actually wrote a \n"
"newline, and <code>NIL</code> otherwise."
msgstr ""
"<dt><code>TERPRI</code> <i>&amp;optional stream</i> \n"
"    и <code>FRESH-LINE</code> <i>&amp;optional stream</i> \n"
"<dd><code>TERPRI</code> безоговорочно записывает знак новой строки\n"
"в выходной поток. <code>FRESH-LINE</code> записывает знак новой строки, \n"
"если только он не может определить, что выходной поток уже находится в \n"
"начале новой строки; <code>FRESH-LINE</code> возвращает  <code>T</code>, \n"
"если он действительно написал новую строку, и <code>NIL</code>\n"
" в противном случае."

#: in/chapter19.html:126
msgid ""
"<dt><code>CLEAR-INPUT</code> <i>&amp;optional stream</i>\n"
"<dd>Flushes unread data from an input stream, if it makes sense to do so."
msgstr ""
"<dt><code>CLEAR-INPUT</code> <i>&amp;optional stream</i>\n"
"<dd>Сбрасывает непрочитанные данные из входного потока, если это имеет смысл."

#: in/chapter19.html:138
msgid ""
"<dt><code>FINISH-OUTPUT</code> <i>&amp;optional stream</i>, \n"
"    <code>FORCE-OUTPUT</code> <i>&amp;optional stream</i>, and \n"
"    <code>CLEAR-OUTPUT</code> <i>&amp;optional stream</i>\n"
"<dd>These functions flush output buffers if it makes sense to do so.\n"
"<code>FINISH-OUTPUT</code> tries to make sure that buffered output\n"
"reaches its destination, then returns.  \n"
"<code>FORCE-OUTPUT</code> attempts to initiate output from the buffer,\n"
"but does not wait for completion like <code>FINISH-OUTPUT</code>.\n"
"<code>CLEAR-OUTPUT</code> attempts\n"
"to discard buffered data and abort any output still in progress.\n"
"</dl> "
msgstr ""
"<dt><code>FINISH-OUTPUT</code> <i>&amp;optional stream</i>, \n"
"    <code>FORCE-OUTPUT</code> <i>&amp;optional stream</i>, and \n"
"    <code>CLEAR-OUTPUT</code> <i>&amp;optional stream</i>\n"
"<dd>Эти функции очищают выходные буферы, если это имеет смысл сделать. \n"
"<code>FINISH-OUTPUT</code> пытается убедиться, что буферизованный вывод \n"
"достигает своего назначения, а затем возвращается. <code>FORCE-OUTPUT</"
"code>\n"
"пытается инициировать вывод из буфера, но не ждет завершения, как \n"
"<code>FINISH-OUTPUT</code>. <code>CLEAR-OUTPUT</code> пытается отбросить \n"
"буферизованные данные и прервать все еще выполняемый вывод данных.\n"
"</dl> "

#: in/chapter19.html:147
msgid ""
"<p>In the read functions listed above, optional arguments \n"
"<code>EOF-ERROR-P</code> and <code>EOF-VALUE</code> specify what happens\n"
"when your program makes an attempt to read from an exhausted stream.\n"
"If <code>EOF-ERROR-P</code> is true (the default), then Lisp will signal\n"
"an error upon an attempt to read an exhausted stream. If \n"
"<code>EOF-ERROR-P</code> is <code>NIL</code>, then Lisp returns\n"
"<code>EOF-VALUE</code> (default <code>NIL</code>) instead of signalling\n"
"an error."
msgstr ""
"<p>\n"
"В функциях чтения, перечисленных выше, необязательные аргументы \n"
"<code>EOF-ERROR-P</code> и <code>EOF-VALUE</code>  указывают, \n"
"что произойдет, когда ваша программа делает попытку чтения из \n"
"исчерпанного потока. Если <code>EOF-ERROR-P</code> имеет значение true \n"
"(по умолчанию), то Lisp будет сигнализировать об ошибке при попытке \n"
"прочитать исчерпанный поток. Если <code>EOF-ERROR-P</code> равно <code>NIL</"
"code>,\n"
"то Lisp возвращает <code>EOF-VALUE</code> (default <code>NIL</code>) \n"
"вместо сигнализации об ошибке."

#: in/chapter19.html:150
msgid ""
"<p>Optional argument <code>RECURSIVE-P</code> is reserved for use by\n"
"functions called by the Lisp reader."
msgstr ""
"<p>Необязательный аргумент <code>RECURSIVE-P</code> зарезервирован \n"
"для использования функциями, вызываемыми программой чтения Lisp."

#: in/chapter19.html:153
msgid "<h2>Creating streams on files</h2>"
msgstr "<h2>Создание потоков на файлах</h2>"

#: in/chapter19.html:162
msgid ""
"<p>The <code>OPEN</code> function creates a\n"
"<code>FILE-STREAM</code>. Keyword arguments determine attributes of\n"
"the stream (<code>:DIRECTION</code>, <code>:ELEMENT-TYPE</code>, and\n"
"<code>:EXTERNAL-FORMAT</code>) and how to handle exceptional\n"
"conditions (<code>:IF-EXISTS</code> and\n"
"<code>:IF-DOES-NOT-EXIST</code>). If <code>OPEN</code> is successful\n"
"it returns a stream, otherwise it returns <code>NIL</code> or\n"
"signals an error."
msgstr ""
"<p>\n"
"Функция <code>OPEN</code> создает <code>FILE-STREAM</code>(файловый "
"поток). \n"
"Аргументы ключевые слова определяют атрибуты потока (<code>:DIRECTION</"
"code>,\n"
" <code>:ELEMENT-TYPE</code>, и <code>:EXTERNAL-FORMAT</code>) и способы "
"обработки\n"
"исключительных условий (<code>:IF-EXISTS</code> и  <code>:IF-DOES-NOT-EXIST</"
"code>). \n"
"Если <code>OPEN</code> проходит успешно, он возвращает поток, в противном "
"случае он\n"
"возвращает <code>NIL</code> или сигнализирует об ошибке."

#: in/chapter19.html:170
msgid ""
"<pre>\n"
"Keyword      Value     Stream Direction\n"
"----------   -------   -----------------------------\n"
":DIRECTION   :INPUT    input (default)\n"
":DIRECTION   :OUTPUT   output\n"
":DIRECTION   :IO       input & output\n"
":DIRECTION   :PROBE    none, returns a closed stream"
msgstr ""

#: in/chapter19.html:181
msgid ""
"Keyword      Value                Action if File Exists\n"
"----------   ------------------   ---------------------------------------\n"
":IF-EXISTS   NIL                  return NIL\n"
":IF-EXISTS   :ERROR               signal an error\n"
":IF-EXISTS   :NEW-VERSION         next version (or error)\n"
":IF-EXISTS   :RENAME              rename existing, create new\n"
":IF-EXISTS   :SUPERSEDE           replace file upon CLOSE\n"
":IF-EXISTS   :RENAME-AND-DELETE   rename and delete existing, create new\n"
":IF-EXISTS   :OVERWRITE           reuse existing file (position at start)\n"
":IF-EXISTS   :APPEND              reuse existing file (position at end)"
msgstr ""

#: in/chapter19.html:187
msgid ""
"Keyword              Value     Action if File Does Not Exist\n"
"------------------   -------   -----------------------------\n"
":IF-DOES-NOT-EXIST   NIL       return NIL\n"
":IF-DOES-NOT-EXIST   :ERROR    signal an error\n"
":IF-DOES-NOT-EXIST   :CREATE   create the file"
msgstr ""

#: in/chapter19.html:197
msgid ""
"Keyword         Value               Element Type\n"
"-------------   --------------      ------------------------\n"
":ELEMENT-TYPE   :DEFAULT            character (default)\n"
":ELEMENT-TYPE   'CHARACTER          character\n"
":ELEMENT-TYPE   'SIGNED-BYTE        signed byte\n"
":ELEMENT-TYPE   'UNSIGNED-BYTE      unsigned byte\n"
":ELEMENT-TYPE   <i>character subtype</i>   character subtype\n"
":ELEMENT-TYPE   <i>integer subtype</i>     integer subtype\n"
":ELEMENT-TYPE   <i>other</i>               implementation-dependent"
msgstr ""

#: in/chapter19.html:203
msgid ""
"Keyword            Value      File Format\n"
"----------------   --------   ------------------------\n"
":EXTERNAL-FORMAT   :DEFAULT   default (default)\n"
":EXTERNAL-FORMAT   <i>other</i>      implementation-dependent\n"
"</pre> "
msgstr ""

#: in/chapter19.html:208
msgid ""
"<p>Once you've opened a stream, you can use it with appropriate \n"
"input or output functions, or with queries that return attributes\n"
"of either the stream or the file.  The following queries can be\n"
"applied to all kinds of streams.  All of these accept a stream argument:"
msgstr ""
"<p>После открытия потока его можно использовать с соответствующими "
"функциями \n"
"ввода или вывода, а также с запросами, возвращающими атрибуты потока или "
"файла. \n"
"Следующие запросы могут быть применены ко всем видам потоков. Все они "
"принимают \n"
"аргумент поток:"

#: in/chapter19.html:218
msgid ""
"<pre>\n"
"Function               Returns\n"
"--------------------   "
"-----------------------------------------------------\n"
"INPUT-STREAM-P         true if stream can provide input\n"
"OUTPUT-STREAM-P        true if stream can accept output\n"
"OPEN-STREAM-P          true if stream is open\n"
"STREAM-ELEMENT-TYPE    the type specifier for stream elements\n"
"INTERACTIVE-STREAM-P   true if stream is interactive (e.g. keyboard/"
"display)\n"
"</pre> "
msgstr ""

#: in/chapter19.html:221
msgid ""
"<p>These queries can be applied to file streams.  These also accept a "
"stream\n"
"argument:"
msgstr ""
"<p>Эти запросы могут быть применены к потокам файлов. \n"
"Они также принимают аргумент поток:"

#: in/chapter19.html:229
msgid ""
"<pre>\n"
"Function                 Returns\n"
"--------------------     "
"-----------------------------------------------------\n"
"STREAM-EXTERNAL-FORMAT   implementation-dependent\n"
"FILE-POSITION            current file offset for read or write, or NIL\n"
"FILE-LENGTH              length of stream, or NIL\n"
"</pre> "
msgstr ""

#: in/chapter19.html:235
msgid ""
"<p><code>FILE-POSITION</code> returns a byte offset within the stream.\n"
"This is an exact count for streams of integer subtypes (see below for\n"
"further description of binary I/O). For streams of character subtypes,\n"
"the position is guaranteed only to increase during reading or writing;\n"
"this allows for variations in text record formats and line terminators."
msgstr ""
"<p>\n"
"<code>FILE-POSITION</code>  возвращает смещение в байтах внутри потока. \n"
"Это точный подсчет для потоков подтипа целых чисел(смотрите ниже для \n"
"дальнейшего описания двоичного ввода-вывода). Для потоков подтипа "
"символьных\n"
"знаков позиция гарантированно увеличивается только во время чтения или "
"записи; \n"
"это позволяет варьировать форматы текстовых записей и Терминаторы строк."

#: in/chapter19.html:239
msgid ""
"<p><code>FILE-POSITION</code> can also be called with a second argument to\n"
"change the file offset for the next read or write.  When used for this\n"
"purpose, <code>FILE-POSITION</code> returns true when it succeeds."
msgstr ""
"<p>\n"
"<code>FILE-POSITION</code>  также может быть вызван со вторым аргументом, \n"
"чтобы изменить смещение файла для следующего чтения или записи. \n"
"При использовании для этой цели FILE-POSITION возвращает true, когда это \n"
"происходит успешно."

#: in/chapter19.html:246
msgid ""
"<p>You should always close a stream when you're done using it\n"
"(except for the interactive streams provided for you use by Lisp,\n"
"such as <code>*STANDARD-INPUT*</code>,\n"
"<code>*STANDARD-OUTPUT*</code>, and <code>*TERMINAL-IO*</code>). The\n"
"\"open, process, close\" pattern is very common, so Lisp provides macros\n"
"to make the pattern both easy to code and error-free."
msgstr ""
"<p>\n"
"Вы всегда должны закрывать поток, когда вы закончите его использовать (за "
"исключением интерактивных потоков, предоставленных вам Lisp, таких "
"как<code>*STANDARD-INPUT*</code>,\n"
"<code>*STANDARD-OUTPUT*</code>, и <code>*TERMINAL-IO*</code>). \n"
"Шаблон \"открыть, обработать, закрыть\" очень распространен, поэтому Lisp "
"предоставляет\n"
"макросы, чтобы сделать шаблон простым в кодировании и безошибочным."

#: in/chapter19.html:251
msgid ""
"<p><code>WITH-OPEN-FILE</code> is tailored for file streams. Its arguments\n"
"are a variable to be bound to the stream, a pathname, and (optionally)\n"
"keyword arguments suitable for <code>OPEN</code>. The stream is always\n"
"closed when control leaves the <code>WITH-OPEN-FILE</code> form."
msgstr ""
"<p>\n"
"<code>WITH-OPEN-FILE</code>  адаптирован для файловых потоков.Его аргументы "
"-\n"
"это переменная, которая должна быть привязана к потоку, путь и "
"(необязательно) \n"
"ключевые аргументы, подходящие для <code>OPEN</code>. Поток всегда "
"закрывается, \n"
"когда элемент управления покидает форму <code>WITH-OPEN-FILE</code>"

#: in/chapter19.html:256
msgid ""
"<pre>\n"
"(with-open-file (stream \"my-file.dat\" :direction :input)\n"
"  ... do something using stream ...)\n"
"</pre> "
msgstr ""

#: in/chapter19.html:263
msgid ""
"<p><code>WITH-OPEN-STREAM</code> expects a variable name and a form to\n"
"be evaluated; the form should produce a stream value or <code>NIL</code>.\n"
"This macro is commonly used with constructors for specialty streams,\n"
"such as <code>MAKE-BROADCAST-STREAM</code>, <code>MAKE-ECHO-STREAM</code>, \n"
"<code>MAKE-TWO-WAY-STREAM</code>, <code>MAKE-CONCATENATED-STREAM</code>, \n"
"and <code>MAKE-SYNONYM-STREAM</code>."
msgstr ""
"<p>\n"
"<code>WITH-OPEN-STREAM</code>  ожидает, что имя переменной и форму для\n"
"вычисления; форма должна выдавать значение равное потоку или <code>NIL</"
"code>.\n"
"Этот макрос обычно используется с конструкторами специальных потоков, таких\n"
"как: <code>MAKE-BROADCAST-STREAM</code>, <code>MAKE-ECHO-STREAM</code>, \n"
"<code>MAKE-TWO-WAY-STREAM</code>, <code>MAKE-CONCATENATED-STREAM</code>, \n"
"и <code>MAKE-SYNONYM-STREAM</code>."

#: in/chapter19.html:265
msgid "<h2>Creating streams on strings</h2>"
msgstr "<h2>Создание потоков на строках</h2>"

#: in/chapter19.html:273
msgid ""
"<p>The data read or written by a stream doesn't have to be associated\n"
"with a device -- the data can just as well be in memory. String streams\n"
"let you read and write at memory speeds, but they can't provide either\n"
"file or interactive capabilities.  Lisp provides constructors\n"
"(<code>MAKE-STRING-INPUT-STREAM</code> and \n"
"<code>MAKE-STRING-OUTPUT-STREAM</code>), plus macros to support the\n"
"\"open, process, close\" pattern."
msgstr ""
"<p>\n"
"Данные, считываемые или записываемые потоком, не обязательно должны быть \n"
"связаны с устройством - они также могут находиться в памяти. Строковые "
"потоки\n"
"позволяют вам читать и писать на скоростях памяти, но они не могут "
"обеспечить \n"
"ни файловые, ни интерактивные возможности. Lisp предоставляет конструкторы \n"
"(<code>MAKE-STRING-INPUT-STREAM</code> и \n"
"<code>MAKE-STRING-OUTPUT-STREAM</code>), плюс макросы для поддержки шаблона\n"
"работы: \"Открытия, обработать, закрыть\"."

#: in/chapter19.html:282
msgid ""
"<pre>\n"
"? (with-input-from-string (stream \"This is my input via stream.\")\n"
"    (read stream))\n"
"THIS\n"
"? (with-output-to-string (stream)\n"
"    (princ \"I'm writing to memory!\" stream))\n"
"\"I'm writing to memory!\"\n"
"</pre> "
msgstr ""

#: in/chapter19.html:290
msgid ""
"<p>These macros accept keyword and optional arguments.\n"
"<code>WITH-INPUT-FROM-STRING</code> allows <code>:BEGIN</code> and\n"
"<code>:END</code> keyword arguments to establish bounds on the\n"
"portion of the string read via the stream. A <code>:INDEX</code> keyword\n"
"argument lets you name a variable to receive the offset of the next\n"
"string element to be read -- this is set only upon leaving the \n"
"<code>WITH-INPUT-FROM-STRING</code> form."
msgstr ""
"<p>\n"
"Эти макросы принимают ключевые слова и необязательные аргументы. \n"
"<code>WITH-INPUT-FROM-STRING</code> позволяет аргументам ключевым словам\n"
"<code>:BEGIN</code> и <code>:END</code> устанавливать границы части "
"строки, \n"
"считываемой через поток. A аргумент ключевое слово <code>:INDEX</code>\n"
"позволяет вам задать имя переменной, получающей смещение следующего \n"
"строкового элемента для чтения - он устанавливается только при выходе из \n"
"формы <code>WITH-INPUT-FROM-STRING</code>."

#: in/chapter19.html:295
msgid ""
"<p><code>WITH-OUTPUT-TO-STRING</code> allows an optional form, which is\n"
"evaluated to produce the output string; if this form is missing or\n"
"<code>NIL</code>, the macro creates a string for you using the\n"
"<code>:ELEMENT-TYPE</code> keyword argument."
msgstr ""
"<p>\n"
"<code>WITH-OUTPUT-TO-STRING</code> позволяет использовать \n"
"необязательную форму, которая вычисляется для получения выходной строки; \n"
"если эта форма отсутствует или равна <code>NIL</code>, макрос создает "
"строку \n"
"для вас, используя аргумент ключевое слово <code>:ELEMENT-TYPE</code>."

#: in/chapter19.html:297
msgid "<h2>Binary I/O</h2>"
msgstr "<h2>Двоичный Ввод/Вывод</h2>"

#: in/chapter19.html:301
msgid ""
"<p>Lisp supports binary I/O via streams whose element types are\n"
"finite (i.e. bounded) subtypes of <code>INTEGER</code>. Some\n"
"examples of appropriate types are:"
msgstr ""
"<p>\n"
"Лисп поддерживает двоичный ввод/вывода через потоки элементов, типы "
"которых \n"
"конечны (т. е. ограничена) подтипом типа <code>INTEGER</code>. Вот "
"некоторые \n"
"примеры подходящих типов:"

#: in/chapter19.html:320
msgid ""
"<ul>\n"
"<li>Implementation-dependent\n"
"<ul>\n"
" <li><code>SIGNED-BYTE</code> \n"
" <li><code>UNSIGNED-BYTE</code> \n"
"</ul> \n"
"<li>Range of values\n"
"<ul>\n"
" <li><code>(INTEGER 0 31)</code> \n"
" <li><code>(INTEGER -16 15)</code> \n"
"</ul> \n"
"<li>Specific number of bits\n"
"<ul>\n"
" <li><code>(SIGNED-BYTE 8)</code> \n"
" <li><code>(UNSIGNED-BYTE 6)</code> \n"
" <li><code>BIT</code> \n"
"</ul> \n"
"</ul> "
msgstr ""
"<ul>\n"
"<li>Зависимые от реализации\n"
"<ul>\n"
" <li><code>SIGNED-BYTE</code> \n"
" <li><code>UNSIGNED-BYTE</code> \n"
"</ul> \n"
"<li>Диапазон значений\n"
"<ul>\n"
" <li><code>(INTEGER 0 31)</code> \n"
" <li><code>(INTEGER -16 15)</code> \n"
"</ul> \n"
"<li>Определенное количество битов\n"
"<ul>\n"
" <li><code>(SIGNED-BYTE 8)</code> \n"
" <li><code>(UNSIGNED-BYTE 6)</code> \n"
" <li><code>BIT</code> \n"
"</ul> \n"
"</ul> "

#: in/chapter19.html:327
msgid ""
"<p>ANSI Common Lisp implementations should support any of these\n"
"types for binary I/O.  However, the implementation is not required to \n"
"directly map the specified <code>:ELEMENT-TYPE</code> onto the \n"
"underlying file system; an implementation is permitted to alter the\n"
"external format so long as data read from a binary file is the same\n"
"as that written using the same <code>:ELEMENT-TYPE</code>."
msgstr ""
"<p>\n"
"Реализации ANSI Common Lisp должны поддерживать любой из этих типов \n"
"для двоичного ввода-вывода. однако реализация не обязана напрямую \n"
"сопоставлять указанный  <code>:ELEMENT-TYPE</code> с базовой файловой "
"системой; \n"
"реализация может изменять внешний формат до тех пор, пока данные, \n"
"считываемые из двоичного файла, совпадают с данными, записанными с \n"
"использованием того же <code>:ELEMENT-TYPE</code>."

#: in/chapter19.html:340
msgid ""
"<hr>\n"
"<div align=\"center\">\n"
"<a href=\"contents.html\">Contents</a> | <a href=\"cover.html\">Cover</a> "
"<br> \n"
"<a href=\"chapter18.html\">Chapter 18</a> | Chapter 19 | <a href=\"chapter20."
"html\">Chapter 20</a> \n"
"</div>\n"
"<hr>\n"
"<address>\n"
"Copyright &copy; 1995-2001, David B. Lamkins<br>\n"
"All Rights Reserved Worldwide<br>\n"
"<br>\n"
"This book may not be reproduced without the written consent of its author.  "
"Online distribution is restricted to the author's site.\n"
"</address> \n"
"</body> </html> "
msgstr ""
