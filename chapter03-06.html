<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Successful Lisp - Chapter 3, Lesson 6</title> 
</head> 

<body bgcolor="white" text="black">
<h1>Глава 3 - Основы Лисп в 12 уроках</h1> 

<h2><A NAME="lesson-6">Урок 6 - Связывание против Присваивания</A></h2> 

<h3>Привязка(Binding) создает новое место для хранения значения</h3> 

<P>
Lisp часто "создает привязку" для переменной, выделяя часть памяти 
для хранения значения переменной и помещая это значение во вновь 
выделенную память. Привязка - это очень общий механизм реализации 
лексической области для переменных, но он имеет и другие применения в
зависимости от времени жизни привязки. Мы еще вернемся к этому в 
<A HREF="chapter08.html">главе 8</A>, когда будем изучать время жизни и
видимость.
</P>

<BLOCKQUOTE>
Да, Lisp выделяет хранилище для новых Привязок. Хотя это звучит так, как 
будто это может быть ужасно неэффективно, мы еще ничего не сказали о том, 
<EM>где</EM> Lisp выделил хранилище. Например, Lisp привязывает параметры функции к фактическим значениям, но выделяет хранилище в стеке точно так же, как и любой другой язык программирования. Lisp создает привязки в куче, если 
он не может определить, что привязка имеет время жизни, которое заканчивается,
когда форма привязки завершает выполнение.
</BLOCKQUOTE>

<h3>Привязки имеют имена</h3> 

<P>
Lisp дает каждой привязке имя. В противном случае, как бы ваша 
программа обращалась к привязке? Все просто, да? 
</P>

<h3>Привязка может иметь одновременно разные значения</h3> 

<P>Довольно часто для нескольких Привязок используется одно и то же имя. Например:</P>

<PRE WIDTH=80>(let ((a 1))
   (let ((a 2))
      (let ((a 3))
         ...)))</PRE>

<P>
Здесь <CODE>A</CODE> получает три отчетливых привязки к тому времени, 
когда тело (обозначено <CODE>...</CODE>) начнет исполнятся в самом внутреннем
<CODE>LET</CODE>.
</P>

<BLOCKQUOTE>
Однако это не означает, что приведенный выше пример является репрезентативным
для типичного кода Lisp.
</BLOCKQUOTE>

<h3>Одна привязка является самой внутренней</h3> 

<PRE WIDTH=80><I>;; Здесь, не имеет никакой привязки.</I>
(let ((a 1))
   <I>;; Здесь, самая внутренняя привязка  A имеет значение 1.</I>
   (let ((a 2))
      <I>;; Здесь, самая внутренняя привязка  A имеет значение 2.</I>
      (let ((a 3))
         <I>;; Здесь, самая внутренняя привязка  A имеет значение 3.</I>
         ...)))</PRE>

<P>
Как вы можете видеть, понятие внутренней привязки зависит от относительного
положения кода вашей программы к форме, которая установила ту или иную
привязку. Если вы посмотрите на то, как вложены формы привязки (это легко
сделать, если вы отформатируете свой код, как показано выше), то программа
имеет доступ к привязкам, созданным вокруг или заключающим ваш программный 
код.
</P>

<P>
Еще одна вещь, которую вы должны знать, заключается в том, что внешняя привязка
будет видна через внутренние формы привязки, пока внутренняя форма привязки 
не свяжет тот же самый символ:
</P>

<PRE WIDTH=80><I>;; Здесь A и B не имеют привязки.</I>
(let ((a 1)
      (b 9))
   <I>;; Здесь, внутрення привязка A имеет значение 1,
   ;; а привязка B имеет значение 9.</I>
   (let ((a 2))
      <I>;; Здесь, внутрення привязка A имеет значение 2.
      ;; Привязка B все еще имеет значение 9.</I>
      (let ((a 3))
         <I>;; Здесь, внутрення привязка A имеет значение 3.
         ;; B все еще имеет значение 9 из самой внешней формы LET.</I>
         ...)))</PRE>

<h3>Программа может получить доступ только к привязкам, которые она создает</h3> 

<P>Когда форма привязки связывает новое значение с существующим символом,
Предыдущее значение становится затененным. Значение внешней привязки
скрыто (но не забыто), в то время как ваш программный код выполняется 
внутри формы внутренней привязки. Но как только ваша программа покидает форму
внутренней привязки, значение внешней привязки восстанавливается. Например:</P>

<PRE WIDTH=80>(let ((z 1))
   <I>;; Здесь, внутренняя привязка Z имеет значение 1.</I>
   (let ((z 2))
      <I>;; Здесь, внутренняя привязка Z имеет значение 2.</I>
      ...)
   <I>;; Здесь, мы выходим из внутренней связывающей формы
   ;; и мы снова видм что z связана со значением 1.</I>
   ...)</PRE>

<h3>Присвоение записывает на старое место новое значение</h3>

<P>
Форма <CODE>SETQ</CODE> изменяет значение существующей привязки:
</P>

<PRE WIDTH=80>(let ((z 1))
   <I>;; Здесь внутрення привязка Z имеет значение 1.</I>
   (setq z 9)
   <I>;; Сейчас значение Z равно 9.</I>
   (let ((z 2))
      <I>;; Здесь внутрення привязка Z имеет значение 2.</I>
      ...)
   <I>;; Здесь, мы выходим из внутренней связывающей формы
   ;; и мы снова видм что z связана со значением 9.</I>
   ...)</PRE>

<P>
Приведенная выше форма <CODE>SETQ</CODE> изменила значение внешней привязки
<CODE>Z</CODE> для оставшейся части внешней формы <CODE>LET</CODE>. Зачастую
так делать неправильно. Проблема заключается в том, что теперь вам придется
искать значение <CODE>Z</CODE> в двух местах - сначала в формах привязки, 
а затем в программном коде для таких присваиваний, как <CODE>SETQ</CODE>. 
В то время как формы привязки имеют отступы по соглашению (многие редакторы
Lisp делают это при вводе текста), форма присваивания, как часть основного 
кода программы, не получает специального отступа; это затрудняет поиск при
чтении программы.
</P>

<P>
Мы можем довольно легко избежать присваивания в предыдущем примере, 
введя новую привязку:
</P>

<PRE WIDTH=80>(let ((z 1))
   <I>;; Здесь, внутренняя привязка has имеет значение 1.</I>
   (let ((z 9))
      <I>;; Здесь значение Z равно 9.</I>
      (let ((z 2))
         <I>;; Здесь, внутренняя привязка has имеет значение 2.</I>
         ...)
      <I>;; Здесь, мы выходим из внутренней связывающей формы
         ;; и мы снова видм что z связана со значением 9.</I>
      ...)
   <I>;; Здесь мы видим самую внешнюю привязку Z со значением 1.</I>
   ...)</PRE>

<P>
Теперь все привязки <CODE>Z</CODE> очевидны из относительного отступа форм
<CODE>LET</CODE>. Во время чтения программы все, что нам нужно сделать, 
чтобы найти правильную привязку для <CODE>Z</CODE> в любой точке нашего
программного кода (<CODE>...</CODE> в Примере) состоит в том, чтобы 
просматривать код сверху вниз, ища форму <CODE>LET</CODE> на внешнем 
уровне отступа.
</P>

<P>
Когда форма <CODE>SETQ</CODE> ссылается на переменную, которая не связана заключающей формой <CODE>LET</CODE>, она присваивает значение глобальному 
или специальному значению символа. Глобальное значение доступно везде, 
где оно не затенено, и остается доступным до тех пор, пока работает система Lisp. Мы рассмотрим специальные переменные в 
<A HREF="chapter08.html">Глава 8</A>.
.

<PRE WIDTH=80>(setq a 987)
<I>;; Здесь A имеет глобальное значение 987.</I>
(let ((a 1))
   <I>;; Здесь, привязка A к значению 1 затеняет глобальное значение.</I>
   ...)
<I>;; Здесь глобальное значение  A снова видно.</I>
...</PRE>

<hr>
<div align="center">
<a href="contents.html">Contents</a> | <a href="cover.html">Cover</a> <br> 
<a href="chapter02.html">Chapter 2</a> | <A HREF="chapter03.html">Chapter 3, Introduction</A> | <A HREF="chapter03-05.html">Chapter 3, Lesson 5</A> | Chapter 3, Lesson 6 | <A HREF="chapter03-07.html">Chapter 3, Lesson 7</A> | <a href="chapter04.html">Chapter 4</a> | 
</div>
<hr>
<address>
Copyright &copy; 1995-2001, David B. Lamkins<br>
All Rights Reserved Worldwide<br>
<br>
This book may not be reproduced without the written consent of its 
author.  Online distribution is restricted to the author's site.
</address> 
</body> </html>