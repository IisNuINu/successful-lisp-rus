#
# NuINu <don't@send.my>, 2020.
#
#. extracted from in/chapter23.html
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-04-19 13:51+0300\n"
"PO-Revision-Date: 2020-06-09 10:57+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter23.html:5
msgid ""
"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/"
"html4/strict.dtd\">\n"
"<html><head>\n"
"<title>Successful Lisp - Chapter 23</title>\n"
"</head> "
msgstr ""

#: in/chapter23.html:8
msgid ""
"<body bgcolor=\"white\" text=\"black\">\n"
"<h1>Chapter 23 - To Err is Expected; To Recover, Divine</h1> "
msgstr ""
"<body bgcolor=\"white\" text=\"black\">\n"
"<h1>Глава 23 - Совершать ошибки это ожидаемо; Восстановление, \n"
"Божественно</h1> "

#: in/chapter23.html:13
msgid ""
"<P>In this chapter you'll learn how to create your own error detection,\n"
"reporting and recovery mechanisms. A good error handling strategy can\n"
"give your program the ability to gracefully handle both expected and\n"
"unexpected errors without failing or losing critical data."
msgstr ""
"<P>\n"
"В этой главе вы узнаете, как создать свои собственные механизмы обнаружения "
"ошибок, \n"
"отчетности и восстановления. Хорошая стратегия обработки ошибок может дать "
"вашей \n"
"программе возможность изящно обрабатывать как ожидаемые, так и "
"непредвиденные \n"
"ошибки без сбоев или потери критических данных."

#: in/chapter23.html:15
msgid "<h2>Signal your own errors and impress your users</h2>"
msgstr "<h2>Сообщите о своих ошибках и впечатлите своих пользователей</h2>"

#: in/chapter23.html:25
msgid ""
"<p>One of the most common failings of computer programs is the\n"
"failure to report failures in a meaningful way. If some input is out\n"
"of the expected range, or if a calculation exceeds the capabilities\n"
"of the program, or if communication does not succeed with some\n"
"external device, a poorly-written program will simply \"roll over and\n"
"die\" with a cryptic error message related to hidden details of the\n"
"program's implementation. In theory, it's nice to be able to\n"
"construct programs without limits; the dynamic nature of Lisp\n"
"certainly enables this practice."
msgstr ""
"<p>\n"
"Одним из наиболее распространенных недостатков компьютерных программ \n"
"является неспособность сообщать о сбоях осмысленным образом. Если \n"
"какой-то ввод выходит за пределы ожидаемого диапазона, или если \n"
"вычисление превышает возможности программы, или если не удается установить \n"
"связь с каким-то внешним устройством, плохо написанная программа просто \n"
"\"перевернется и умрет\" с загадочным сообщением об ошибке, связанным со \n"
"скрытыми деталями реализации программы. В теории приятно иметь возможность \n"
"создавать программы без ограничений; динамическая природа Lisp, "
"безусловно, \n"
"допускает эту практику."

#: in/chapter23.html:37
msgid ""
"<p>But in almost every non-trivial program there will always arise\n"
"some fatal situation that can be anticipated by the programmer but\n"
"not addressed by the program. It is precisely for these situations\n"
"that Lisp provides the <code>ERROR</code> function.\n"
"<code>ERROR</code> expects a format string and arguments. (We've\n"
"seen <code>FORMAT</code> briefly in <a href=\"chapter04.html\">Chapter\n"
"4</a>, and will examine it in detail in <a\n"
"href=\"chapter24.html\">Chapter 24</a>.) <code>ERROR</code> gives your\n"
"program a standard way to announce a fatal error. You simply compose\n"
"an appropriate message using the format string and (optional)\n"
"arguments, and <code>ERROR</code> takes care of the rest. "
msgstr ""
"<p>\n"
"Но почти в каждой нетривиальной программе всегда будет возникать некая \n"
"фатальная ситуация, которую программист может предвидеть, но не решит \n"
"сама программа. Именно для этих ситуаций Lisp предоставляет функцию "
"<code>ERROR</code>.\n"
"<code>ERROR</code> ожидает строку формата и аргументы. (Мы кратко "
"рассмотрели <code>FORMAT</code>\n"
"в <a href=\"chapter04.html\">Главе 4</a> и подробно рассмотрим его в\n"
"<a href=\"chapter24.html\">Главе 24</a>.) <code>ERROR</code> дает программе "
"стандартный \n"
"способ объявить о фатальной ошибке. Вы просто составляете соответствующее "
"сообщение, \n"
"используя строку формата и (необязательные) аргументы, а об остальном "
"заботится <code>ERROR</code>."

#: in/chapter23.html:49
msgid ""
"<pre>\n"
"? (defun divide (numerator denominator)\n"
"    (when (zerop denominator)\n"
"      (error \"Sorry, you can't divide by zero.\"))\n"
"    (/ numerator denominator))\n"
"DIVIDE\n"
"? (divide 4 3)\n"
"4/3\n"
"? (divide 1 0)\n"
"Error: Sorry, you can't divide by zero.\n"
"</pre> "
msgstr ""

#: in/chapter23.html:58
msgid ""
"<p>Your program never returns from the call to <code>ERROR</code>.\n"
"Instead, the Lisp debugger will be entered. You'll have an\n"
"opportunity to examine the cause of the error while in the debugger,\n"
"but you will not be able to resume your program's execution. This\n"
"makes <code>ERROR</code> a rather extreme response to a problem detected\n"
"by your program. Later, we'll see how to report problems\n"
"<em>and</em> give the user an opportunity to correct the problem.\n"
"We'll even see how errors can be handled automatically."
msgstr ""
"<p>\n"
"Ваша программа никогда не возвращается из вызова <code>ERROR</code>. \n"
"Вместо этого будет произведен вход в отладчик Lisp. У вас будет "
"возможность \n"
"изучить причину ошибки, находясь в отладчике, но вы не сможете возобновить \n"
"выполнение своей программы. Это делает <code>ERROR</code> довольно "
"экстремальным \n"
"ответом на проблему, обнаруженную вашей программой. Позже мы увидим, как "
"сообщать \n"
"о проблемах <em>и</em> дать пользователю возможность исправить проблему. \n"
"Мы даже увидим, как ошибки могут быть обработаны автоматически."

#: in/chapter23.html:60
msgid "<h2>Categorize errors using Conditions</h2>"
msgstr "<h2>Классифицируйте ошибки, используя условия(Conditions)</h2>"

#: in/chapter23.html:66
msgid ""
"<blockquote> Note: If you have a really old Lisp system, it may not\n"
"include an implementation of conditions. If so, this section and the\n"
"following one may not be of much use to you, except to point out\n"
"what your Lisp system lacks as compared to the current standard.\n"
"</blockquote> "
msgstr ""
"<blockquote> \n"
"Примечание: Если у вас действительно старая система Lisp, она может \n"
"не включать в себя реализацию условий. Если это так, то этот раздел \n"
"и следующий могут быть не очень полезны для вас, за исключением того, \n"
"чтобы указать, чего не хватает вашей системе Lisp по сравнению с \n"
"текущим стандартом.\n"
"</blockquote> "

#: in/chapter23.html:71
msgid ""
"<p>An error is just a condition that requires some kind of correction\n"
"before your program may continue.  The error may be corrected by having\n"
"the program's user interact with the debugger, or through the intervention\n"
"of a handler (as we'll see later in this chapter)."
msgstr ""
"<p>\n"
"Ошибка - это просто условие, которое требует некоторого исправления, "
"прежде \n"
"чем ваша программа cможет продолжить работу. Ошибка может быть исправлена "
"с \n"
"помощью взаимодействия пользователя программы с отладчиком или с помощью \n"
"вмешательства обработчика/handler (как мы увидим далее в этой главе) ошибок."

#: in/chapter23.html:85
msgid ""
"<p>A condition is just some exceptional event that happens in your\n"
"program. The event may be due to an error, or it could be something\n"
"of interest that happens while your program runs. For example, a\n"
"program that writes entries to a log file on disk might call a\n"
"routine that handles the record formatting and writing. The logging\n"
"routine might periodically check the amount of space available on disk\n"
"and signal a condition when the disk becomes ninety percent full.  This\n"
"is not an error, because the logger won't fail under this condition.\n"
"If your program ignores the \"almost-full\" message from the logger, "
"nothing\n"
"bad will happen.  However, your program may wish to do something useful\n"
"with the information about the available disk space, such as archiving\n"
"the log to a different device or informing the user that some corrective\n"
"action may be needed soon."
msgstr ""
"<p>\n"
"Условие(condition) - это просто какое-то исключительное событие, которое \n"
"происходит в вашей программе. Это событие может быть вызвано ошибкой или \n"
"чем-то интересным, что происходит во время выполнения вашей программы. \n"
"Например, программа, которая записывает записи в файл журнала на диске, \n"
"может вызвать процедуру, которая обрабатывает форматирование и запись "
"записей. \n"
"Процедура ведения журнала может периодически проверять объем свободного "
"места \n"
"на диске и сигнализировать о том, что диск заполнен на девяносто "
"процентов. \n"
"Это не ошибка, потому что регистратор не выйдет из строя при этом условии. \n"
"Если ваша программа игнорирует сообщение \"почти заполнен\"  от "
"регистратора, \n"
"ничего плохого не произойдет. Однако ваша программа может захотеть сделать \n"
"что-то полезное с информацией о доступном дисковом пространстве, например, \n"
"архивировать журнал на другое устройство или сообщить пользователю, что в \n"
"ближайшее время могут потребоваться некоторые корректирующие действия."

#: in/chapter23.html:90
msgid ""
"<p>Now we know the distinction between conditions and errors.  For now, \n"
"we're going to focus our attention on the tools Lisp provides for \n"
"handling errors.  Later, we'll look at how your program can signal and\n"
"handle conditions."
msgstr ""
"<p>\n"
"Теперь мы знаем разницу между условиями(conditions) и ошибками(errors). \n"
"А пока мы сосредоточим наше внимание на инструментах, которые "
"предоставляет \n"
"Lisp для обработки ошибок. Позже мы рассмотрим, как ваша программа может \n"
"сигнализировать и обрабатывать условия."

#: in/chapter23.html:96
msgid ""
"<p>You could report errors using format strings as described above.\n"
"But for the sake of consistency and maintainability, you'll probably\n"
"want to create different classifications of errors. That way, you can\n"
"change the presentation of an entire class of errors without searching\n"
"your program code to change all of the similar format strings."
msgstr ""
"<p>\n"
"Вы можете сообщить об ошибках, используя строки формата, как описано выше. \n"
"Но ради согласованности и ремонтопригодности вы, вероятно, захотите "
"создать \n"
"различные классификации ошибок. Таким образом, вы можете изменять "
"представление \n"
"целого класса ошибок без поиска в программном коде, чтобы изменить все "
"строки \n"
"аналогичного формата."

#: in/chapter23.html:101
msgid ""
"<p>A <code>condition</code> represents some <em>exceptional\n"
"situation</em> which occurs during the execution of your program. An \n"
"error is a kind of condition, but not all conditions are errors. The \n"
"next section will cover this distinction in greater detail."
msgstr ""
"<p> \n"
"Условие(<code>condition</code>) представляет собой некоторую \n"
"исключительную ситуацию(<em>exceptional situation</em>), которая \n"
"возникает во время выполнения вашей программы. Ошибка - это своего \n"
"рода условие, но не все условия являются ошибками. В следующем разделе \n"
"это различие будет рассмотрено более подробно.\n"

#: in/chapter23.html:105
msgid ""
"<p>You can use <code>DEFINE-CONDITION</code> to create type hierarchies\n"
"for conditions in much the same way that you use <code>DEFCLASS</code> \n"
"to create type hierarchies for your program's data."
msgstr ""
"<p>\n"
"Вы можете использовать <code>DEFINE-CONDITION</code> для создания иерархий \n"
"типов для условий почти так же, как вы используете <code>DEFCLASS</code> "
"для \n"
"создания иерархий типов для данных вашей программы."

#: in/chapter23.html:136
msgid ""
"<pre>\n"
"? (define-condition whats-wrong (error)\n"
"                    ((what :initarg :what :initform \"something\" :reader "
"what))\n"
"    (:report (lambda (condition stream)\n"
"               (format stream \"Foo! ~@(~A~) is wrong.\"\n"
"                       (what condition))))\n"
"    (:documentation \"Tell the user that something is wrong.\"))\n"
"WHATS-WRONG\n"
"? (define-condition whats-wrong-and-why (whats-wrong)\n"
"                    ((why :initarg :why :initform \"no clue\" :reader why))\n"
"    (:report (lambda (condition stream)\n"
"               (format stream \"Uh oh! ~@(~A~) is wrong. Why? ~@(~A~).\"\n"
"                       (what condition)\n"
"                       (why condition)))))\n"
"WHATS-WRONG-AND-WHY\n"
"? (error 'whats-wrong-and-why)\n"
"Error: Uh oh! Something is wrong. Why? No clue.\n"
"? (error 'whats-wrong-and-why \n"
"         :what \"the phase variance\" \n"
"         :why \"insufficient tachyon flux\")\n"
"Error: Uh oh! The phase variance is wrong. Why? Insufficient tachyon flux.\n"
"? (define-condition whats-wrong-is-unfathomable (whats-wrong-and-why)\n"
"                    ()\n"
"    (:report (lambda (condition stream)\n"
"               (format stream \"Gack! ~@(~A~) is wrong for some inexplicable "
"reason.\"\n"
"                       (what condition)))))\n"
"WHATS-WRONG-IS-UNFATHOMABLE\n"
"? (error 'whats-wrong-is-unfathomable)\n"
"Error: Gack! Something is wrong for some inexplicable reason.\n"
"</pre> "
msgstr ""

#: in/chapter23.html:143
msgid ""
"<p>As you can see, conditions have parents, slots and options just\n"
"like classes. The <code>:REPORT</code> option is used to generate\n"
"the textual presentation of a condition. The\n"
"<code>:DOCUMENTATION</code> option is for the benefit of the\n"
"programmer; you can retrieve a condition's documentation using\n"
"<code>(DOCUMENTATION '<em>condition-name</em> 'type)</code>."
msgstr ""
"<p>\n"
"Как вы можете видеть, условия имеют родителей, слоты и параметры/опции, как "
"и классы. \n"
"Параметр <code>:REPORT</code> используется для создания текстового "
"представления условия. \n"
"Параметр <code>:DOCUMENTATION</code> предназначен для программиста; вы "
"можете получить \n"
"документацию по условию с помощью <code>(DOCUMENTATION '<em>condition-name</"
"em> 'type)</code>."

#: in/chapter23.html:150
msgid ""
"<blockquote> ANSI Common Lisp also allows a\n"
"<code>:DEFAULT-INITARGS</code> option. Some Lisp systems still base\n"
"their implementation of conditions on the description found in Guy\n"
"Steele's \"Common Lisp: The Language, 2nd Edition\" (<a\n"
"href=\"chapter33.html#cltl2\">CLtL2</a>); these implementations do not\n"
"have a <code>:DEFAULT-INITARGS</code> option. </blockquote> "
msgstr ""
"<blockquote> \n"
"ANSI Common Lisp также допускает параметр <code>:DEFAULT-INITARGS</code>. \n"
"Некоторые системы Lisp все еще основывают свою реализацию условий на "
"описании, \n"
"найденном в книге Гая Стила \"Common Lisp: The Language, 2nd Edition\" \n"
"(<a href=\"chapter33.html#cltl2\">CLtL2</a>); \n"
"эти реализации не имеют опции <code>:DEFAULT-INITARGS</code>. \n"
"</blockquote> "

#: in/chapter23.html:162
msgid ""
"<a name=\"condition-designator\"></a> \n"
"<p>If you've compared the <code>ERROR</code> calls in this section\n"
"to those of the previous section, you're probably wondering how both\n"
"a string and a symbol can designate a condition. If you pass a\n"
"symbol to <code>ERROR</code> , it constructs a condition using\n"
"<code>MAKE-CONDITION</code> (analogous to <code>MAKE-INSTANCE</code>\n"
"for CLOS objects); the symbol designates the type of the condition,\n"
"and the arguments are used to initialize the condition. If you pass\n"
"a format string to <code>ERROR</code>, the format string and its\n"
"arguments become initialization options for the construction of a\n"
"condition of type <code>SIMPLE-ERROR</code>. "
msgstr ""
"<a name=\"condition-designator\"></a> \n"
"<p>\n"
"Если вы сравнили вызовы <code>ERROR</code> в этом разделе с вызовами \n"
"в предыдущем разделе, вы, вероятно, задаетесь вопросом, как строка и \n"
"символ могут обозначать условие. Если вы передаете символ <code>ERROR</"
"code>, \n"
"он создает условие с помощью <code>MAKE-CONDITION</code> (аналогично \n"
"<code>MAKE-INSTANCE</code> для объектов CLOS); символ обозначает тип "
"условия, \n"
"а аргументы используются для инициализации условия. Если вы передаете "
"строку \n"
"формата в <code>ERROR</code>, то строка формата и ее аргументы становятся \n"
"параметрами инициализации для построения условия типа <code>SIMPLE-ERROR</"
"code>. "

#: in/chapter23.html:165
msgid ""
"<p>Of course, you can also pass an instantiated condition object to\n"
"<code>ERROR</code>:"
msgstr ""
"<p>Конечно, вы также можете передать экземпляр объекта условия(condition) "
"в \n"
"<code>ERROR</code>:"

#: in/chapter23.html:173
msgid ""
"<pre>\n"
"? (let ((my-condition (make-condition 'simple-error\n"
"                                    :format-control \"Can't do ~A.\"\n"
"                                    :format-arguments '(undefined-"
"operation))))\n"
"  (error my-condition))\n"
"Error: Can't do UNDEFINED-OPERATION.\n"
"</pre> "
msgstr ""

#: in/chapter23.html:178
msgid ""
"<blockquote>\n"
"Lisp systems designed according to <a href=\"chapter33.html#cltl2\">CLtL2</"
"a> \n"
"will use <code>:FORMAT-STRING</code> in place of <code>:FORMAT-CONTROL</"
"code>.\n"
"</blockquote> "
msgstr ""
"<blockquote>\n"
"Системы Lisp, разработанные в соответствии с <a href=\"chapter33."
"html#cltl2\">CLtL2</a>, \n"
"будут использовать <code>:FORMAT-STRING</code> вместо <code>:FORMAT-CONTROL</"
"code>.\n"
"</blockquote> "

#: in/chapter23.html:180
msgid "<h2>Recover from Conditions using Restarts</h2>"
msgstr ""
"<h2>Восстановление из условий(Conditions) с помощью перезагрузки(Restarts)</"
"h2>"

#: in/chapter23.html:183
msgid ""
"<p>In this final section, we'll see how to recover from errors. The\n"
"simplest forms involve the use of <code>CERROR</code> or <code>ASSERT</code>."
msgstr ""
"<p>\n"
"В этом заключительном разделе мы увидим, как восстанавливаться из ошибок. \n"
"Самые простые формы предполагают использование <code>CERROR</code> \n"
"или <code>ASSERT</code>."

#: in/chapter23.html:193
msgid ""
"<pre>\n"
"? (progn (cerror \"Go ahead, make my day.\"\n"
"                 \"Do you feel lucky?\")\n"
"         \"Just kidding\")\n"
"Error: Do you feel lucky?\n"
"Restart options:\n"
"  1: Go ahead, make my day.\n"
"  2. Top level\n"
"</pre> "
msgstr ""

#: in/chapter23.html:200
msgid ""
"<blockquote>\n"
"The \"Restart options\" list shown in this and the following examples\n"
"is typical, but not standard. Different Lisp systems will present\n"
"restart information in their own ways, and may add other built in \n"
"options.\n"
"</blockquote> "
msgstr ""
"<blockquote>\n"
"Список \"параметры перезапуска/Restart options\", показанный в этом и "
"следующих \n"
"примерах, является типичным, но не стандартным. Различные системы Lisp "
"будут \n"
"представлять информацию о перезапуске по-своему и могут добавлять другие \n"
"встроенные параметры.\n"
"</blockquote> "

#: in/chapter23.html:208
msgid ""
"<p><code>CERROR</code> has two required arguments. The first\n"
"argument is a format control string that you'll use to tell the\n"
"program's user what will happen upon <code>continuing</code> from\n"
"the error. The second argument is a condition designator (a format\n"
"control string, a symbol that names a condition, or a condition\n"
"object -- <a href=\"#condition-designator\">see above</a>) used to\n"
"tell the program's user about the error. "
msgstr ""
"<p>\n"
"<code>CERROR</code> имеет два обязательных аргумента. Первый аргумент - \n"
"это строка управления форматом, которую вы будете использовать, чтобы \n"
"сообщить пользователю программы, что произойдет при "
"продолжении(<code>continuing</code>) \n"
"работы с ошибкой. \n"
"Второй аргумент - это обозначение условия (строка управления форматом, "
"символ, \n"
"который именует условие или объект условия -- <a href=\"#condition-designator"
"\">см. выше</a>), \n"
"используемый для сообщения пользователю программы об ошибке."

#: in/chapter23.html:217
msgid ""
"<p>The rest of <code>CERROR</code>'s arguments, when present, are\n"
"used by the the format control strings <em>and</em> -- when the\n"
"second argument is a symbol that names a condition type -- as\n"
"keyword arguments to <code>MAKE-CONDITION</code> for that type.\n"
"In either case, you have to construct the format control strings\n"
"so that they address the proper arguments. The <code>FORMAT</code> \n"
"directive <code>~</code><i>n</i><code>*</code> can be used to skip\n"
"<i>n</i> arguments (<i>n</i> is 1 if omitted)."
msgstr ""
"<p>\n"
"Остальные аргументы <code>CERROR</code>, когда они присутствуют, \n"
"используются управляющими строками формата и - когда второй аргумент \n"
"является символом, который именует тип условия - в качестве аргумента \n"
"ключевого слова в <code>MAKE-CONDITION</code> для этого типа. В любом \n"
"случае вы должны построить управляющие строки формата так, чтобы они \n"
"обращались к соответствующим аргументам. Директива <code>FORMAT</code> \n"
"<code>~</code><i>n</i><code>*</code> может использоваться для пропуска \n"
"<i>n</i> аргументов (<i>n</i> равно 1, по умолчанию)."

#: in/chapter23.html:238
msgid ""
"<pre>\n"
"? (defun expect-type (object type default-value)\n"
"    (if (typep object type)\n"
"      object\n"
"      (progn\n"
"        (cerror \"Substitute the default value ~2*~S.\"\n"
"                \"~S is not of the expected type ~S.\"\n"
"                object type default-value)\n"
"        default-value)))\n"
"EXPECT-TYPE\n"
"? (expect-type \"Nifty\" 'string \"Bear\")\n"
"\"Nifty\"\n"
"? (expect-type 7 'string \"Bear\")\n"
"Error: 7 is not of the expected type STRING.\n"
"Restart options:\n"
"  1: Substitute the default value \"Bear\".\n"
"  2. Top level\n"
"  ? 1\n"
"\"Bear\"\n"
"</pre> "
msgstr ""

#: in/chapter23.html:255
msgid ""
"<p>Notice how the first format control string uses only the third\n"
"format argument: <code>DEFAULT-VALUE</code>. It skips the first two\n"
"format arguments with the <code>~2*</code> directive. You do similar\n"
"things if the arguments are keyword initializer arguments when you\n"
"provide a symbol as the second argument to <code>CERROR</code>; the\n"
"only difference is that you have to count the keywords\n"
"<code>and</code> the values when deciding how many arguments to\n"
"skip. Here's the previous example, written with a designator for a\n"
"condition of type <code>EXPECT-TYPE-ERROR</code> instead of a format\n"
"control string. Note how we skip five arguments to get to the\n"
"<code>DEFAULT-VALUE</code>. Note also the use of\n"
"<code>:ALLOW-OTHER-KEYS T</code>, which permits us to add the\n"
"<code>:IGNORE DEFAULT-VALUE</code> keyword argument which is not\n"
"expected as an initialization argument for the\n"
"<code>EXPECT-TYPE-ERROR</code> condition; without this, we'd get an\n"
"error for the unexpected keyword argument."
msgstr ""
"<p>\n"
"Обратите внимание, что первая строка управления format использует \n"
"только третий аргумент format: <code>DEFAULT-VALUE</code>. Он пропускает \n"
"первые два аргумента format с директивой <code>~2*</code>. Вы делаете то "
"же \n"
"самое, если аргументы являются инициализирующими аргументами ключевыми "
"словами, \n"
"когда вы предоставляете символ в качестве второго аргумента для "
"<code>CERROR</code>;\n"
"единственная разница заключается в том, что вам нужно подсчитать ключевые "
"слова \n"
"и значения, когда вы решаете, сколько аргументов пропустить. Вот предыдущий "
"пример,\n"
"написанный с обозначением для условия типа <code>EXPECT-TYPE-ERROR</code> "
"вместо \n"
"строки управления форматом. Обратите внимание, как мы пропускаем пять "
"аргументов, \n"
"чтобы получить <code>DEFAULT-VALUE</code>. Обратите также внимание на "
"использование \n"
"<code>:ALLOW-OTHER-KEYS T</code>, который позволяет нам добавить аргумент \n"
"ключевое слово <code>:IGNORE DEFAULT-VALUE</code>, который не ожидался в \n"
"качестве аргумента инициализации для условия <code>EXPECT-TYPE-ERROR</code>; "
"без \n"
"него мы получим ошибку для неожиданного аргумента ключевого слова."

#: in/chapter23.html:287
msgid ""
"<pre>\n"
"? (define-condition expect-type-error (error)\n"
"                    ((object :initarg :object :reader object)\n"
"                     (type :initarg :type :reader type))\n"
"    (:report (lambda (condition stream)\n"
"               (format stream \"~S is not of the expected type ~S.\"\n"
"                       (object condition)\n"
"                       (type condition)))))\n"
"EXPECT-TYPE-ERROR\n"
"? (defun expect-type (object type default-value)\n"
"    (if (typep object type)\n"
"      object\n"
"      (progn\n"
"        (cerror \"Substitute the default value ~5*~S.\"\n"
"                'expect-type-error\n"
"                :object object\n"
"                :type type\n"
"                :ignore default-value\n"
"                :allow-other-keys t)\n"
"        default-value)))\n"
"EXPECT-TYPE\n"
"? (expect-type \"Nifty\" 'string \"Bear\")\n"
"\"Nifty\"\n"
"? (expect-type 7 'string \"Bear\")\n"
"Error: 7 is not of the expected type STRING.\n"
"Restart options:\n"
"  1: Substitute the default value \"Bear\".\n"
"  2. Top level\n"
"  ? 1\n"
"\"Bear\"\n"
"</pre> "
msgstr ""

#: in/chapter23.html:289
msgid "<!-- assert --> "
msgstr ""

#: in/chapter23.html:291
msgid "<a name=\"assert\"></a> "
msgstr ""

#: in/chapter23.html:295
msgid ""
"<p><code>ASSERT</code> is ideal for those situations where your\n"
"program's state must pass some test -- an <em>assertion</em>.  In its\n"
"simplest form, <code>ASSERT</code> does only that."
msgstr ""
"<p>\n"
"<code>ASSERT</code> идеально подходит для тех ситуаций, когда \n"
"состояние вашей программы должно пройти некоторый тест -- \n"
"утверждение/<em>assertion</em>. В своей простейшей форме \n"
" <code>ASSERT</code> делает только это."

#: in/chapter23.html:307
msgid ""
"<pre>\n"
"? (defun my-divide (numerator denominator)\n"
"    (assert (not (zerop denominator)))\n"
"    (/ numerator denominator))\n"
"MY-DIVIDE\n"
"? (my-divide 3 0)\n"
"Error: Failed assertion (NOT (ZEROP DENOMINATOR))\n"
"Restart options:\n"
"  1. Retry the assertion\n"
"  2. Top level\n"
"</pre> "
msgstr ""

#: in/chapter23.html:315
msgid ""
"<p>This report is correct, but nor particularly useful; your program \n"
"would have signalled a <code>DIVISION-BY-ZERO</code> error without the\n"
"<code>ASSERT</code>.  What <em>would</em> be helpful is the ability\n"
"to correct the offending value -- the zero denominator, in this case --\n"
"and continue from the error.  <code>ASSERT</code>'s optional second "
"argument\n"
"lets you list places whose values you might want to change to correct\n"
"the problem."
msgstr ""
"<p>\n"
"Этот отчет верен,но не особенно полезен; ваша программа сигнализировала \n"
"бы об <code>DIVISION-BY-ZERO</code>(ошибке деления на ноль) и без \n"
"<code>ASSERT</code>.  Что <em>было бы</em> полезно, так это возможность \n"
"исправить  нарушающее значение -- в данном случае нулевой знаменатель - \n"
"и продолжить работу из error. Необязательный второй аргумент <code>ASSERT</"
"code>  \n"
"позволяет вам перечислить места, значения которых вы, возможно, захотите \n"
"изменить, чтобы исправить проблему."

#: in/chapter23.html:331
msgid ""
"<pre>\n"
"? (defun my-divide (numerator denominator)\n"
"    (assert (not (zerop denominator)) (numerator denominator))\n"
"    (/ numerator denominator))\n"
"MY-DIVIDE\n"
"? (my-divide 3 0)\n"
"Error: Failed assertion (NOT (ZEROP DENOMINATOR))\n"
"Restart options:\n"
"  1. Change the values of some places, then retry the assertion\n"
"  2. Top level\n"
"  ? 1\n"
"  Value for NUMERATOR: 3\n"
"  Value for DENOMINATOR 0.5\n"
"6.0\n"
"</pre> "
msgstr ""

#: in/chapter23.html:337
msgid ""
"<p>Of course, the choice of values to set is up to you.  I used both\n"
"<code>NUMERATOR</code> and <code>DENOMINATOR</code> in the example to\n"
"emphasize the fact that the list of places does not have to be just\n"
"the variables tested in the assertion.  (However, at least <code>one</"
"code> \n"
"of the places must affect the result of the assertion.)"
msgstr ""
"<p>\n"
"Конечно, выбор значений для установки зависит от вас. Я использовал как \n"
"<code>NUMERATOR</code>(числитель), так и <code>DENOMINATOR</"
"code>(знаменатель)\n"
"в этом примере, чтобы подчеркнуть тот факт, что список мест не обязательно \n"
"должен быть просто переменными, проверяемыми в утверждении. (Однако хотя "
"бы \n"
"<code>одно</code> из этих мест должно повлиять на результат утверждения.)"

#: in/chapter23.html:344
msgid ""
"<p>One last refinement to <code>ASSERT</code> lets you specify your own\n"
"message to use when an assertion fails. By default, <code>ASSERT</code> may\n"
"display the test form, but it is not required to do so.  By specifying\n"
"a condition designator and arguments following the list of places, you\n"
"can be assured that you know what message will be printed upon an \n"
"assertion failure."
msgstr ""
"<p>\n"
"Последнее уточнение для <code>ASSERT</code> позволяет указать собственное "
"сообщение,\n"
"которое будет использоваться в случае сбоя утверждения. По умолчанию "
"<code>ASSERT</code>\n"
"может отображать тестовую форму, но это не обязательно. Указав обозначитель "
"условия \n"
"и аргументы, следующие за списком мест, вы можете быть уверены, что знаете, "
"какое \n"
"сообщение будет напечатано при сбое утверждения"

#: in/chapter23.html:361
msgid ""
"<pre>\n"
"? (defun my-divide (numerator denominator)\n"
"    (assert (not (zerop denominator)) (numerator denominator)\n"
"            \"You can't divide ~D by ~D.\" numerator denominator)\n"
"    (/ numerator denominator))\n"
"MY-DIVIDE\n"
"? (my-divide 3 0)\n"
"Error: You can't divide 3 by 0.\n"
"Restart options:\n"
"  1. Change the values of some places, then retry the assertion\n"
"  2. Top level\n"
"  ? 1\n"
"  Value for NUMERATOR: 3\n"
"  Value for DENOMINATOR 2\n"
"3/2\n"
"</pre> "
msgstr ""

#: in/chapter23.html:363
msgid "<!-- handler-bind w/ signal to handle exceptions --> "
msgstr ""

#: in/chapter23.html:368
msgid ""
"<p>You can use <code>HANDLER-BIND</code> and <code>SIGNAL</code> to \n"
"process exceptions in your program.  Here's an extended example based\n"
"upon this chapter's earlier description of how a program might use\n"
"conditions to report on disk space availability."
msgstr ""
"<p>\n"
"Вы можете использовать <code>HANDLER-BIND</code> и <code>SIGNAL</code> \n"
"для обработки исключений в вашей программе. Вот расширенный пример, "
"основанный \n"
"на более раннем описании в этой главе того, как программа может "
"использовать \n"
"условия для получения отчета о доступности дискового пространства."

#: in/chapter23.html:411
msgid ""
"<pre>\n"
"? (define-condition high-disk-utilization ()\n"
"                    ((disk-name :initarg :disk-name :reader disk-name)\n"
"                     (current :initarg :current :reader current-"
"utilization)\n"
"                     (threshold :initarg :threshold :reader threshold))\n"
"    (:report (lambda (condition stream)\n"
"               (format stream \"Disk ~A is ~D% full; threshold is ~D%.\"\n"
"                       (disk-name condition)\n"
"                       (current-utilization condition)\n"
"                       (threshold condition)))))\n"
"HIGH-DISK-UTILIZATION\n"
"? (defun get-disk-utilization (disk-name)\n"
"    <i>;; for this example, we'll just return a fixed value</i> \n"
"    93)\n"
"GET-DISK-UTILIZATION\n"
"? (defun check-disk-utilization (name threshold)\n"
"    (let ((utilization (disk-utilization name)))\n"
"      (when (&gt;= utilization threshold)\n"
"        (signal 'high-disk-utilization\n"
"                :disk-name name\n"
"                :current utilization\n"
"                :threshold threshold))))\n"
"CHECK-DISK-UTILIZATION\n"
"? (defun log-to-disk (record name)\n"
"    (handler-bind ((high-disk-utilization \n"
"                    #'(lambda (c)\n"
"                        (when (y-or-n-p \"~&amp;~A Panic?\" c)\n"
"                          (return-from log-to-disk nil)))))\n"
"      (check-disk-utilization name 90)\n"
"      (print record))\n"
"    t)\n"
"LOG-TO-DISK\n"
"? (log-to-disk \"Hello\" 'disk1)\n"
"Disk DISK1 is 93% full; threshold is 90%. Panic? (y or n)  <b>n</b> \n"
"\"Hello\" \n"
"T\n"
"? (log-to-disk \"Goodbye\" 'disk1)\n"
"Disk DISK1 is 93% full; threshold is 90%. Panic? (y or n)  <b>y</b> \n"
"NIL\n"
"? (check-disk-utilization 'disk1 90)\n"
"NIL\n"
"</pre> "
msgstr ""

#: in/chapter23.html:413
msgid "<!-- handled/unhandled error/signal --> "
msgstr ""

#: in/chapter23.html:421
msgid ""
"<p>Notice that the condition signalled by\n"
"<code>CHECK-DISK-UTILIZATION</code> has an effect only when a\n"
"handler is established for the <code>HIGH-DISK-UTILIZATION</code>\n"
"condition. Because of this, you can write exception signalling code\n"
"without foreknowledge that the client will provide a handler. This\n"
"is most useful when the exception provides information about the\n"
"running program, but is not an error if left unhandled."
msgstr ""
"<p>\n"
"Обратите внимание, что условие сигнализации <code>CHECK-DISK-UTILIZATION</"
"code>\n"
"действует только тогда, когда обработчик устанавливается для условия\n"
"<code>HIGH-DISK-UTILIZATION</code>. Из-за этого вы можете написать код \n"
"сигнализации исключения, не зная заранее, что клиент предоставит "
"обработчик. \n"
"Это наиболее полезно, когда исключение предоставляет информацию о "
"запущенной \n"
"программе, но не является ошибкой, если его оставить без обработки."

#: in/chapter23.html:423
msgid "<!-- cerror w/ restart-bind to add restarts --> "
msgstr ""

#: in/chapter23.html:428
msgid ""
"<p>In the next example, we'll extend the restart options available \n"
"to <code>CERROR</code>.  <code>RESTART-BIND</code> defines, for each\n"
"new restart, the message to be printed by the restart user interface\n"
"and a function to be executed when the user chooses the restart."
msgstr ""
"<p>\n"
"В следующем примере мы расширим параметры перезапуска, доступные для \n"
"<code>CERROR</code>. <code>RESTART-BIND</code> определяет для каждого \n"
"нового перезапуска, сообщение, которое будет распечатано пользовательским \n"
"интерфейсом перезапуска, и функцию, которая будет выполняться, когда \n"
"пользователь выберет перезапуск."

#: in/chapter23.html:525
msgid ""
"<pre>\n"
"? (define-condition device-unresponsive ()\n"
"                    ((device :initarg :device :reader device))\n"
"    (:report (lambda (condition stream)\n"
"               (format stream \"Device ~A is unresponsive.\"\n"
"                       (device condition)))))\n"
"DEVICE-UNRESPONSIVE\n"
"? (defun send-query (device query)\n"
"    (format t \"~&amp;Sending ~S ~S~%\" device query))\n"
"SEND-QUERY\n"
"? (defun accept-response (device)\n"
"    <i>;; For the example, the device always fails.</i> \n"
"    nil)\n"
"ACCEPT-RESPONSE\n"
"? (defun reset-device (device)\n"
"    (format t \"~&amp;Resetting ~S~%\" device))\n"
"RESET-DEVICE\n"
"? (defun query-device (device)\n"
"    (restart-bind ((nil #'(lambda () (reset-device device))\n"
"                        :report-function\n"
"                        #'(lambda (stream)\n"
"                            (format stream \"Reset device.\")))\n"
"                   (nil #'(lambda ()\n"
"                            (format t \"~&amp;New device: \")\n"
"                            (finish-output)\n"
"                            (setq device (read)))\n"
"                        :report-function\n"
"                        #'(lambda (stream)\n"
"                            (format stream \"Try a different device.\")))\n"
"                   (nil #'(lambda ()\n"
"                            (return-from query-device :gave-up))\n"
"                        :report-function\n"
"                        #'(lambda (stream)\n"
"                            (format stream \"Give up.\"))))\n"
"      (loop\n"
"        (send-query device 'query)\n"
"        (let ((answer (accept-response device)))\n"
"          (if answer\n"
"            (return answer)\n"
"            (cerror \"Try again.\"\n"
"                    'device-unresponsive :device device))))))\n"
"QUERY-DEVICE\n"
"? (query-device 'foo)\n"
"Sending FOO QUERY\n"
"Error: Device FOO is unresponsive.\n"
"Restart options:\n"
"  1. Try again.\n"
"  2. Reset device.\n"
"  3. Try a different device.\n"
"  4. Give up.\n"
"  5. Top level\n"
"  ? 1\n"
"Sending FOO QUERY\n"
"Error: Device FOO is unresponsive.\n"
"Restart options:\n"
"  1. Try again.\n"
"  2. Reset device.\n"
"  3. Try a different device.\n"
"  4. Give up.\n"
"  5. Top level\n"
"  ? 2\n"
"Resetting FOO\n"
"Restart options:\n"
"  1. Try again.\n"
"  2. Reset device.\n"
"  3. Try a different device.\n"
"  4. Give up.\n"
"  5. Top level\n"
"  ? 1\n"
"Sending FOO QUERY\n"
"Error: Device FOO is unresponsive.\n"
"Restart options:\n"
"  1. Try again.\n"
"  2. Reset device.\n"
"  3. Try a different device.\n"
"  4. Give up.\n"
"  5. Top level\n"
"  ? 3\n"
"New device: <b>bar</b> \n"
"Restart options:\n"
"  1. Try again.\n"
"  2. Reset device.\n"
"  3. Try a different device.\n"
"  4. Give up.\n"
"  5. Top level\n"
"  ? 1\n"
"Error: Device BAR is unresponsive.\n"
"Restart options:\n"
"  1. Try again.\n"
"  2. Reset device.\n"
"  3. Try a different device.\n"
"  4. Give up.\n"
"  5. Top level\n"
"  ? 4\n"
":GAVE-UP\n"
"</pre> "
msgstr ""

#: in/chapter23.html:536
msgid ""
"<p>The \"Try again\" restart is established by the <code>CERROR</code>\n"
"form; selecting this restart lets the program continue from the\n"
"<code>CERROR</code> form. The \"Reset device\", \"Try a different\n"
"device\", and \"Give up\" restarts are created within the\n"
"<code>RESTART-BIND</code> form; choosing one of these executes the\n"
"associated function. Of the restarts defined within the\n"
"<code>RESTART-BIND</code>, only the \"Give up\" restart transfers\n"
"control out of the <code>CERROR</code> form -- the others return\n"
"control to <code>CERROR</code> to again display the menu of restart\n"
"choices."
msgstr ""
"<p>\n"
"Перезапуск \"Try again\"(попробовать снова) устанавливается формой\n"
"<code>CERROR</code>; выбор этого перезапуска позволяет программе "
"продолжить \n"
"работу из формы <code>CERROR</code>. Перезапуски \"Reset device\", \n"
"\"Try a different device\" и \"Give up\" создаются в форме <code>RESTART-"
"BIND</code>; \n"
"выбор одного из них выполняет соответствующую функцию. Из перезапусков, \n"
"определенных в <code>RESTART-BIND</code>, только перезапуск \"Give up/"
"отказаться\" \n"
"передает управление из формы <code>CERROR</code> - остальные возвращают "
"управление\n"
"в <code>CERROR</code>, чтобы снова отобразить меню выбора перезапуска."

#: in/chapter23.html:538
msgid "<!-- recovery strategies --> "
msgstr ""

#: in/chapter23.html:542
msgid ""
"<p>Now you've seen the basics of condition handlers and restarts.\n"
"Lisp has additional built-in abstractions that extend these concepts.\n"
"If you're interested, you should consult a Common Lisp reference."
msgstr ""
"<p>\n"
"Теперь вы познакомились с основами обработчиков состояний и перезапусков. \n"
"Lisp имеет дополнительные встроенные абстракции, которые расширяют эти "
"понятия. \n"
"Если вы заинтересовались, вам следует проконсультироваться с общим "
"справочником Lisp."

#: in/chapter23.html:553
msgid ""
"<p>There's one last thing you should know about handling conditions.\n"
"As we saw earlier, <code>ERROR</code> causes your program to stop in\n"
"the Lisp debugger. You can't continue past the call to\n"
"<code>ERROR</code>, but most Lisp systems will let you back up,\n"
"correct the problem that caused the error, and rerun that portion of\n"
"the program. If you do the right thing, your program won't call\n"
"<code>ERROR</code> again. This is an amazingly powerful tool to use\n"
"during program development. But you don't want to expose your users\n"
"to that kind of experience -- they won't be as impressed by the Lisp\n"
"debugger as you are."
msgstr ""
"<p>\n"
"Есть еще одна вещь, которую вы должны знать о обработке условий. \n"
"Как мы видели ранее, <code>ERROR</code> приводит к остановке вашей \n"
"программы в отладчике Lisp. Вы не можете продолжить работу после \n"
"вызова <code>ERROR</code>, но большинство систем Lisp позволят вам \n"
"выполнить резервное копирование, исправить проблему, вызвавшую ошибку, \n"
"и повторно запустить эту часть программы. Если вы сделаете все правильно, \n"
"ваша программа больше не будет вызывать <code>ERROR</code>. Это "
"удивительно \n"
"мощный инструмент для использования при разработке программ. Но вы не \n"
"хотите подвергать своих пользователей такому опыту - они не будут \n"
"так впечатлены отладчиком Lisp, как вы."

#: in/chapter23.html:556
msgid ""
"<p>To protect your users from the debugger, you can wrap portions of\n"
"your program in an <code>IGNORE-ERRORS</code> form."
msgstr ""
"<p>Чтобы защитить пользователей от отладчика,можно обернуть части \n"
"программы в форму <code>IGNORE-ERRORS</code>."

#: in/chapter23.html:567
msgid ""
"<pre>\n"
"? (ignore-errors \n"
"   (error \"Something bad has happened.\")\n"
"   (print \"Didn't get here.\"))\n"
"NIL\n"
"#&lt;SIMPLE-ERROR #x42B26B6&gt;\n"
"? (ignore-errors\n"
"   (* 7 9))\n"
"63\n"
"</pre> "
msgstr ""

#: in/chapter23.html:571
msgid ""
"<p>If an error occurs within an <code>IGNORE-ERRORS</code> form, program\n"
"execution ends at that point, and <code>IGNORE-ERRORS</code> returns two\n"
"values: <code>NIL</code> and the condition signalled by <code>ERROR</code>."
msgstr ""
"<p>\n"
"Если ошибка возникает в пределах формы <code>IGNORE-ERRORS</code>, "
"выполнение \n"
"программы заканчивается в этой точке, и <code>IGNORE-ERRORS</code> "
"возвращает \n"
"два значения: <code>NIL</code> и условие, сигнализируемое <code>ERROR</"
"code>.\n"
" <code>ERROR</code>."

#: in/chapter23.html:577
msgid ""
"<p>You should use <code>IGNORE-ERRORS</code> judiciously. Use it only to\n"
"wrap forms for which you can't otherwise provide handlers.  Note, too, that\n"
"the values returned by <code>IGNORE-ERRORS</code> are not very informative.\n"
"But you can decode the second return value to print the actual error\n"
"message."
msgstr ""
"<p>\n"
"Вы должны использовать <code>IGNORE-ERRORS</code> рассудительно. "
"Используйте \n"
"его только для обертывания форм,для которых вы не можете иначе "
"предоставить \n"
"обработчики. Обратите также внимание, что значения, возвращаемые с помощью \n"
"<code>IGNORE-ERRORS</code>, не очень информативны. Но вы можете "
"декодировать \n"
"второе возвращаемое значение, чтобы напечатать фактическое сообщение об "
"ошибке."

#: in/chapter23.html:611
msgid ""
"<pre>\n"
"? (defmacro report-error (&amp;body body)\n"
"    (let ((results (gensym))\n"
"          (condition (gensym)))\n"
"      `(let ((,results (multiple-value-list\n"
"                        (ignore-errors \n"
"                         ,@body))))\n"
"         (if (and (null (first ,results))\n"
"                  (typep (second ,results) 'condition)\n"
"                  (null (nthcdr 2 ,results)))\n"
"           (let ((,condition (second ,results)))\n"
"             (typecase ,condition\n"
"               (simple-condition\n"
"                (apply #'format t \n"
"                       (simple-condition-format-control ,condition) \n"
"                       (simple-condition-format-arguments ,condition)))\n"
"               (otherwise\n"
"                (format t \"~A error.\" (type-of ,condition))))\n"
"             (values))\n"
"           (values-list ,results)))))\n"
"REPORT-ERROR\n"
"? (report-error (error \"I feel like I'm losing my mind, Dave.\"))\n"
"I feel like I'm losing my mind, Dave.\n"
"? (report-error (+ 1 no-variable-by-this-name))\n"
"UNBOUND-VARIABLE error.\n"
"? (report-error (* 7 'f))\n"
"TYPE-ERROR error.\n"
"? (report-error (let ((n 1)) (/ 8 (decf n))))\n"
"DIVISION-BY-ZERO error.\n"
"? (report-error (* 2 pi)) <i>; not an error</i> \n"
"6.283185307179586\n"
"? (report-error (values 1 2 3 4)) <i>; not an error</i> \n"
"</pre> "
msgstr ""

#: in/chapter23.html:624
msgid ""
"<hr>\n"
"<div align=\"center\">\n"
"<a href=\"contents.html\">Contents</a> | <a href=\"cover.html\">Cover</a> "
"<br> \n"
"<a href=\"chapter22.html\">Chapter 22</a> | Chapter 23 | <a href=\"chapter24."
"html\">Chapter 24</a> \n"
"</div>\n"
"<hr>\n"
"<address>\n"
"Copyright &copy; 1995-2001, David B. Lamkins<br>\n"
"All Rights Reserved Worldwide<br>\n"
"<br>\n"
"This book may not be reproduced without the written consent of its author.  "
"Online distribution is restricted to the author's site.\n"
"</address> \n"
"</body> </html> "
msgstr ""
