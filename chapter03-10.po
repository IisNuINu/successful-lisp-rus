#
# NuINu <don't@send.my>, 2020.
#
#. extracted from in/chapter03-10.html
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-04-19 13:50+0300\n"
"PO-Revision-Date: 2020-05-22 12:28+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter03-10.html:5
msgid ""
"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/"
"html4/strict.dtd\">\n"
"<html><head>\n"
"<title>Successful Lisp - Chapter 3, Lesson 10</title> \n"
"</head> "
msgstr ""

#: in/chapter03-10.html:8
msgid ""
"<body bgcolor=\"white\" text=\"black\">\n"
"<h1>Chapter 3 - Essential Lisp in Twelve Lessons</h1> "
msgstr ""
"<body bgcolor=\"white\" text=\"black\">\n"
"<h1>Глава 3 - Основы Лисп в 12 уроках</h1> "

#: in/chapter03-10.html:10
msgid ""
"<h2><A NAME=\"lesson-10\">Lesson 10 - A Preview of Other Data Types</A></h2> "
msgstr ""
"<h2><A NAME=\"lesson-10\">Урок 10 - Обзор других типов данных</A></h2> "

#: in/chapter03-10.html:12
msgid "<h3>Lisp almost always does the right thing with numbers</h3> "
msgstr "<h3>Лисп почти всегда правильно работает с числами</h3> "

#: in/chapter03-10.html:15
msgid ""
"<P>This sounds like a strange thing to say.  Don't computers always do the \n"
"right thing with numbers?  Well, no...  Not usually.</P>"
msgstr ""
"<P>Это звучит странно, если это сказать. Разве компьютеры не всегда "
"правильно обращаются с цифрами? Оказывается нет... Как правило, нет..</P>"

#: in/chapter03-10.html:22
msgid ""
"<P>Numeric calculations can break in lots of different ways.  One of the \n"
"biggest trouble spots is in calculations with floating point numbers (your \n"
"language may call them <I>real</I> numbers, but that's a lie).  There are \n"
"probably half as many books written on proper use of floating point \n"
"calculations as there are on visual- or object-oriented-anything -- and \n"
"that's a lot.</P>"
msgstr ""
"<P>Числовые вычисления могут искажаться множеством различных способов. \n"
"Одна из самых больших проблем заключается в вычислениях с числами с \n"
"плавающей запятой (ваш язык может называть их  <I>real</I> реальными "
"числами, но это ложь).\n"
"Существует, вероятно, вдвое меньше книг, написанных о правильном "
"использовании\n"
"вычислений с плавающей запятой, чем о визуальном-или чём-то объектно-"
"ориентированном, и это очень много.</P>"

#: in/chapter03-10.html:31
msgid ""
"<P>The problem with floating point numbers is that they're not \n"
"mathematically accurate real numbers, but are often (mis)used as if they \n"
"are.  The main problem is that floating point numbers have a limited \n"
"accuracy -- only so many digits to the right of the decimal point.  Now, "
"if \n"
"all of the numbers in a calculation are of approximately the same \n"
"magnitude, then the calculation won't lose \n"
"accuracy.  But if the numbers are of very different magnitude, then a \n"
"floating point calculation sacrifices accuracy.</P>"
msgstr ""
"<P>Проблема с числами с плавающей запятой заключается в том, что они не\n"
"являются математически точными вещественными числами, но часто\n"
"(и неправильно) используются так, как будто они есть. Основная проблема\n"
"заключается в том, что числа с плавающей запятой имеют ограниченную "
"точность-\n"
"только несколько цифр справа от десятичной точки. Теперь, если все числа в\n"
"вычислении имеют приблизительно одинаковую величину, то вычисление не "
"потеряет\n"
"точности. Но если эти числа имеют сильную разницу по величине, то вычисление "
"с\n"
"плавающей точкой приносит в жертву точность.</P>"

#: in/chapter03-10.html:39
msgid ""
"<BLOCKQUOTE>\n"
"Suppose that a floating point number on your computer can accurately "
"represent \n"
"7 decimal digits.  Then you can add 1897482.0 to 2973225.0 and get a "
"completely \n"
"accurate answer.  But if you try to add 1897482.0 to 0.2973225, the \n"
"accurate answer has fourteen digits, while your computer will answer with \n"
"1897482.0.\n"
"</BLOCKQUOTE>"
msgstr ""
"<BLOCKQUOTE>\n"
"Предположим, что число с плавающей запятой на вашем компьютере имеет "
"точность\n"
"представления 7 десятичных цифр. Затем вы можете добавить 1897482.0 к "
"2973225.0\n"
"и получить совершенно точный ответ. Но если вы попытаетесь добавить "
"1897482.0 к 0.2973225, точный ответ будет состоять из четырнадцати цифр, в "
"то время как ваш компьютер ответит: 1897482.0.\n"
"</BLOCKQUOTE>"

#: in/chapter03-10.html:47
msgid ""
"<P>The other problem with floating point numbers is more subtle.  When you \n"
"write a program, you write numbers in base 10.  But the computer does all \n"
"arithmetic in base 2.  The conversion from base 10 to base 2 does funny \n"
"things to certain \"obviously exact\" numbers.  For example, the decimal \n"
"number 0.1 is a repeating fraction when translated into binary.  Because \n"
"the computer can't store the infinite number of digits required by a \n"
"repeating fraction, it can't store the number 0.1 accurately.</P>"
msgstr ""
"<P>Другая проблема с числами с плавающей запятой является более тонкой. \n"
"Когда вы пишете программу, вы пишете числа в базе 10. Но компьютер делает\n"
"всю арифметику в базе 2. Преобразование из базы 10 в базу 2 делает\n"
"забавные вещи с определенными \"очевидно точными\" числами. Например, \n"
"десятичное число 0.1 является повторяющейся дробью при переводе в \n"
"двоичный код. Поскольку компьютер не может хранить бесконечное \n"
"число цифр, требуемое повторяющейся дробью, он не может хранить \n"
"число 0.1 точно.</P>"

#: in/chapter03-10.html:53
msgid ""
"<P>Integer (whole number) arithmetic poses another problem in most \n"
"computer languages -- they tend to impose a limit on the maximum positive \n"
"or negative value that an integer can hold.  So, if you try to add the \n"
"number one to the largest integer your language lets the computer handle, \n"
"one of two things will happen:</P>"
msgstr ""
"<P>Целочисленная арифметика (целые числа) создает еще одну проблему в\n"
"большинстве компьютерных языков - они имеют тенденцию накладывать \n"
"ограничение на максимальное положительное или отрицательное значение,\n"
"которое может содержать целое число. Итак, если вы попытаетесь добавить \n"
"число один к самому большому целому числу, которое ваш язык позволяет\n"
"обрабатывать компьютеру, произойдет одно из двух:\n"
"</P>"

#: in/chapter03-10.html:60
msgid ""
"<OL>\n"
"<LI>your program will terminate with an error, or</LI>\n"
"<LI>you'll get a wildly incorrect answer (the largest \n"
"positive number plus one yields the largest negative integer in at least \n"
"one computer language).</LI>\n"
"</OL>"
msgstr ""
"<OL>\n"
"<LI>ваша программа завершится с ошибкой, или</LI>\n"
"<LI>вы получите совершенно неверный ответ (Самое большое положительное \n"
"число плюс один дает самое большое отрицательное целое число по крайней \n"
"мере в одном компьютерном языке).</LI>\n"
"</OL>"

#: in/chapter03-10.html:65
msgid ""
"<P>So how does Lisp manage to do the right thing with numbers?  After all, \n"
"it seems like these problems are inherent in computer arithmetic.  The \n"
"answer is that Lisp doesn't do use just the built-in computer arithmetic \n"
"operations -- it adds certain mathematically accurate numeric data types:</P>"
msgstr ""
"<P>Так как же Лиспу удается делать правильные вещи с числами? \n"
"В конце концов, похоже, что эти проблемы присущи всей компьютерной "
"арифметике.\n"
"Ответ заключается в том, что Lisp не использует только встроенные в \n"
"компьютер арифметические операции - он добавляет определенные \n"
"математически точные числовые типы данных:</P>"

#: in/chapter03-10.html:73
msgid ""
"<UL>\n"
"<LI><EM>bignums</EM> are integers with an unlimited number of digits \n"
"(subject only to limitations of computer memory)</LI>\n"
"<LI><EM>rational numbers</EM> are the exact quotient of two integers, not "
"a \n"
"floating point number resulting from an approximate machine division \n"
"algorithm</LI>\n"
"</UL>"
msgstr ""
"<UL>\n"
"<LI><EM>bignums</EM> это целые числа с неограниченным количеством цифр \n"
"(при условии ограничения только памяти компьютера)</LI>\n"
"<LI><EM>rational numbers</EM>(рациональные числа) - это точное частное от \n"
"двух целых чисел, а не число с плавающей запятой, полученное в результате\n"
"приближенного алгоритма машинного деления</LI>\n"
"</UL>"

#: in/chapter03-10.html:79
msgid ""
"<P>Of course, Lisp also has machine-based integers and floating point \n"
"numbers.  Machine integers are called <EM>fixnums</EM> in Lisp.  So long \n"
"as a whole number falls within the numeric range of a fixnum, Lisp will "
"store \n"
"it as a machine integer.  But if it gets too big, Lisp automatically \n"
"promotes it to a bignum.</P>"
msgstr ""
"<P>\n"
"Конечно, Лисп также имеет машинные целые числа и числа с плавающей запятой.\n"
"Машинные целые числа в Lisp называются <EM>fixnums</EM>(фиксированными)\n"
"числами. До тех пор, пока целое число попадает в числовой диапазон fixnum, \n"
"Lisp будет хранить его как машинное целое число. Но если он становится \n"
"слишком большим, Lisp автоматически переводит его в bignum.\n"
"</P>"

#: in/chapter03-10.html:83
msgid ""
"<P>When I said that Lisp almost always does the right thing with numbers, "
"I \n"
"meant that it <EM>almost always</EM> chooses the numeric representation \n"
"that is mathematically correct:</P>"
msgstr ""
"<P>\n"
"Когда я сказал, что Lisp почти всегда делает правильные вещи с числами, \n"
"я имел в виду, что он <EM>почти всегда</EM> выбирает числовое "
"представление, \n"
"которое является математически правильным:\n"
"</P>"

#: in/chapter03-10.html:85
msgid ""
"<pre width=80><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> "
"(/ 1 3)<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> "
"1/3<br><br><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> (+ "
"(/ 7 11) (/ 13 31))<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-&gt;\" ALIGN="
"\"BOTTOM\"> 360/341<br><br><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN="
"\"BOTTOM\"> (defun factorial (n)<br>     (cond ((= n 0) 1)<br>           (t "
"(* n (factorial (- n 1))))))<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-&gt;"
"\" ALIGN=\"BOTTOM\"> FACTORIAL<br><br><IMG SRC=\"gifs/circle-dot.gif\" ALT="
"\"?\" ALIGN=\"BOTTOM\"> (factorial 100)<br><IMG SRC=\"gifs/right-arrow.gif\" "
"ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> "
"933262154439441526816992388562667004907159682643816214685<br>   "
"929638952175999932299156089414639761565182862536979208272<br>   "
"23758251185210916864000000000000000000000000</pre>"
msgstr ""

#: in/chapter03-10.html:91
msgid ""
"<P>You can write calculations to use floating point numbers, but Lisp "
"won't \n"
"automatically turn an exact numeric result into an inexact floating \n"
"point number -- you have to ask for it.  Floating point numbers are \n"
"<EM>contagious</EM> -- once you introduce one into a calculation, the \n"
"result of the entire calculation stays a floating point number:</P>"
msgstr ""
"<P>\n"
"Вы можете написать вычисления, чтобы использовать числа с плавающей "
"запятой,\n"
"но Lisp не будет автоматически превращать точный числовой результат в \n"
"неточное число с плавающей запятой - вы должны попросить его. Числа \n"
"с плавающей запятой <EM>contagious/заразны</EM> - как только вы вводите \n"
"их в расчет, результат всего расчета остается числом с плавающей запятой:\n"
"</P>"

#: in/chapter03-10.html:93
msgid ""
"<pre width=80><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> "
"(float (/ 1 3))<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-&gt;\" ALIGN="
"\"BOTTOM\"> 0.3333333333333333<br><br><IMG SRC=\"gifs/circle-dot.gif\" ALT="
"\"?\" ALIGN=\"BOTTOM\"> (* (float (/ 1 10)) (float (/ 1 10)))<br><IMG SRC="
"\"gifs/right-arrow.gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> "
"0.010000000000000002<br><br><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN="
"\"BOTTOM\"> (+ 1/100 (* (float (/ 1 10)) (float (/ 1 10))))<br><IMG SRC="
"\"gifs/right-arrow.gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> "
"0.020000000000000004<br><br><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN="
"\"BOTTOM\"> (+ 1/100 1/100) <EM>; compare to previous calculation</"
"EM><br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> "
"1/50<br><br><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> (* "
"3 7 10.0)<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM"
"\"> 210.0<br><br><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM"
"\"> (- 1.0 1)<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-&gt;\" ALIGN="
"\"BOTTOM\"> 0.0<br><br><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN="
"\"BOTTOM\"> (+ 1/3 2/3 0.0)<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-&gt;"
"\" ALIGN=\"BOTTOM\"> 1.0<br><br><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" "
"ALIGN=\"BOTTOM\"> (+ 1/3 2/3)<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-"
"&gt;\" ALIGN=\"BOTTOM\"> 1 <EM>; compare to previous calculation</EM></pre>"
msgstr ""

#: in/chapter03-10.html:96
msgid ""
"<P>Lisp prints floating point numbers with a decimal point, and integers \n"
"without.</P>"
msgstr ""
"<P>Lisp печатает числа с плавающей запятой с десятичной запятой, а \n"
"целые числа без нее</P>"

#: in/chapter03-10.html:98
msgid ""
"<h3><A NAME=\"characters\">Characters give Lisp something to read and write</"
"A></h3> "
msgstr ""
"<h3><A NAME=\"characters\">(Characters)Символьные знаки позволяют \n"
"Лиспу что либо читать и писать</A></h3> "

#: in/chapter03-10.html:103
msgid ""
"<P>Basic Lisp I/O uses characters.  The <CODE>READ</CODE> and \n"
"<CODE>WRITE</CODE> functions turn characters into Lisp objects and vice \n"
"versa.  <CODE>READ-CHAR</CODE> and <CODE>WRITE-CHAR</CODE> read and write \n"
"single characters.</P>"
msgstr ""
"<P>\n"
"Базовый ввод/вывод Лиспа использует символьные знаки. Функции чтения \n"
"и записи превращают знаки в объекты Lisp и наоборот. <CODE>READ-CHAR</CODE>\n"
"и <CODE>WRITE-CHAR</CODE> читают и записывают одиночные знаки.\n"
"</P>"

#: in/chapter03-10.html:105
msgid ""
"<pre width=80><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> "
"(read)<br><IMG SRC=\"gifs/dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> a<IMG SRC="
"\"gifs/return.gif\" ALT=\"CR\" ALIGN=\"BOTTOM\"><br><IMG SRC=\"gifs/right-"
"arrow.gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> A<br><br><IMG SRC=\"gifs/circle-"
"dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> (read)<br><IMG SRC=\"gifs/dot.gif\" "
"ALT=\"??\" ALIGN=\"BOTTOM\"> #\\a<IMG SRC=\"gifs/return.gif\" ALT=\"CR\" "
"ALIGN=\"BOTTOM\"><br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-&gt;\" ALIGN="
"\"BOTTOM\"> a<br><br><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN="
"\"BOTTOM\"> (read-char)<br><IMG SRC=\"gifs/dot.gif\" ALT=\"??\" ALIGN="
"\"BOTTOM\"> a<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-&gt;\" ALIGN="
"\"BOTTOM\"> #\\a<br><br><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN="
"\"BOTTOM\"> (write 'a)<br><IMG SRC=\"gifs/double-right-arrow.gif\" ALT=\"-"
"&gt;\" ALIGN=\"BOTTOM\"> A<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"=&gt;"
"\" ALIGN=\"BOTTOM\"> A<br><br><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" "
"ALIGN=\"BOTTOM\"> (write #\\a)<br><IMG SRC=\"gifs/double-right-arrow.gif\" "
"ALT=\"=&gt;\" ALIGN=\"BOTTOM\"> #\\a<br><IMG SRC=\"gifs/right-arrow.gif\" "
"ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> #\\a<br><br><IMG SRC=\"gifs/circle-dot.gif\" "
"ALT=\"?\" ALIGN=\"BOTTOM\"> (write-char #\\a)<br><IMG SRC=\"gifs/double-"
"right-arrow.gif\" ALT=\"=&gt;\" ALIGN=\"BOTTOM\"> a<br><IMG SRC=\"gifs/right-"
"arrow.gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> #\\a<br><br><IMG SRC=\"gifs/"
"circle-dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> (write-char 'a)<br><IMG SRC="
"\"gifs/right-arrow-bar.gif\" ALT=\"-&gt;|\" ALIGN=\"BOTTOM\"> Error: Not a "
"character</pre>"
msgstr ""

#: in/chapter03-10.html:114
msgid ""
"<P>We've introduced some new notation in the above examples.  The <IMG \n"
"SRC=\"gifs/dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> symbol means that Lisp "
"expects \n"
"input in response to an input function such as <CODE>READ</CODE>.  This is \n"
"different from <IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM"
"\">, \n"
"which accepts input to be evaluated and printed.  The <IMG \n"
"SRC=\"gifs/return.gif\" ALT=\"CR\" ALIGN=\"BOTTOM\"> symbol indicates a\n"
"newline character, generated by the <KBD>return</KBD> or \n"
"<KBD>enter</KBD> key.</P>"
msgstr ""
"<P>\n"
"Мы ввели некоторые новые обозначения в вышеприведенных примерах. Какие? \n"
"Знак <IMG SRC=\"gifs/dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> означает, что "
"Lisp\n"
"ожидает ввода в ответ на функцию ввода, такую как <CODE>READ</CODE>. \n"
"Он немного отличается от \n"
"<IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\">, который "
"принимает\n"
"входные данные для вычисления и печати. Знак\n"
"<IMG SRC=\"gifs/return.gif\" ALT=\"CR\" ALIGN=\"BOTTOM\"> указывает на "
"знак \n"
"новой строки, генерируемый клавишей <KBD>return</KBD> или <KBD>enter</KBD>.\n"
"</P>"

#: in/chapter03-10.html:117
msgid ""
"<P>The <IMG SRC=\"gifs/double-right-arrow.gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM"
"\"> \n"
"indicates output that is printed rather than returned as a value.</P>"
msgstr ""
"<P>\n"
"Знак <IMG SRC=\"gifs/double-right-arrow.gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM"
"\">\n"
"указывает на вывод, который печатается, а не возвращается в виде значения.\n"
"</P>"

#: in/chapter03-10.html:125
msgid ""
"<P>You should notice that newline terminates <CODE>READ</CODE> input.  "
"This \n"
"is because <CODE>READ</CODE> collects characters trying to form a complete \n"
"Lisp expression.  We'll see more of this in <A \n"
"HREF=\"chapter03-11.html\">Lesson 11</A>.  In the example, <CODE>READ</"
"CODE> \n"
"collects a symbol, which is terminated by the newline.  The symbol could \n"
"also have been terminated by a space, a parenthesis, or any other "
"character \n"
"that can't be part of a symbol.</P>"
msgstr ""
"<P>\n"
"Вы должны заметить, что новая строка завершает ввод данных для \n"
"<CODE>READ</CODE>. Это происходит потому, что <CODE>READ</CODE> \n"
"собирает символьные знаки, пытаясь сформировать полное выражение Lisp.\n"
"Подробнее об этом мы поговорим в <A HREF=\"chapter03-11.html\">Уроке 11</"
"A>. \n"
"В этом примере <CODE>READ</CODE> собирает символ, который заканчивается \n"
"знаком новой строки. Символ также может заканчиваться пробелом, скобкой \n"
"или любым другим знаком, который не может быть частью символа.\n"
"</P>"

#: in/chapter03-10.html:129
msgid ""
"<P>In contrast, <CODE>READ-CHAR</CODE> reads exactly one character from "
"the \n"
"input.  As soon as that character is consumed, <CODE>READ-CHAR</CODE> \n"
"completes executing and returns the character.</P>"
msgstr ""
"<P>\n"
"Напротив, <CODE>READ-CHAR</CODE> считывает ровно один знак из входных "
"данных.\n"
"Как только этот знак получен, <CODE>READ-CHAR</CODE> завершает выполнение и "
"возвращает символьный знак.\n"
"</P>"

#: in/chapter03-10.html:135
msgid ""
"<BLOCKQUOTE>\n"
"Some Lisp systems systems may require you to press the <KBD>return</KBD> \n"
"key before any input is recognized.  This is unusual, and can often be \n"
"fixed by a configuration parameter -- consult your Lisp vendor.\n"
"</BLOCKQUOTE>"
msgstr ""
"<BLOCKQUOTE>\n"
"Некоторые системы Lisp могут потребовать, чтобы вы нажали клавишу \n"
"<KBD>return</KBD>, прежде чем какой-либо ввод будет распознан. \n"
"Это необычно, и часто может быть исправлено с помощью параметра \n"
"конфигурации - обратитесь к поставщику Lisp.\n"
"</BLOCKQUOTE>"

#: in/chapter03-10.html:143
msgid ""
"<P><CODE>WRITE</CODE> and <CODE>WRITE-CHAR</CODE> both return the value \n"
"they're given.  The way in which they print the value is different.  \n"
"<CODE>WRITE</CODE> prints the value so that it could be presented to \n"
"<CODE>READ</CODE> to create the same value.  <CODE>WRITE-CHAR</CODE> \n"
"prints just the readable character, without the extra Lisp syntax (the \n"
"<CODE>#\\</CODE>) that would identify it to <CODE>READ</CODE> as a \n"
"character.</P>"
msgstr ""
"<P>\n"
"<CODE>WRITE</CODE> и <CODE>WRITE-CHAR</CODE> оба возвращают полученное\n"
"значение. Но способ, которым они печатают значение, отличается. \n"
"<CODE>WRITE</CODE> печатает значение так, чтобы оно могло быть \n"
"представлено для <CODE>READ</CODE>, чтобы он мог создать то же самое "
"значение. \n"
"<CODE>WRITE-CHAR</CODE> печатает только читаемый символьный знак, \n"
"без дополнительного синтаксиса Lisp <CODE>#\\</CODE>), который \n"
"идентифицировал бы его для <CODE>READ</CODE> как символьный знак.\n"
"</P>"

#: in/chapter03-10.html:147
msgid ""
"<P>Lisp represents a single character using the notation \n"
"<CODE>#\\<I>char</I></CODE>, where <I>char</I> is a literal character or "
"the \n"
"name of a character that does not have a printable glyph.</P>"
msgstr ""
"<P>\n"
"Lisp представляет один символьный знак, используя обозначение \n"
"<CODE>#\\<I>char</I></CODE>, где <I>char</I> - это литеральный символьный\n"
"знак или имя символьного знака, который не имеет печатаемого "
"глифа(изображения).\n"
"</P>"

#: in/chapter03-10.html:160
msgid ""
"<pre>\n"
"Character           Hex Value   Lisp           Standard?\n"
"--------------------------------------------------------\n"
"  space                 20      #\\Space          yes\n"
"  newline               --      #\\Newline        yes\n"
"  backspace             08      #\\Backspace      semi\n"
"  tab                   09      #\\Tab            semi\n"
"  linefeed              0A      #\\Linefeed       semi\n"
"  formfeed              0C      #\\Page           semi\n"
"  carriage return       0D      #\\Return         semi\n"
"  rubout or DEL         7F      #\\Rubout         semi\n"
"</pre>"
msgstr ""

#: in/chapter03-10.html:164
msgid ""
"<P>Only <CODE>#\\Space</CODE> and <CODE>#\\Newline</CODE> are required on "
"all \n"
"Lisp systems.  Systems that use the ASCII character set will probably \n"
"implement the rest of the character codes shown above.</P>"
msgstr ""
"<P>\n"
"Только <CODE>#\\Space</CODE> и <CODE>#\\Newline</CODE> требуются во \n"
"всех системах Lisp. Системы, использующие набор символьных знаков ASCII,\n"
"вероятно, реализуют и остальные коды символьных знаков, показанные выше.\n"
"</P>"

#: in/chapter03-10.html:167
msgid ""
"<P>The <CODE>#\\Newline</CODE> character stands for whatever convention \n"
"represents the end of a printed line on the host system, e.g.:</P>"
msgstr ""
"<P>\n"
"Имя символьного знака <CODE>#\\Newline</CODE> обозначает любое соглашение,\n"
"представляющее собой конец печатной строки на хост-системе, например:\n"
"</P>"

#: in/chapter03-10.html:175
msgid ""
"<pre>\n"
"System        Newline     Hex Value\n"
"-----------------------------------\n"
"Macintosh       CR          0D\n"
"MS-DOS          CR LF       0D 0A\n"
"Unix            LF          0A\n"
"</pre>"
msgstr ""

#: in/chapter03-10.html:178
msgid ""
"<P>The 94 printable standard characters are represented by \n"
"#\\<I>char</I>:</P>"
msgstr ""
"<P>94 печатаемых стандартных символа представлены следующим \n"
"образом: #\\<I>char</I>:</P>"

#: in/chapter03-10.html:187
msgid ""
"<pre>\n"
"  ! \" # $ % & ' ( ) * + , - . / \n"
"0 1 2 3 4 5 6 7 8 9 : ; &lt; = &gt; ? \n"
"@ A B C D E F G H I J K L M N O \n"
"P Q R S T U V W X Y Z [ \\ ] ^ _ \n"
"` a b c d e f g h i j k l m n o \n"
"p q r s t u v w x y z { | } ~\n"
"</pre>"
msgstr ""

#: in/chapter03-10.html:189
msgid "<h3>Arrays organize data into tables</h3> "
msgstr "<h3>Массивы организуют данные в таблицы</h3> "

#: in/chapter03-10.html:192
msgid ""
"<P>If you need to organize data in tables of two, three, or more \n"
"dimensions, you can create an array:</P>"
msgstr ""
"<P>Если вам нужно организовать данные в таблицах двух, трех или более "
"измерений, вы можете создать массив:\n"
"</P>"

#: in/chapter03-10.html:194
msgid ""
"<pre width=80><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> "
"(setq a1 (make-array '(3 4)))<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-"
"&gt;\" ALIGN=\"BOTTOM\"> #2A((NIL NIL NIL NIL) <br>      (NIL NIL NIL NIL) "
"<br>      (NIL NIL NIL NIL))<br><br><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?"
"\" ALIGN=\"BOTTOM\"> (setf (aref a1 0 0) (list 'element 0 0))<br><IMG SRC="
"\"gifs/right-arrow.gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> (ELEMENT 0 "
"0)<br><br><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> (setf "
"(aref a1 1 0) (list 'element 1 0))<br><IMG SRC=\"gifs/right-arrow.gif\" ALT="
"\"-&gt;\" ALIGN=\"BOTTOM\"> (ELEMENT 1 0)<br><br><IMG SRC=\"gifs/circle-dot."
"gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> (setf (aref a1 2 0) (list 'element 2 "
"0))<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> "
"(ELEMENT 2 0)<br><br><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN="
"\"BOTTOM\"> a1<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-&gt;\" ALIGN="
"\"BOTTOM\"> #2A(((ELEMENT 0 0) NIL NIL NIL) <br>      ((ELEMENT 1 0) NIL NIL "
"NIL) <br>      ((ELEMENT 2 0) NIL NIL NIL))<br><br><IMG SRC=\"gifs/circle-"
"dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> (aref a1 0 0)<br><IMG SRC=\"gifs/right-"
"arrow.gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> (ELEMENT 0 0)<br><br><IMG SRC="
"\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> (setf (aref a1 0 1) "
"pi)<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> "
"3.141592653589793<br><br><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN="
"\"BOTTOM\"> (setf (aref a1 0 2) \"hello\")<br><IMG SRC=\"gifs/right-arrow.gif"
"\" ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> \"hello\"<br><br><IMG SRC=\"gifs/circle-"
"dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> (aref a1 0 2)<br><IMG SRC=\"gifs/right-"
"arrow.gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> \"hello\"</pre>"
msgstr ""

#: in/chapter03-10.html:199
msgid ""
"<P>You create an array using <CODE>MAKE-ARRAY</CODE>, which takes a list "
"of \n"
"dimensions and returns an array.  By default, an array can contain any \n"
"kind of data; optional arguments let you restrict the element data types \n"
"for the sake of efficiency.</P>"
msgstr ""
"<P>\n"
"Вы создаете массив с помощью <CODE>MAKE-ARRAY</CODE>, который принимает \n"
"список измерений и возвращает массив. По умолчанию массив может содержать \n"
"любые типы данных; необязательные аргументы позволяют ограничить типы \n"
"данных элементов для повышения эффективности.\n"
"</P>"

#: in/chapter03-10.html:206
msgid ""
"<P>An array's <EM>rank</EM> is the same as its number of dimensions.  We \n"
"created a rank-2 array in the above example.  Lisp prints an array using \n"
"the notation <CODE>#<I>rank</I>A(...)</CODE>.  The contents of the array \n"
"appear as nested lists, with the first dimension appearing as the "
"outermost \n"
"grouping, and the last dimension appearing as the elements of the \n"
"innermost grouping.</P>"
msgstr ""
"<P>\n"
"Ранг(<EM>rank</EM>) массива совпадает с его количеством измерений. \n"
"В приведенном выше примере мы создали массив ранга-2. Lisp печатает \n"
"массив, используя обозначение <CODE>#<I>rank</I>A(...)</CODE>. \n"
"Содержимое массива отображается в виде вложенных списков, причем \n"
"первое измерение отображается как самая внешняя группировка, \n"
"а последнее измерение - как элементы самой внутренней группировки.\n"
"</P>"

#: in/chapter03-10.html:211
msgid ""
"<BLOCKQUOTE>\n"
"Your Lisp system will probably not print an array with line breaks as I've \n"
"shown here.  I added these breaks to emphasize the structure of the array.\n"
"</BLOCKQUOTE>"
msgstr ""
"<BLOCKQUOTE>\n"
"Ваша система Lisp, вероятно, не будет печатать массив с разрывами строк, \n"
"как я показал здесь. Я добавил эти разрывы, чтобы подчеркнуть структуру \n"
"массива.\n"
"</BLOCKQUOTE>"

#: in/chapter03-10.html:216
msgid ""
"<P>To retrieve an element of an array, use <CODE>AREF</CODE>.  \n"
"<CODE>AREF</CODE>'s first argument is the array; the remaining arguments \n"
"specify the index along each dimension.  The number of indices must match \n"
"the rank of the array.</P>"
msgstr ""
"<P>\n"
"Чтобы извлечь элемент массива, используйте <CODE>AREF</CODE>. \n"
"Первым аргументом <CODE>AREF</CODE> является массив; остальные аргументы\n"
"определяют индекс вдоль каждого измерения. Количество индексов должно\n"
"соответствовать рангу массива.\n"
"</P>"

#: in/chapter03-10.html:223
msgid ""
"<P>To set an element of an array, use <CODE>AREF</CODE> inside a \n"
"<CODE>SETF</CODE> form as shown in the example.  <CODE>SETF</CODE> is \n"
"similar to <CODE>SETQ</CODE>, except where <CODE>SETQ</CODE> assigns a \n"
"value to a <EM>symbol</EM>, <CODE>SETF</CODE> assigns a value to a \n"
"<EM>place</EM>.  In the examples, the <CODE>AREF</CODE> form specifies the \n"
"place as an element in the array.</P>"
msgstr ""
"<P>\n"
"Чтобы задать значение элемента массива, используйте <CODE>AREF</CODE> \n"
"внутри формы <CODE>SETF</CODE>, как показано в Примере. \n"
"Чтение аналогично <CODE>SETQ</CODE>, кроме случаев, когда <CODE>SETQ</CODE>\n"
"присваивает значение <EM>символу</EM>, <CODE>SETF</CODE> присваивает \n"
"значение <EM>месту/place</EM>. В примерах форма <CODE>AREF</CODE> \n"
"указывает место в качестве элемента массива.\n"
"</P>"

#: in/chapter03-10.html:225
msgid "<h3>Vectors are one-dimensional arrays</h3> "
msgstr "<h3>Векторы - это одномерные массивы</h3> "

#: in/chapter03-10.html:228
msgid ""
"<P>Vectors are one-dimensional arrays.  You can create a vector using \n"
"<CODE>MAKE-ARRAY</CODE>, and access its elements using <CODE>AREF</CODE>.</P>"
msgstr ""
"<P>\n"
"Векторы - это одномерные массивы. Вы можете создать вектор с помощью \n"
"<CODE>MAKE-ARRAY</CODE> и получить доступ к его элементам с помощью \n"
"<CODE>AREF</CODE>.\n"
"</P>"

#: in/chapter03-10.html:230
msgid ""
"<pre width=80><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> "
"(setq v1 (make-array '(3)))<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-&gt;"
"\" ALIGN=\"BOTTOM\"> #(NIL NIL NIL)<br><br><IMG SRC=\"gifs/circle-dot.gif\" "
"ALT=\"?\" ALIGN=\"BOTTOM\"> (make-array 3)<br><IMG SRC=\"gifs/right-arrow.gif"
"\" ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> #(NIL NIL NIL)<br><br><IMG SRC=\"gifs/"
"circle-dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> (setf (aref v1 0) :"
"zero)<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> :"
"ZERO<br><br><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> "
"(setf (aref v1 1) :one)<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-&gt;\" "
"ALIGN=\"BOTTOM\"> :ONE<br><br><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" "
"ALIGN=\"BOTTOM\"> (aref v1 0)<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-"
"&gt;\" ALIGN=\"BOTTOM\"> :ZERO<br><br><IMG SRC=\"gifs/circle-dot.gif\" ALT="
"\"?\" ALIGN=\"BOTTOM\"> v1<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-&gt;"
"\" ALIGN=\"BOTTOM\"> #(:ZERO :ONE NIL)</pre>"
msgstr ""

#: in/chapter03-10.html:233
msgid ""
"<P>Lisp prints vectors using the slightly abbreviated form \n"
"<CODE>#(...)</CODE>, rather than <CODE>#1A(...)</CODE>.</P>"
msgstr ""
"<P>Lisp печатает векторы, используя слегка сокращенную форму \n"
"<CODE>#(...)</CODE>, а не  <CODE>#1A(...)</CODE>.</P>"

#: in/chapter03-10.html:236
msgid ""
"<P>You can use either a single-element list or a number to specify the \n"
"vector dimensions to <CODE>MAKE-ARRAY</CODE> -- the effect is the same.</P>"
msgstr ""
"<P>\n"
"Вы можете использовать либо одноэлементный список, либо число, \n"
"чтобы указать векторные размеры для <CODE>MAKE-ARRAY</CODE> - \n"
"эффект тот же.\n"
"</P>"

#: in/chapter03-10.html:239
msgid ""
"<P>You can create a vector from a list of values, using the <CODE>VECTOR</"
"CODE> \n"
"form:</P>"
msgstr ""
"<P>\n"
"Вы можете создать вектор из списка значений, используя форму <CODE>VECTOR</"
"CODE>:\n"
"</P>"

#: in/chapter03-10.html:241
msgid ""
"<pre width=80><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> "
"(vector 34 22 30)<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-&gt;\" ALIGN="
"\"BOTTOM\"> #(34 22 30)</pre>"
msgstr ""

#: in/chapter03-10.html:246
msgid ""
"<P>This is similar to the <CODE>LIST</CODE> form, except that the result "
"is \n"
"a vector instead of a list.  There are other similarities between lists \n"
"and vectors: both are <EM>sequences</EM>.  Sequences are manipulated by "
"the \n"
"functions we'll see in <A HREF=\"chapter13.html\">Chapter 13</A>.</P>"
msgstr ""
"<P>\n"
"Это похоже на форму <CODE>LIST</CODE>, за исключением того, что \n"
"результатом является вектор, а не список. Есть и другие сходства между \n"
"списками и векторами: оба являются <EM>sequences/последовательностями</EM>.\n"
"Последовательностями управляют функции, которые мы увидим в \n"
"<A HREF=\"chapter13.html\">Главе 13</A>.\n"
"</P>"

#: in/chapter03-10.html:249
msgid ""
"<P>You can use <CODE>AREF</CODE> to access the elements of a vector, or "
"you \n"
"can use the sequence-specific function, <CODE>ELT</CODE>:</P>"
msgstr ""
"<P>\n"
"Вы можете использовать <CODE>AREF</CODE> для доступа к элементам вектора \n"
"или использовать функцию, зависящую от последовательности, <CODE>ELT</"
"CODE>:\n"
"</P>"

#: in/chapter03-10.html:251
msgid ""
"<pre width=80><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> "
"(setf v2 (vector 34 22 30 99 66 77))<br><IMG SRC=\"gifs/right-arrow.gif\" "
"ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> #(34 22 30 99 66 77)<br><br><IMG SRC=\"gifs/"
"circle-dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> (setf (elt v2 3) :"
"radio)<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> :"
"RADIO<br><br><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> "
"v2<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> #(34 "
"22 30 :RADIO 66 77)</pre>"
msgstr ""

#: in/chapter03-10.html:253
msgid "<h3>Strings are vectors that contain only characters</h3> "
msgstr ""
"<h3>Строки-это векторы, содержащие только знаковые символы(character)</h3> "

#: in/chapter03-10.html:259
msgid ""
"<P>You already know how to write a string using the <CODE>\"...\"</CODE> \n"
"syntax.  Since a string is a vector, you can apply the array and vector \n"
"functions to access elements of a string.  You can also create strings \n"
"using the <CODE>MAKE-STRING</CODE> function or change characters or "
"symbols \n"
"to strings using the <CODE>STRING</CODE> function.</P>"
msgstr ""
"<P>\n"
"Вы уже знаете, как написать строку с помощью синтаксиса двойных кавычек\n"
"<CODE>\"...\"</CODE>.\n"
"Поскольку строка является вектором, вы можете применить функции массива и\n"
"вектора для доступа к элементам строки. Вы также можете создавать строки с\n"
"помощью функции <CODE>MAKE-STRING</CODE> или изменять символы или знаки на \n"
"строки с помощью функции <CODE>STRING</CODE>.\n"
"</P>"

#: in/chapter03-10.html:261
msgid ""
"<pre width=80><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> "
"(setq s1 \"hello, there.\")<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-&gt;"
"\" ALIGN=\"BOTTOM\"> \"hello, there.\"<br><br><IMG SRC=\"gifs/circle-dot.gif"
"\" ALT=\"?\" ALIGN=\"BOTTOM\"> (setf (elt s1 0) #\\H))<br><IMG SRC=\"gifs/"
"right-arrow.gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> #\\H<br><br><IMG SRC="
"\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> (setf (elt s1 12) #"
"\\!)<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> #"
"\\!<br><br><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> "
"s1<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> "
"\"Hello, there!\"<br><br><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN="
"\"BOTTOM\"> (string 'a-symbol)<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-"
"&gt;\" ALIGN=\"BOTTOM\"> \"A-SYMBOL\"<br><br><IMG SRC=\"gifs/circle-dot.gif"
"\" ALT=\"?\" ALIGN=\"BOTTOM\"> (string #\\G)<br><IMG SRC=\"gifs/right-arrow."
"gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> \"G\"</pre>"
msgstr ""

#: in/chapter03-10.html:263
msgid "<h3>Symbols are unique, but they have many values</h3> "
msgstr "<h3>Символы уникальны, но они имеют много значений</h3> "

#: in/chapter03-10.html:273
msgid ""
"<P>We saw in <A HREF=\"chapter03-05.html\">Lesson 5</A> that a symbol has "
"a \n"
"unique identity, but this bears repeating: A symbol is <EM>identical</EM> \n"
"to any other symbol spelled the same way \n"
"(including its package designation, which we'll learn more about at the "
"end \n"
"of this lesson).  This means that you can have Lisp read a program or "
"data, \n"
"and every occurrence of a symbol with the same spelling is the same \n"
"symbol.  Since Lisp supplies the mechanism to do this, it's one less thing \n"
"you have to worry about when you write a program that manipulates \n"
"<EM>symbolic</EM> information.</P>"
msgstr ""
"<P>\n"
"Мы видели в <A HREF=\"chapter03-05.html\">Уроке 5</A>, что символ имеет\n"
"уникальную идентичность, но когда он вновь встречается: символ идентичен\n"
"любому другому символу, написанному таким же образом (включая название\n"
"его пакета(package), о котором мы узнаем больше в конце этого урока). \n"
"Это означает, что вы можете заставить Lisp читать программу или данные, \n"
"и каждое появление символа с одинаковым написанием является одним и тем же\n"
"символом. Поскольку Lisp предоставляет механизм для этого, это еще одна \n"
"вещь, о которой вам нужно беспокоиться, когда вы пишете программу, которая\n"
"манипулирует </EM>символьной</EM> информацией\n"
"</P>"

#: in/chapter03-10.html:281
msgid ""
"<P>We also learned in <A HREF=\"chapter03-05.html\">Lesson 5</A> that a \n"
"symbol can have values as a variable and a function, and for "
"documentation, \n"
"print name, and properties.  <A NAME=\"property-list\">A symbol's property \n"
"list is like a miniature database which associates a number of key/value \n"
"pairs with the symbol.  For example, if your program represented and \n"
"manipulated objects, you could store information about an object on its \n"
"property list:</A></P>"
msgstr ""
"<P>\n"
"В <A HREF=\"chapter03-05.html\">Уроке 5</A> мы также узнали, что символ "
"может\n"
"иметь значения в виде переменной и функции, а также для документации, \n"
"печатного имени и свойств. <A NAME=\"property-list\">Список свойств символа\n"
"подобен миниатюрной базе данных, которая связывает несколько пар \n"
"ключ/значение с символом. Например, если ваша программа представляет "
"объекты \n"
"и управляет ими, вы можете хранить информацию об объекте в списке его "
"свойств:\n"
"</A></P>"

#: in/chapter03-10.html:283
msgid ""
"<pre width=80><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> "
"(setf (get 'object-1 'color) 'red)<br><IMG SRC=\"gifs/right-arrow.gif\" ALT="
"\"-&gt;\" ALIGN=\"BOTTOM\"> RED<br><br><IMG SRC=\"gifs/circle-dot.gif\" ALT="
"\"?\" ALIGN=\"BOTTOM\"> (setf (get 'object-1 'size) 'large)<br><IMG SRC="
"\"gifs/right-arrow.gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> LARGE<br><br><IMG "
"SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> (setf (get 'object-1 "
"'shape) 'round)<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-&gt;\" ALIGN="
"\"BOTTOM\"> ROUND<br><br><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN="
"\"BOTTOM\"> (setf (get 'object-1 'position) '(on table))<br><IMG SRC=\"gifs/"
"right-arrow.gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> (ON TABLE)<br><br><IMG SRC="
"\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> (setf (get 'object-1 "
"'weight) 15)<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-&gt;\" ALIGN="
"\"BOTTOM\"> 15<br><br><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN="
"\"BOTTOM\"> (symbol-plist 'object-1)<br><IMG SRC=\"gifs/right-arrow.gif\" "
"ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> (WEIGHT 15 POSITION (ON TABLE) SHAPE ROUND "
"SIZE LARGE <br>     COLOR RED)<br><br><IMG SRC=\"gifs/circle-dot.gif\" ALT="
"\"?\" ALIGN=\"BOTTOM\"> (get 'object-1 'color)<br><IMG SRC=\"gifs/right-"
"arrow.gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> RED<br><br><IMG SRC=\"gifs/"
"circle-dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> object-1<br><IMG SRC=\"gifs/"
"right-arrow.gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> Error: no value<br></pre>"
msgstr ""

#: in/chapter03-10.html:287
msgid ""
"<P>Note that <CODE>OBJECT-1</CODE> doesn't have a value -- all of the \n"
"useful information is in two places: the <EM>identity</EM> of the symbol, \n"
"and the symbol's properties.</P>"
msgstr ""
"<P>\n"
"Обратите внимание, что <CODE>OBJECT-1</CODE> не имеет значения - вся "
"полезная\n"
"информация находится в двух местах: <EM>identity</EM>(идентичности символа) "
"и\n"
"свойствах символа.\n"
"</P>"

#: in/chapter03-10.html:295
msgid ""
"<BLOCKQUOTE>\n"
"This use of properties predates modern object programming by a few \n"
"decades.  It provides two of the three essential mechanisms of an object: \n"
"identity and encapsulation (remember that property values could just as \n"
"well be a function).  The third mechanism, inheritance, was sometimes \n"
"simulated by links to other \"objects.\"\n"
"</BLOCKQUOTE>"
msgstr ""
"<BLOCKQUOTE>\n"
"Такое использование свойств предшествовало современному объектному\n"
"программированию на несколько десятилетий. Оно обеспечивало два из трех \n"
"основных механизмов объектов: идентификацию и инкапсуляцию (помните, что\n"
"значения свойств могут также быть функцией). Третий механизм, наследование,\n"
"иногда моделировался ссылками на другие \"объекты\".\n"
"</BLOCKQUOTE>"

#: in/chapter03-10.html:305
msgid ""
"<P>Properties are less often used in modern Lisp programs.  Hash tables "
"(<A \n"
"HREF=\"#hash-tables\">see below)</A>, structures (described in the next \n"
"section), and CLOS objects (see <A HREF=\"chapter07.html\">Chapter 7</A> "
"and \n"
"<A HREF=\"chapter14.html\">Chapter 14</A>) provide all of the capabilities "
"of \n"
"property lists in ways that are easier to use and more efficient.  Modern \n"
"Lisp development systems often use properties to annotate a program by \n"
"keeping track of certain information such as the file and file position of \n"
"the defining form for a symbol, and the definition of a function's "
"argument \n"
"list (for use by informational tools in the programming environment).</P>"
msgstr ""
"<P>\n"
"Свойства всё реже используются в современных программах Lisp. Хэш-таблицы \n"
"(<A HREF=\"#hash-tables\">см.ниже)</A>), структуры (описанные в следующем\n"
"разделе) и объекты CLOS (см. <A HREF=\"chapter07.html\">Главу 7</A> и \n"
"<A HREF=\"chapter14.html\">Главу 14</A>) обеспечивают все возможности \n"
"списков свойств более простыми и эффективными способами. Современные "
"системы\n"
"разработки Lisp часто используют свойства для аннотирования программы,\n"
"отслеживая определенную информацию, такую как файл и положение файла\n"
"определяющей формы для символа, а также определение списка аргументов \n"
"функции (для использования информационными средствами в среде \n"
"программирования).\n"
"</P>"

#: in/chapter03-10.html:307
msgid ""
"<h3><A NAME=\"structures\">Structures let you store related data</A></h3> "
msgstr ""
"<h3><A NAME=\"structures\">Структуры позволяют хранить связанные данные\n"
"</A></h3> "

#: in/chapter03-10.html:310
msgid ""
"<P>A Lisp structure gives you a way to create an object which stores "
"related \n"
"data in named slots.</P>"
msgstr ""
"<P>Структура Lisp позволяет создать объект, который хранит связанные данные "
"в именованных слотах.\n"
"</P>"

#: in/chapter03-10.html:312
msgid ""
"<pre width=80><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> "
"(defstruct struct-1 color size shape position weight)<br><IMG SRC=\"gifs/"
"right-arrow.gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> STRUCT-1<br><br><IMG SRC="
"\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> (setq object-2 (make-"
"struct-1<br>                     :size 'small <br>                     :"
"color 'green <br>                     :weight 10 <br>                     :"
"shape 'square))<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-&gt;\" ALIGN="
"\"BOTTOM\"> #S(STRUCT-1 :COLOR GREEN :SIZE SMALL :SHAPE SQUARE <br>     :"
"POSITION NIL :WEIGHT 10)<br><br><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" "
"ALIGN=\"BOTTOM\"> (struct-1-shape object-2)<br><IMG SRC=\"gifs/right-arrow."
"gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> SQUARE<br><br><IMG SRC=\"gifs/circle-"
"dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> (struct-1-position object-2)<br><IMG "
"SRC=\"gifs/right-arrow.gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> NIL<br><br><IMG "
"SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> (setf (struct-1-"
"position object-2) '(under table))<br><IMG SRC=\"gifs/right-arrow.gif\" ALT="
"\"-&gt;\" ALIGN=\"BOTTOM\"> (UNDER TABLE)<br><br><IMG SRC=\"gifs/circle-dot."
"gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> (struct-1-position object-2)<br><IMG SRC="
"\"gifs/right-arrow.gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> (UNDER-TABLE)</pre>"
msgstr ""

#: in/chapter03-10.html:322
msgid ""
"<P>In the example, we defined a structure type named <CODE>STRUCT-1</CODE> \n"
"with slots named <CODE>COLOR</CODE>, <CODE>SHAPE</CODE>, <CODE>SIZE</"
"CODE>, \n"
"<CODE>POSITION</CODE>, and <CODE>WEIGHT</CODE>.  Then we created an \n"
"instance of a <CODE>STRUCT-1</CODE> type, and assigned the instance to the \n"
"variable <CODE>OBJECT-2</CODE>.  The rest of the example shows how to \n"
"access slots of a struct instance using accessor functions named for the \n"
"structure type and the slot name.  Lisp generates the \n"
"make-<I>structname</I> and <I>structname</I>-<I>slotname</I> functions "
"when \n"
"you define a structure using <CODE>DEFSTRUCT</CODE>.</P>"
msgstr ""
"<P>\n"
"В этом примере мы определили тип структуры с именем <CODE>STRUCT-1</CODE>\n"
"и слотами с именами <CODE>COLOR</CODE>, <CODE>SHAPE</CODE>, <CODE>SIZE</"
"CODE>, \n"
"<CODE>POSITION</CODE>, and <CODE>WEIGHT</CODE>. Затем мы создали экземпляр \n"
"типа <CODE>STRUCT-1</CODE> и присвоили его переменной <CODE>OBJECT-2</"
"CODE>. \n"
"В остальной части примера показано, как получить доступ к слотам экземпляра\n"
"структуры с помощью функций доступа, названных по типу структуры и имени "
"слота. Lisp генерирует функции make-<I>structname</I> и \n"
"<I>structname</I>-<I>slotname</I> при определении структуры с помощью\n"
"<CODE>DEFSTRUCT</CODE>.\n"
"</P>"

#: in/chapter03-10.html:325
msgid ""
"<P>We'll look at <CODE>DEFSTRUCT</CODE>'s optional features in <A \n"
"HREF=\"chapter06.html\">Chapter 6</A>.</P>"
msgstr ""
"<P>\n"
"Мы рассмотрим дополнительные функции <CODE>DEFSTRUCT</CODE> в \n"
"<A HREF=\"chapter06.html\">Глава 6</A>.\n"
"</P>"

#: in/chapter03-10.html:327
msgid "<h3>Type information is apparent at runtime</h3> "
msgstr "<h3>Информация о типе является видной во время выполнения</h3> "

#: in/chapter03-10.html:330
msgid ""
"<P>A symbol can be associated with any type of value at runtime.  For "
"cases \n"
"where it matters, Lisp lets you query the type of a value.</P>"
msgstr ""
"<P>Символ может быть связан с любым типом значения во время выполнения. \n"
"В тех случаях, когда он имеет значение, Lisp позволяет запрашивать тип "
"значения.</P>"

#: in/chapter03-10.html:332
msgid ""
"<pre width=80><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> "
"(type-of 123)<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-&gt;\" ALIGN="
"\"BOTTOM\"> FIXNUM<br><br><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN="
"\"BOTTOM\"> (type-of 123456789000)<br><IMG SRC=\"gifs/right-arrow.gif\" ALT="
"\"-&gt;\" ALIGN=\"BOTTOM\"> BIGNUM<br><br><IMG SRC=\"gifs/circle-dot.gif\" "
"ALT=\"?\" ALIGN=\"BOTTOM\"> (type-of \"hello, world\")<br><IMG SRC=\"gifs/"
"right-arrow.gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> (SIMPLE-BASE-STRING "
"12)<br><br><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> "
"(type-of 'fubar)<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-&gt;\" ALIGN="
"\"BOTTOM\"> SYMBOL<br><br><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN="
"\"BOTTOM\"> (type-of '(a b c))<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-"
"&gt;\" ALIGN=\"BOTTOM\"> CONS</pre>"
msgstr ""

#: in/chapter03-10.html:337
msgid ""
"<P><CODE>TYPE-OF</CODE> returns a symbol or a list indicating the type of \n"
"its argument.  This information can then be used to guide a program's \n"
"behavior based upon the type of its arguments.  The <CODE>TYPECASE</CODE> \n"
"function combines the type inquiry with a <CODE>COND</CODE>-like dispatch.</"
"P>"
msgstr ""
"<P><CODE>TYPE-OF</CODE> возвращает символ или список, указывающий тип \n"
"его аргумента. Затем эта информация может быть использована для \n"
"руководства поведением программы в зависимости от типа ее аргументов. \n"
"Функция <CODE>TYPECASE</CODE> объединяет запрос о типе с диспетчеризацией,\n"
"похожей на <CODE>COND</CODE>.\n"
"</P>"

#: in/chapter03-10.html:343
msgid ""
"<BLOCKQUOTE>\n"
"With the introduction of generic functions in CLOS (see <A \n"
"HREF=\"chapter14.html\">Chapter 14</A>), <CODE>TYPE-OF</CODE> is not as \n"
"important as it once was.\n"
"</BLOCKQUOTE>"
msgstr ""
"<BLOCKQUOTE>\n"
"С введением обобщенных функций в CLOS (см. \n"
"<A HREF=\"chapter14.html\">Главу 14</A>), <CODE>TYPE-OF</CODE> уже не так "
"важен, как раньше.\n"
"</BLOCKQUOTE>"

#: in/chapter03-10.html:345
msgid ""
"<h3><A NAME=\"hash-tables\">Hash Tables provide quick data access from a "
"lookup key</A></h3> "
msgstr ""
"<h3><A NAME=\"hash-tables\">Хеш-таблицы обеспечивают быстрый доступ к данным "
"по ключу поиска.</A></h3> "

#: in/chapter03-10.html:350
msgid ""
"<P>A hash table associates a value with a unique key.  Unlike a <A \n"
"HREF=\"#property-list\">property list</A>, a hash table is well suited to "
"a \n"
"large number of key/value pairs, but suffers from excessive overhead for \n"
"smaller sets of associations.</P>"
msgstr ""
"<P>\n"
"Хэш-таблица связывает значение с уникальным ключом. В отличие от списка\n"
"свойств(<A HREF=\"#property-list\">property list</A>), хэш-таблица хорошо\n"
"подходит для большого числа пар ключ/значение, но страдает от чрезмерных\n"
"накладных расходов для небольших наборов ассоциаций.\n"
"</P>"

#: in/chapter03-10.html:352
msgid ""
"<pre width=80><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> "
"(setq ht1 (make-hash-table))<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-&gt;"
"\" ALIGN=\"BOTTOM\"> #&lt;HASH-TABLE&gt;<br><br><IMG SRC=\"gifs/circle-dot."
"gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> (gethash 'quux ht1)<br><IMG SRC=\"gifs/"
"right-arrow.gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> NIL<br><IMG SRC=\"gifs/"
"right-arrow.gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> NIL<br><br><IMG SRC=\"gifs/"
"circle-dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> (setf (gethash 'baz ht1) 'baz-"
"value)<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> "
"BAZ-VALUE<br><br><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM"
"\"> (gethash 'baz ht1)<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-&gt;\" "
"ALIGN=\"BOTTOM\"> BAZ-VALUE<br><IMG SRC=\"gifs/right-arrow.gif\" ALT=\"-&gt;"
"\" ALIGN=\"BOTTOM\"> T<br><br><IMG SRC=\"gifs/circle-dot.gif\" ALT=\"?\" "
"ALIGN=\"BOTTOM\"> (setf (gethash 'gronk ht1) nil)<br><IMG SRC=\"gifs/right-"
"arrow.gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> NIL<br><br><IMG SRC=\"gifs/"
"circle-dot.gif\" ALT=\"?\" ALIGN=\"BOTTOM\"> (gethash 'gronk ht1)<br><IMG "
"SRC=\"gifs/right-arrow.gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> NIL<br><IMG SRC="
"\"gifs/right-arrow.gif\" ALT=\"-&gt;\" ALIGN=\"BOTTOM\"> T</pre>"
msgstr ""

#: in/chapter03-10.html:359
msgid ""
"<P>You create a hash table using <CODE>MAKE-HASH-TABLE</CODE>, and access \n"
"values using <CODE>GETHASH</CODE>.  <CODE>GETHASH</CODE> returns two \n"
"values.  The first is the value associated with the key.  The second \n"
"is <CODE>T</CODE> if the key was found, and <CODE>NIL</CODE> \n"
"otherwise.  Notice the difference between the first and last \n"
"<CODE>GETHASH</CODE> form in the examples above.</P>"
msgstr ""
"<P>\n"
"Вы создаете хэш-таблицу с помощью <CODE>MAKE-HASH-TABLE</CODE> и получаете\n"
"доступ к значениям с помощью <CODE>GETHASH</CODE>. <CODE>GETHASH</CODE>\n"
"возвращает два значения. Первое - это значение, связанное с ключом. Второе "
"-\n"
"это <CODE>T</CODE>, если ключ был найден, и <CODE>NIL</CODE> в противном\n"
"случае. Обратите внимание на разницу между первой и последней формой \n"
"<CODE>GETHASH</CODE> в приведенных выше примерах.\n"
"</P>"

#: in/chapter03-10.html:365
msgid ""
"<P>By default, a hash table is created so that its keys are compared using \n"
"<EM>EQ</EM> -- this works for symbols, but not numbers or lists.  We'll \n"
"learn more about equality predicates in <A HREF=\"chapter17.html\">Chapter \n"
"17</A>.  For now, just remember that if you want to use numbers for keys, \n"
"you must create a hash table using the form:</P>"
msgstr ""
"<P>\n"
"По умолчанию хэш-таблица создается так, что ее ключи сравниваются с помощью "
"<EM>EQ</EM>-это работает для символов, но не для чисел или списков. \n"
"Подробнее о предикатах равенства мы поговорим в \n"
"<A HREF=\"chapter17.html\">Главе 17</A>. А пока просто помните, что если вы\n"
"хотите использовать числа для ключей, вы должны создать хэш-таблицу с "
"помощью\n"
"формы:\n"
"</P>"

#: in/chapter03-10.html:367
msgid "<p><tt>(make-hash-table :test #'eql)</tt>"
msgstr ""

#: in/chapter03-10.html:369
msgid "<p>If you want to use lists for keys, create your hash table with:"
msgstr ""
"<p>Если вы хотите использовать списки для ключей, создайте свою хэш-таблицу "
"с\n"
"помощью:"

#: in/chapter03-10.html:371
msgid "<p><tt>(make-hash-table :test #'equal)</tt>"
msgstr ""

#: in/chapter03-10.html:376
msgid ""
"<P>If you want to remove a key, use the form <CODE>(REMHASH <VAR>key</VAR> \n"
"<VAR>hash-table</VAR>)</CODE>.  And if you want to change the value for a \n"
"key, use <CODE>GETHASH</CODE> with <CODE>SETF</CODE>, just as if you were \n"
"adding a new key/value pair.</P>"
msgstr ""
"<P>\n"
"Если вы хотите удалить ключ, используйте форму \n"
"<CODE>(REMHASH <VAR>key</VAR> <VAR>hash-table</VAR>)</CODE>. И если вы \n"
"хотите изменить значение ключа, используйте <CODE>GETHASH</CODE> с\n"
"<CODE>SETF</CODE>, как если бы вы добавляли новую пару ключ / значение.\n"
"</P>"

#: in/chapter03-10.html:378
msgid "<h3>Packages keep names from colliding</h3> "
msgstr "<h3>Пакты защищают от совпадения имен</h3> "

#: in/chapter03-10.html:385
msgid ""
"<P>One of the things that's hard about writing programs is naming parts of \n"
"your program.  On one hand, you want to use names that are easy to remember "
"and \n"
"evocative of the role or purpose of the named object.  On the other hand, \n"
"you don't want to use a name that someone else has already used (or is \n"
"likely to use) in a different program that you may \n"
"someday have to make work with your program.</P>"
msgstr ""
"<P>\n"
"Одна из самых сложных вещей при написании программ-это присвоение имен "
"частям\n"
"вашей программы. С одной стороны, вы хотите использовать имена, которые "
"легко\n"
"запоминаются и напоминают о роли или назначении именованного объекта. С "
"другой\n"
"стороны, вы не хотите использовать имя, которое кто-то уже использовал \n"
"(или, скорее всего, будет использовать) в другой программе, которую вам,\n"
"возможно, когда-нибудь придется заставить работать с вашей программой.\n"
"</P>"

#: in/chapter03-10.html:397
msgid ""
"<P>One way to avoid naming conflicts is to give every name in your program \n"
"a unique prefix that no one else is likely to use.  You see this done all \n"
"the time with libraries -- the prefix is typically one to three \n"
"characters.  Unfortunately, this still leaves a lot of room for two \n"
"software developers to choose the same prefix; especially since some \n"
"prefixes are more evocative than others.  If you have control over all the \n"
"software that will be developed for your product, you can choose all of "
"the \n"
"prefixes and avoid problems.  If you're going to buy third-party software \n"
"that uses a prefix naming scheme, you'll have to work around the names \n"
"chosen by your vendors and hope that two different vendors don't stumble \n"
"upon the same prefix.</P>"
msgstr ""
"<P>Один из способов избежать конфликтов имен - дать каждому имени в вашей\n"
"программе уникальный префикс, который вряд ли кто-либо будет использовать. \n"
"Вы видите, что это делается все время с библиотеками - префикс обычно\n"
"составляет от одного до трех символов. К сожалению, это все еще оставляет "
"много\n"
"места для двух разработчиков программного обеспечения, чтобы выбрать один и "
"тот\n"
"же префикс; тем более, что некоторые префиксы более выразительны, чем "
"другие.\n"
"Если у вас есть контроль над всем программным обеспечением, которое будет\n"
"разработано для вашего продукта, вы можете выбрать все префиксы и избежать\n"
"проблем. Если вы собираетесь купить стороннее программное обеспечение,\n"
"использующее схему именования префиксов, вам придется обойти имена, "
"выбранные\n"
"вашими поставщиками, и надеяться, что два разных поставщика не столкнуться "
"на\n"
"одном и том же префиксе\n"
"</P>"

#: in/chapter03-10.html:399
msgid ""
"<IMG SRC=\"gifs/prefixed-names.gif\" ALT=\"prefixed names example\" ALIGN="
"\"BOTTOM\">"
msgstr ""

#: in/chapter03-10.html:412
msgid ""
"<P>Another way to avoid naming conflicts is to use qualified names.  To do \n"
"this, the language must provide support for separate namespaces defined "
"and \n"
"controlled by the programmer.  To understand how this works, imagine that \n"
"all the names you create for your program get written on a sheet of paper \n"
"with your name written at the top as a title -- this is the \n"
"<EM>qualifier</EM> for all of your names.  To see whether a name is safe "
"to \n"
"use, you only have to check the list of names you've written on this "
"page.  \n"
"When someone else's software needs the services of your program, they "
"refer \n"
"to your names by using both your qualifier and name.  Because the other \n"
"person's software has a different qualifier, and their qualifier is \n"
"implicit (that is, it doesn't need to be written) for their own names, \n"
"there's no chance of a name conflict.</P>"
msgstr ""
"<P>Еще один способ избежать конфликтов имен-это использовать "
"квалифицированные\n"
"имена. Для этого язык должен обеспечивать поддержку отдельных пространств "
"имен,\n"
"определяемых и контролируемых программистом. Чтобы понять, как это "
"работает,\n"
"представьте, что все имена, которые вы создаете для своей программы,\n"
"записываются на листе бумаги с вашим именем, написанным сверху в качестве\n"
"заголовка-это квалификатор для всех ваших имен. Чтобы узнать, безопасно ли\n"
"использовать имя, вам нужно только проверить список имен, которые вы "
"написали на этой странице. Когда чье-то программное обеспечение нуждается в "
"услугах\n"
"вашей программы, они ссылаются на ваши имена, используя как ваш "
"квалификатор,\n"
"так и имя. Поскольку программное обеспечение другого человека имеет другой\n"
"квалификатор, а его квалификатор неявен (то есть он не должен быть "
"записан) \n"
"для их собственных имен, нет никаких шансов на конфликт имен.\n"
"</P>"

#: in/chapter03-10.html:423
msgid ""
"<P>You might think that a qualifier is no more than a complicated way to \n"
"add a prefix to a name.  However, there's a subtle but important \n"
"difference.  A prefix is part of the name; it cannot be changed once \n"
"written.  A qualifier is separate from the names it qualifies, and is \n"
"\"written down\" in exactly one place.  Furthermore, you can point to the \n"
"\"sheet of paper\" upon which names are written and refer to it as \"those \n"
"names.\" If you happen to choose the same qualifier as another programmer, \n"
"you can still refer to \"those names\" by a qualifier of your own choosing "
"-- \n"
"In other words, you can change the qualifier <EM>after the software has \n"
"been delivered for your use</EM>.</P>"
msgstr ""
"<P>Вы можете подумать, что квалификатор-это не более чем сложный способ\n"
"добавить префикс к имени. Однако есть тонкое, но важное отличие. Префикс \n"
"- это часть имени; он не может быть изменен после записи. Квалификатор \n"
"отделен от имен, которые он квалифицирует, и \"записан\" точно в одном "
"месте.\n"
"Кроме того, вы можете указать на \"листе бумаги\", на котором написаны "
"имена, \n"
"и ссылаться на него как на \"эти имена\".\"Если вы случайно выбрали тот же "
"самый\n"
"квалификатор, что и другой программист, вы все еще можете ссылаться на "
"\"эти\n"
"имена\" с помощью квалификатора по вашему собственному выбору-другими "
"словами,\n"
"вы можете изменить квалификатор <EM>после того, как программное обеспечение "
"будет поставлено для вашего использования</EM>.\n"
"</P>"

#: in/chapter03-10.html:425
msgid ""
"<IMG SRC=\"gifs/rename-package.gif\" ALT=\"rename-package example\" ALIGN="
"\"BOTTOM\">"
msgstr ""

#: in/chapter03-10.html:438
msgid ""
"<P>In the above example, two libraries are delivered in files \n"
"<CODE>LIB1</CODE> and <CODE>LIB2</CODE>.  Both library designers used the \n"
"name <CODE>UTIL</CODE> for the name of their namespace, known in Lisp as a \n"
"package name.  Each library lists the names exposed to a client.  The \n"
"programmer who uses the two libraries writes code in the package name \n"
"<CODE>MY-PACKAGE</CODE>.  After loading each library, the programmer \n"
"renames its package so the names are distinct.  Then, names in the library \n"
"are referenced using their <EM>renamed</EM> qualifiers, as we see in the \n"
"calls to <CODE>UTIL-1:INITIALIZE</CODE> and <CODE>UTIL-2:INITIALIZE</"
"CODE>.  \n"
"Notice how the <CODE>INITIALIZE</CODE> name is still available to the \n"
"programmer in its unqualified form -- this is equivalent to \n"
"<CODE>MY-PACKAGE:INITIALIZE</CODE>.</P>"
msgstr ""
"<P>\n"
"В приведенном выше примере две библиотеки поставляются в файлах \n"
"<CODE>LIB1</CODE> и <CODE>LIB2</CODE>. Оба разработчика библиотек \n"
"использовали имя <CODE>UTIL</CODE> для имени своего пространства\n"
"имен,известного в Lisp как имя пакета. В каждой библиотеке перечислены "
"имена,\n"
"доступные клиенту. Программист, использующий эти две библиотеки, "
"записывает \n"
"код в пакет с именем <CODE>MY-PACKAGE</CODE>. После загрузки каждой "
"библиотеки\n"
"программист переименовывает ее пакет, чтобы имена были различны. Затем на "
"имена\n"
"в библиотеке ссылаются с помощью их <EM>переименованных</EM> "
"квалификаторов,\n"
"как мы видим в вызовах <CODE>UTIL-1:INITIALIZE</CODE> и\n"
" <CODE>UTIL-2:INITIALIZE</CODE>. Обратите внимание, что имя\n"
"<CODE>INITIALIZE</CODE>  все еще доступно программисту в его неполной форме\n"
"-это эквивалентно <CODE>MY-PACKAGE:INITIALIZE</CODE>.\n"
"</P>"

#: in/chapter03-10.html:443
msgid ""
"<P>Lisp provides this functionality through a set of functions and macros \n"
"collective known as the <EM>package</EM> facility.  The <CODE>DEFPACKAGE</"
"CODE> \n"
"macro conveniently provides most package operations, while the \n"
"<CODE>IN-PACKAGE</CODE> macro sets the current package:</P>"
msgstr ""
"<P>Lisp предоставляет эту функциональность черезю набора функций и "
"макросов,\n"
"известных как средство <EM>package</EM>. Макрос <CODE>DEFPACKAGE</CODE> \n"
"удобно обеспечивает большинство операций с пакетами, в то время как макрос \n"
"<CODE>IN-PACKAGE</CODE> задает текущий пакет:</P>"

#: in/chapter03-10.html:450
msgid ""
"<pre>\n"
";;;; ---- File 1 ----\n"
"(defpackage util1\n"
"  (:export init func1 func2)\n"
"  (:use common-lisp))\n"
"(in-package util1)"
msgstr ""

#: in/chapter03-10.html:454
msgid ""
"(defun init () 'util1-init)\n"
"(defun func1 () 'util1-func1)\n"
"(defun func2 () 'util1-func2)"
msgstr ""

#: in/chapter03-10.html:460
msgid ""
";;;; ---- File 2 ----\n"
"(defpackage util2\n"
"  (:export init func1 func2)\n"
"  (:use common-lisp))\n"
"(in-package util2)"
msgstr ""

#: in/chapter03-10.html:464
msgid ""
"(defun init () 'util2-init)\n"
"(defun func1 () 'util2-func1)\n"
"(defun func2 () 'util2-func2)"
msgstr ""

#: in/chapter03-10.html:471
msgid ""
";;;; ---- File 3 ----\n"
"(defpackage client\n"
"  (:use common-lisp)\n"
"  (:import-from util1 func1)\n"
"  (:import-from util2 func2))\n"
"(in-package client)"
msgstr ""

#: in/chapter03-10.html:479
msgid ""
"(defun init () 'client-init)\n"
"(util1:init)\n"
"(util2:init)\n"
"(init)\n"
"(func1)\n"
"(func2)\n"
"</pre>"
msgstr ""

#: in/chapter03-10.html:487
msgid ""
"<P>The example lists the contents of three files.  File 1 and File 2 both \n"
"define three functions using identical names.  File 1 puts names in the \n"
"<CODE>UTIL1</CODE> package, while File 2 uses the <CODE>UTIL2</CODE> \n"
"package.  The <CODE>DEFPACKAGE</CODE> form names the package.  The \n"
"<CODE>:USE</CODE> option specifies that names from another package may be \n"
"used without qualification, while the <CODE>:EXPORT</CODE> option \n"
"specifies the names that are exposed to clients of the package.</P>"
msgstr ""
"<P>В этом примере показано содержимое трех файлов. Файл 1 и файл 2 "
"определяют\n"
"три функции, использующие одинаковые имена. Файл 1 помещает имена в пакет\n"
"<CODE>UTIL1</CODE>, в то время как файл 2 использует пакет <CODE>UTIL2</"
"CODE>.\n"
"Форма <CODE>DEFPACKAGE</CODE> дает имя пакету. Параметр <CODE>:USE</CODE>\n"
"указывает, что имена из другого пакета могут использоваться без каких-либо\n"
"квалификаторов, в то время как параметр <CODE>:EXPORT</CODE> указывает "
"имена,\n"
" которые доступны клиентам пакета.\n"
"</P>"

#: in/chapter03-10.html:493
msgid ""
"<P>The <CODE>DEFPACKAGE</CODE> form only creates a package.  The \n"
"<CODE>USE-PACKAGE</CODE> form makes a package <EM>current</EM> -- all \n"
"unqualified names are in whatever package is current.  The \n"
"<CODE>COMMON-LISP:*PACKAGE*</CODE> variable always contains the current \n"
"package.</P>"
msgstr ""
"<P>Форма <CODE>DEFPACKAGE</CODE> создает только пакет. Форма \n"
"<CODE>USE-PACKAGE</CODE> делает пакет текущим - все неквалифицированные \n"
"имена находятся в любом пакете, который является текущим. Переменная \n"
"<CODE>COMMON-LISP:*PACKAGE*</CODE> всегда содержит текущий пакет..</P>"

#: in/chapter03-10.html:502
msgid ""
"<P>File 3 creates the <CODE>CLIENT</CODE> package.  The \n"
"<CODE>:IMPORT-FROM</CODE> options bring in specific names from the \n"
"<CODE>UTIL1</CODE> and <CODE>UTIL2</CODE> packages -- these names may be \n"
"used without qualification in the <CODE>CLIENT</CODE> package.  Names that \n"
"are exported from <CODE>UTIL1</CODE> or <CODE>UTIL2</CODE> but not "
"imported \n"
"by <CODE>CLIENT</CODE> may still be referenced within <CODE>CLIENT</CODE> \n"
"by using an explicit qualifier of the form \n"
"<CODE><I>package</I>:<I>name</I></CODE>.</P>"
msgstr ""
"<P>Файл 3 создает пакет <CODE>CLIENT</CODE>. Опции  <CODE>:IMPORT-FROM</"
"CODE>\n"
"вводит определенные имена из пакетов <CODE>UTIL1</CODE> и <CODE>UTIL2</"
"CODE>\n"
"- эти имена могут использоваться без каких-либо квалификаторов в пакете\n"
"<CODE>CLIENT</CODE>. На имена, экспортированные из <CODE>UTIL1</CODE> или\n"
"<CODE>UTIL2</CODE>, но не импортированные клиентом, все еще можно ссылаться "
"в\n"
"<CODE>CLIENT</CODE> с помощью явного квалификатора пакета в форме:  \n"
"<CODE><I>package</I>:<I>name</I></CODE>.\n"
"</P>"

#: in/chapter03-10.html:507
msgid ""
"<P>This section covered only very basic package operations.  We'll cover \n"
"additional details in <A HREF=\"chapter31.html\">Chapter 31</A>, when we "
"look \n"
"again at packages within the context of constructing large software \n"
"systems.</P>"
msgstr ""
"<P>Этот раздел охватывал только самые основные операции с пакетами. Мы\n"
"рассмотрим дополнительные детали в <A HREF=\"chapter31.html\">Глава 31</"
"A>, \n"
"когда снова рассмотрим пакеты в контексте построения больших программных\n"
"систем.</P>"

#: in/chapter03-10.html:522
msgid ""
"<hr>\n"
"<div align=\"center\">\n"
"<a href=\"contents.html\">Contents</a> | <a href=\"cover.html\">Cover</a> "
"<br> \n"
"<a href=\"chapter02.html\">Chapter 2</a> | <A HREF=\"chapter03.html"
"\">Chapter 3, Introduction</A> | <A HREF=\"chapter03-09.html\">Chapter 3, "
"Lesson 9</A> | Chapter 3, Lesson 10 | <A HREF=\"chapter03-11.html\">Chapter "
"3, Lesson 11</A> | <a href=\"chapter04.html\">Chapter 4</a> | \n"
"</div>\n"
"<hr>\n"
"<address>\n"
"Copyright &copy; 1995-2001, David B. Lamkins<br>\n"
"All Rights Reserved Worldwide<br>\n"
"<br>\n"
"This book may not be reproduced without the written consent of its \n"
"author.  Online distribution is restricted to the author's site.\n"
"</address> \n"
"</body> </html> "
msgstr ""
