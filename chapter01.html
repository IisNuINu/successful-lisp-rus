<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Успешный Лисп - Глава 1</title> 
</head> 

<body bgcolor="white" text="black">
<h1>Глава 1 - Зачем?  Или: Ответы на возражения</h1> 

<P>Все знают Лисп, верно(это не про Россию)?  Многие из нас прошли курс,
который познакомил нас Лиспом, а также с тремя, четырьмя или более языками
программирования. Так я познакомился с Лиспом в 1975 году и подумал, что это
довольно бесполезный язык.  Он <em>ничего</em> не делал обычным способом, он
был медленным, и одних этих скобок было достаточно, чтобы свести с ума любого!
</P>

<P>Если ваш собственный опыт использования лиспа предшествовал 1985 году
или около того, то вы, вероятно, разделяете это мнение.  Но в 1984 году, 
когда большой брат так и не стал <em>реальностью</em> (не так ли?), в год
когда первый Macintosh (хотя и жалкий по сегодняшним меркам) начал массовые
поставки, мир Лиспа начал меняться.  К сожалению, большинство программистов этого не заметили; Состояние Лиспа быо связано с ИИ, который претерпел резкий спад - Зима ИИ - как раз то время когда Лисп достиг совершеннолетия.  Некоторые говорят, что это
было неудачей для Лиспа.  Я смотрю на всплеск интереса к другим динамическим языкам и
на проблемы, с которыми сталкиваются как практики, так и поставщики, и удивляюсь,
не слишком ли сильно Лисп опередил свое время.</P>

<P>С годами я изменил свое мнение о Лиспе до такой степени, что это не только 
мой любимый язык программирования, но и способ структурировать большую часть 
моих мыслей о программировании.  Я надеюсь, что эта книга передаст мой энтузиазм
и возможно изменит ваше мнение о Лиспе.</P>

<P>Ниже я перечислю большинство распространенных возражений против Лиспа.  
Они приходят от коллег, знакомых, менеджеров и из моего прошлого опыта.
Для каждой точки зрения я опиши, сколько на самом деле верно, а сколько зависит
от точки зрения и сколько пережиток мрачных дней ранних реализаций Лиспа.
В максимально возможной степени я буду избегать проведения сравнений с
другими языками. У Лиспа свой путь, и вы сможете сами сравнить его, понимая
Лисп так же, как и ваш обычный язык. Если вы в конце концов достаточно
поймете Лисп, чтобы знать, когда подойдет его использование, или найдете 
место для Лиспа в вашем личном инструментарии, то это значит, что я выполнил
свою работу.</P>

<P>Без дальнейших введений, вот дюжина причин, по которым вы можете избегать Лиспа:</P>

<hr>
<h2>Я видел Лисп раньше и не понял его.</h2> 

<P>Это действительно сложный вопрос. Большинство языков программирования
больше похожи друг на друга, чем на Лисп.  Если вы посмотрите на семейное
дерево компьютерных языков, то увидите, что наиболее распространенные языки,
используемые сегодня, это потомки семейства Algol.  Фукнции, общие для языков
семейства Алгол, включают алгебраическую запись выражений, блочную структуру для
управления видимостью переменных и способ вызова подпрограмм для получения значений
или эффектов.  Когда вы поймете эти понятия, вы можете работать с любым другим языком
в этой семье, изучая поверхностные различия: 
имена ключевых слов и стиль пунктуации.</P>

<P>Лисп действительно <em>другой</em>.  Если вы читаете код только на
языках семейства Алгол, вы не найдете знакомых знаков препинания или 
блочной структуры, которые могли бы помочь вам понять код на Лиспе, только
незнакомые имена, появляющиеся в, казалось бы, бессмысленных гнёздах скобок.
В Лиспе скобка - это <em>пунктуация</em>.  К счастью, их использование довольно
просто; проще чем, например, запоминать правила приоритетов операторов Си
или Паскаля.  Среды разработки Лисп даже предоставляют редакторы, которые помогают
сопоставить открывающие и закрывающие скобки.</P>

<P>Как только вы поймете, как составляются выражения на Лиспе, вам все равно
придется понять, что они означают.  Это сложнее, потому что Лисп пердоставляет
множество возможностей, которых нет в других языках, или дает незнакомые имена
знакомым концепциям.  Чтоыб понастоящему понять Лисп, вам нужно знать, как он
работает внутри. Как и большинство хороших программистов, у вас вероятно есть
ментальная модель работы вашего компьютера и того, как ваш любимый компилятор
переводит операторы из вашего любимого языка в машинный код.  Вы сойдете с
ума, если попробуете это с Лиспом, который кажется идет на многое, чтобы изолировать
вас от детелей организации машины.  Да, вы жертвуете некоторым контролем. Возможно,
неудивительно, что вы значительно выиграете в корректности программы, если перестанете
беспокоиться о том, как компилятор отображает вашу программу в машинный код.  Хорош
ли этот компромис?  Мы рассмотрим этот вопрос в следующей главе.</P>

<P>Эта книга научит вас, как читать и писать на Лиспе, как распознавать и понимать
новые слова, такие как <code>DEFUN</code>, <code>CONS</code>, и 
<code>FLET</code>, и -- в конечно итоге -- как думать на Лиспе так же, как вы думаете
на своем любимом языке программирования.</P>

<hr>
<h2>За скобками, я не вижу программы.</h2> 

<P>Частично эта проблема связана с непривычным синтаксисом.  Я говорил об
этом в предыдущем разделе.  Другая часть этой проблемы реальна: 
вам приходится иметь дело с множеством скобок.  К счастью, в средах 
программирования Лисп есть редакторы, которые механизируют процесс подсчета
скобок, мигая или выделяя совпадающие пары или манипулируюя целыми сбалансированными выражениями. Наконец, есть вопрос стиля.  
Правильный отступ улучшает читаемость программ на Лиспе, как и на других языках
программирования.  Но вертикальные пропуски часто мешают читабельности в Лиспе.</P>

<P>В этой книге я расскажу о механических и стилистических аспектах кода на Лиспе. 
К тому времени, когда вы закончите, у вас будет мнение о том, что представляет собой читаемый код, и вы сможете защитить свою позицию. Когда вы достигнете такого уровня уверенности, вы сможете писать эстетичный код на Лиспе и читать чужой код. 
Скобки больше не будут проблемой.</P>

<hr>
<h2>Лисп очень медленный по сравнению с моим любимым языком.</h2> 

<P>Возможно ... Но разница может быть не такой большой, как вы ожидаете. 
Во-первых, давайте очистим таблицу от старого заблуждения: что Lisp - 
интерпретируемый язык. Как правило, большинство современных систем Lisp
компилируется в машинный код. Некоторые компилируются в байтовый код,
который обычно выполняется в пять раз медленнее, чем машинный код. 
И одна или две свободно распространяемые системы Lisp запускают только интерпретированный код, но они являются исключением. Итак, есть первая 
часть ответа: если вы не используете <em>компилятор</em> Lisp, вы 
должны его получить.</P>

<P>Ваш стиль кодирования на Лиспе влияет на скорость выполнения. К сожалению, вы не узнаете неэффективный код на Лиспе, пока не разберетесь с языком. Вам нужно подумать о том, как работает Lisp, чтобы понять, что заставляет код на Lisp работать медленно. Это не сложно сделать, но эта проблема отличаются от тех, которые касаются языков, которые предоставляют вам больше информации о базовой машине.</P>

<P>Lisp предоставляет вам инкрементную компиляцию. Это означает, что вы можете компилировать по одной функции за раз и будьте готовы мгновенно запустить свою
программу - там нет шага связвания(linkage). Это означает, что вы можете быстро
внести множество изменений и оценить их влияние(выполнить их) на программу. 
Lisp также имеет встроенные инструменты, которые помогут вам настроить 
производительность вашей программы.</P>

<P>Вы испытаете все эти вещи, когда будете работать над этой книгой. К тому времени, когда вы закончите, вы будете знать, в первую очередь, как избежать написания неэффективного кода, и как использовать все доступные инструменты для идентификации 
и тонкой настройки действительно критического кода в ваших программах..</P>

<hr>
<h2>Никто больше не пишет программы на Лиспе.</h2> 

<P>Что? Я-единственный, кто остался? Нет, я так не думаю...</P>

<P>Серьезно, однако, есть довольно много людей, которые пишут Лисп-код каждый день. Они пишут программы, которые решают сложные задачи и дают своим работодателям стратегическое преимущество. Трудно найти хороших Лисп-программистов, готовых перейти к новому работодателю; те компании, которые используют Лисп, охраняют свое стратегическое преимущество, своих Лисп-программистов, весьма ревниво.</P>

<P>Так вот, в основном это правда, что вы не найдете Lisp в потребительских товарах, таких как электронные таблицы, базы данных, текстовые процессоры и игры. Но с другой стороны, это не та работа, которую Лисп делает лучше всего. Вы <em>найдете</em> Lisp
в продуктах, которые должны рассуждать о сложных системах и процессах и управлять ими, где способность надежно приходить к полезным выводам, основанным на сложных отношениях между множеством источников и видов данных, более важна, чем молниеносные численные вычисления или изящная графика (хотя современные системы Lisp довольно близко подходят к лидерам даже в последних двух категориях).</P>

<P>Lisp также используется в качестве языка расширения из-за его простого, последовательного синтаксиса и возможности для системных дизайнеров добавлять
новые функции в Lisp без написания заново целого языка. Редактор Emacs и 
программа для черчения AutoCAD являются двумя лучшими примерами такого 
использования Lisp.</P>

<P>И конечно, Лисп <em>по-прежнему</em> является языком, наиболее часто 
используемым для исследований в области искусственного интеллекта и 
продвинутого компьютерного языкового дизайна, но мы не будем касаться 
ни одной из этих тем в этой книге. Когда вы закончите эту книгу, у вас 
будут знания, необходимые для того, чтобы понять, какие проблемы вы должны 
решать с помощью Лиспа, и как подойти к разработке решения.</P>

<P>Да, и еще одно: это не совсем верно, что ни один продукт массового рынка 
не использует Lisp. Среда Microsoft "Bob" для наивных пользователей компьютеров
была разработана (и поставлена) на Лиспе.</P>

<hr>
<h2>Лисп не позволяет мне использовать графические интерфейсы.</h2> 

<P>Это ирония судьбы. Некоторые из первых графических пользовательских интерфейсов
появились на машинах Lisp в начале 1970-х гг. фактически, в 1995 г. вы все еще 
можете купить DOS адаптацию одной из этих ранних сред Lisp-с тем же GUI, что и двадцать лет назад..</P>

<P>Ведущие среды разработки Lisp для Windows и Macintosh поддерживают только 
часть графического интерфейса своей основной платформы. Можно добавить 
поддержку отсутствующих функций, но проще сделать это с помощью 
предпочтительного языка Microsoft и Apple: C++.</P>

<P>Если вы хотите иметь один и тот же графический пользовательский интерфейс 
в вашей программе Lisp, когда она работает на узлах Windows или Macintosh, 
вы можете найти по крайней мере две оконные среды Lisp, которые позволяют 
вам это сделать. Проблема в том, что графический интерфейс Lisp не будет 
знакома ни пользователям Mcintosh, ни пользователям Windows.</P>

<P>Если все, что вам нужно, - это быстрый, специфичный для платформы графический интерфейс для вашего компьютера.
Программа Lisp, любая из коммерческих сред Lisp обеспечит то, что вам нужно. Все они имеют графические интерфейсные конструкторы, которые позволяют создавать окна и диалоговые окна с помощью методов укажи и кликни (point and click) или 
перетащи и брось (drag and drop).
Только не ождайте многого на пути колокольчиков и свистков(ммм... свистоперделок).</P>

<hr>
<h2>Я не могу вызвать код написанный другими людьми из Лиспа.</h2> 

<P>Это в основном неправда. Большинство сред Lisp предоставляют вам 
возможность вызывать внешние подпрограммы с помощью соглашений о 
вызовах C или Pascal. Вы также можете вернуться в Lisp из внешней 
программы. Но если вы хотите вызвать C++ из Lisp, вам, вероятно, 
придется написать обертку C вокруг кода C++.</P>

<hr>
<h2>Сборщик мусора в Лиспе вызывает непредсказуемые паузы при запуске
моей программы.</h2> 

<P>Это, вероятно, должно быть рассмотрено в обсуждении "Лисп медленный", 
но есть достаточно интересных отступлений, чтобы было оправданно создание
этой темы. Лисп-программы создают мусор, уничтожая все ссылки на какой-либо
объект в памяти. В программе, написанной на каком-то другом языке, 
программист должен организовать освобождение памяти, занятой объектом, 
в то же самое время, когда последняя ссылка уничтожается. Если программа 
не может сделать это надежно, в программе есть <em>утечка памяти</em> - 
в конечном итоге всё пространство памяти программы может заполниться этими 
недостижимыми объектами и не оставить достаточно свободной памяти для 
продолжения работы программы. Если вы когда-либо писали сложную программу, 
которая выделяет и вручную перерабатывает большое количество динамической 
памяти, вы знаете, насколько сложной может быть эта проблема.</P>

<P>Lisp решает проблему утечки памяти, никогда не позволяя программисту 
освобождать неиспользуемую память. Идея здесь заключается в том, что 
компьютер может определить, когда блок памяти недоступен  очень точно. 
Этот недостижимый блок называется мусором, потому что он больше не полезен
ни для одной части программы. Сборщик мусора запускается автоматически, 
чтобы собрать все эти неиспользуемые блоки памяти и подготовить их 
к повторному использованию. Алгоритмы, которые делают это, очень сложны, 
но они встроены в вашу систему Lisp.</P>

<P>Исторически сбор мусора <em>был</em> медленным. Самые ранние сборщики мусора 
могли буквально запирать систему на несколько часов. Производительность была 
настолько низкой, что ранние Лисп-программисты работали с выключенной сборкой 
мусора до тех пор, пока у них полностью не заканчивалась память, а затем
запускали сборку мусора вручную и возвращались домой на остаток дня.</P>

<P>За последние двадцать лет было применено много хороших методов 
разработки программного обеспечения для повышения производительности
сборки мусора. Современные Лисп-системы собирают мусор почти непрерывно,
 понемногу за один раз, вместо того чтобы ждать и делать все это сразу. 
В результате даже на очень медленной настольной машине пауза для сбора 
мусора редко превышает одну-две секунды.</P>

<P>Далее в этой книге я расскажу о сборке мусора более подробно и покажу 
вам методы, позволяющие избежать создания мусора; чем меньше мусора создает
 ваша программа, тем меньше работы придется выполнять сборщику мусора.</P>

<hr>
<h2>Лисп-это огромный язык.</h2> 

<P>Если вы посмотрите на книгу <cite>Common Lisp: The Language</cite>, объем 
которой составляет около тысячи страниц, или на недавний (и более громоздкий) 
стандарт <cite>ANSI X3. 226: язык программирования Common Lisp</cite>, то легко
сформировать такое мнение. Однако, если учесть, что язык Lisp практически 
не имеет синтаксиса, а всего лишь пару десятков примитивных языковых элементов
(называемых специальными формами), то Lisp начинает выглядеть как 
<em>очень маленький</em> язык.</P>

<P>На самом деле, приведенные выше руководства в основном касаются описания того,
что в большинстве других языков назвали бы библиотечными функциями и,
в меньшей степени, средствами разработки. Возьмите руководство по языку 
для вашего любимого языка. Добавьте руководства для трех или четырех 
сторонних библиотек - утилиты разработки, причудливые структуры данных, 
обобщенный ввод-вывод и т. д. Возьмите все инструкции для ваших инструментов 
разработки - браузеры, инспекторы, отладчики и т. д. и бросьте их в 
растущую кучу. А теперь сосчитай страницы. Неужели тысяча страниц все еще 
кажутся вам слишком большой величиной?</P>

<P>К тому времени, как вы закончите эту книгу, вы будете знать, как найти то, что вам нужно в Lisp, с руководством или без него.</P>

<hr>
<h2>Лисп только для исследований в области искуственного интеллекта.</h2> 

<P>Это просто неправда. Лисп используется для больших проектов, которые должны
быть решены одним или несколькими программистами. Lisp также хорош для задач,
которые не очень четко определены или требуют некоторого экспериментирования,
чтобы найти правильное решение. Как оказалось, искусственный интеллект отвечает
всем этим критериям. Так же как и многие другие приложения: планирование рабочих
мест в цехах, транспортная маршрутизация, военная логистика, эхолот и 
сейсмологическое Эхо-извлечение признаков, торговля валютой, конфигурация 
компьютеров и компьютерных сетей, диагностика промышленных процессов и многое
другое. Это не массовые приложения, но они все еще приносят много денег 
(часто избегая затрат) для организаций, которые их разрабатывают.</P>

<hr>
<h2>Лисп не имеет хороших инструментов программирования.</h2> 

<P>Я надеюсь убедить вас в обратном. Несколько глав этой книги посвящены 
знакомству с многочисленными полезными инструментами, предоставляемыми средой
разработки Lisp.</P>

<hr>
<h2>Лисп использует слишком много памяти.</h2> 

<P>Системы разработки Lisp как на моем Mac, так и на моем ПК работают с 
комфортом везде, где есть от 4 до 8 мегабайт оперативной памяти. В крайнем 
случае-меньше. Интегрированные среды разработки C++ занимают от 12 до 20 мегабайт. 
Обе они имеют сопоставимые инструменты и средства.</P>

<hr>
<h2>Лисп использует слишком много дискового пространства.</h2> 

<P>Системы разработки Lisp как на моем Mac, так и на моем ПК используют 
значительно меньше дискового пространства, чем среды C++. Пространство 
Lisp на моем жестком диске использует минимум 5 мегабайт для одной системы
и максимум 30 мегабайт для другой системы, которая является общей средой программирования, включая встроенный файловый менеджер, текстовый процессор WYSIWYG, графическую программу, календарь встреч и (почти забыл) среду разработки Lisp. 
Системы C++ занимают от минимум 20 мегабайт до максимум 150 мегабайт.</P>

<hr>
<h2>Я не могу найти хороший компилятор Лиспа.</h2> 

<P>В зависимости от того, какой компьютер вы используете, это было 
проблемой еще год или два назад. И это правда, что на рынке Lisp нет 
большой конкуренции - вы можете пересчитать продавцов по пальцам одной руки. 
Поставщики, которые поддерживают рынок Lisp, как правило, существуют 
уже давно и имеют хорошую репутацию. По мере увеличения скорости и 
объема памяти настольных компьютеров производители Lisp все чаще 
обращают свое внимание на эти платформы.</P>

<hr>
<div align="center">
<a href="contents.html">Contents</a> | <a href="cover.html">Cover</a> <br> 
<a href="introduction.html">Introduction</a> | Chapter 1 | <a href="chapter02.html">Chapter 2</a> 
</div>
<hr>
<address>
Copyright &copy; 1995-2001, David B. Lamkins<br>
All Rights Reserved Worldwide<br>
<br>
This book may not be reproduced without the written consent of its 
author.  Online distribution is restricted to the author's site.
</address> 
</body> </html>