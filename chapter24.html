<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<title>Successful Lisp - Chapter 24</title>
</head> 

<body bgcolor="white" text="black">
<h1>Глава 24 - FORMAT Говорит на другом языке</h1> 

<P>На протяжении всей этой книги мы показали некоторые простые способы 
использования  <code>FORMAT</code> без объяснения причин. В этой главе 
мы проведем инвентаризацию и опишем наиболее полезные возможности  <code>FORMAT</code>,
а также некоторые из его наиболее эзотерических особенностей.

<h2>FORMAT рифмуется с FORTRAN, вроде как...</h2>

<p><code>FORMAT</code>  по-видимому, был вдохновлен разнообразной и 
мощной функцией FORTRAN с тем же названием. Но <code>FORMAT</code> Lisp 
реализует свой собственный язык программирования, разработанный специально 
для целей форматирования текстового вывода. <code>FORMAT</code> позволяет 
печатать данные многих типов, используя различные убранства и украшения. 
Он может печатать числа в виде слов или- для вас, любителей кино - в виде 
римских цифр. Вывод столбцами - это (breeze)бриз с возможностями <code>FORMAT</code> 
для итерации по спискам и продвижения к определенным позициям в выходной строке. 
Вы даже можете сделать так, чтобы части выходных данных отображались по-разному в
зависимости от форматированных переменных. Эта глава охватывает репрезентативную 
часть того, что может сделать <code>FORMAT</code>; вы должны обратиться к ссылке 
Lisp, чтобы получить полную историю.

<h2>Форматирование</h2>

<p><code>FORMAT</code>  предполагает, что  аргумент назначение(destination), 
управляющая строка формата и список из нуля или более аргументов будут использоваться 
управляющей строкой для получения форматированных выходных данных.


<p>
Выходные данные отправляются в место, определяемое аргументом 
назначения(destination). Если назначением является <code>T</code>, 
то вывод идет в <code>*STANDARD-OUTPUT*</code>. Конечным пунктом также 
может быть определенный поток вывода.

<p>
Существует два способа, с помощью которых <code>FORMAT</code> может отправлять 
выходные данные в строку. Один из них-указать <code>NIL</code> для назначения: 
<code>FORMAT</code> вернет строку, содержащую форматированный вывод. Другой способ
- указать в качестве назначения стороку; строка должна иметь указатель заполнения
(fill pointer).

<pre>
? (defparameter *s* 
    (make-array 0 
                :element-type 'character 
                :adjustable t 
                :fill-pointer 0))
""
? (format *s* "Hello~%")
NIL
? *s*
"Hello
"
? (format *s* "Goodbye")
NIL
? *s*
"Hello
Goodbye"
? (setf (fill-pointer *s*) 0)
0
? *s*
""
? (format *s* "A new beginning")
NIL
? *s*
"A new beginning"
</pre> 

<p>
Вызов <code>MAKE-ARRAY</code> с опциями, как показано выше, создает пустую строку, 
которая может расширяться для размещения новых выходных данных. Как вы можете видеть,
форматирование дополнительного вывода к этой строке добавляет новый вывод к тому, что 
уже есть. Чтобы очистить строку, вы можете либо сбросить ее указатель заполнения 
(fill pointer) (как показано на рисунке), либо создать новую пустую строку.


<p><code>FORMAT</code> возвращает <code>NIL</code>, за исключением случаев, 
когда адресат равен <code>NIL</code>.

<p>
Строка управления format содержит литеральный текст и директивы форматирования. 
Директивы всегда вводятся с символьным знаком <code>~</code>.

<pre>
  Directive   Interpretation
  ---------   --------------
     ~%       new line(новая строка)
     ~&       fresh line(свежая строка)
     ~|       page break(разрыв страницы)
     ~T       tab stop(табуляция)
     ~&lt;       justification(основание/выравнивание)
     ~&gt;       terminate(завершение) ~&lt;
     ~C       character(символьный знак)
     ~(       case conversion(преобразование регистра)
     ~)       terminate(завершение) ~(
     ~D       decimal integer(десятичное целое)
     ~B       binary integer(двоичное целое)
     ~O       octal integer(восмеричное целое)
     ~X       hexadecimal integer(шестнадцатеричное целое)
     ~bR      base-b integer (целое по основанию base-b)
     ~R       spell an integer( пишется целое число)
     ~P       plural(множество)
     ~F       floating point(число с плавающей запятой)
     ~E       scientific notation(научная запись)
     ~G       ~F или ~E,  в зависимости от величины magnitude()
     ~$       monetary(денежный формат)
     ~A       legibly, without escapes(разборчиво, без знаков экранирования)
     ~S       READably, with escapes(читаемо, со знаками экранирования)
     ~~       ~ (просто печатается тильда)
</pre> 

<p>
Первые несколько директив в приведенной выше таблице предназначены 
для создания пропусков. Директива <code>~%</code> вставляет знак 
новой строки. <code>~&amp;</code> вставляет знак новой строку только 
в том случае, если вывод <code>FORMAT</code> еще не находится в начале 
новой строки. <code>~|</code> генерирует знак разрыва страницы; не все 
устройства способны реагировать на этот знак. Вы можете заставить 
<code>FORMAT</code> выдавать несколько разрывов строк или страниц, 
используя необязательный аргумент, например <code>~5%</code>, который 
генерирует пять новых строк.


<p>Чтобы продвинуть вывод в столбец <i>n</i> путем вставки 
пропусков, используйте <code>~</code><i>n</i><code>T</code>.

<p>
Вы можете выровнять выходные данные, используя <code>~&lt;</code> и 
<code>~&gt;</code>, чтобы вложить выходные данные, подлежащие выравниванию.
<code>~</code><code>w</code><code>&lt;</code><i>text</i><code>~&gt;</code> 
правое выравнивание текста в поле ширины <i>n</i>. Если вы разбиваете/сегментируете
текст  с помощью <code>~;</code> в качестве разделителя, сегменты будут равномерно
распределены по полю ширины <i>w</i>.


<p>
<code>~C</code> формат символьного знака. Обычно этот знак форматирует 
себя сам. Однако если вы измените директиву на <code>~:C</code>, то будут 
выведены имена непечатаемых символов.

<pre>
? (format nil "~:C" 7)  <i>;; 7 is ASCII BEL</i> 
"Bell"
</pre> 

<p>
Вы можете изменить регистр у буквенных знаков, заключив выходные данные 
в <code>~(</code> и <code>~)</code>. Различные формы директивы приводят 
к различным результатам. <code>~(</code><i>text</i><code>~)</code> преобразует 
<i>text</i> в нижний регистр. <code>~:@(</code><i>text</i><code>~)</code>
преобразует <i>text</i> в верхний регистр. 
<code>~:(</code><i>text</i><code>~)</code> делает заглавной начальную букву
каждого слова в <i>text</i>. <code>~@(</code><i>text</i><code>~)</code> 
делает заглавной начальную букву первого слова в <i>text</i> и преобразует 
остальные в нижний регистр.

<p>
Директива <code>~D</code> форматирует целое число в виде десятичных цифр
с ведущим знаком минус, если число отрицательно. 
<code>~</code><i>w</i><code>D</code> - выравнивает справа вывод в поле
с шириной <i>w</i>, заполняя отступы слева с пробелами. 
<code>~</code><i>w</i><code>,'</code><i>c</i><code>D</code> заполняет слева 
знаком <i>c</i>. Добавление модификатора <code>@</code> сразу после <code>~</code>
приводит к тому, что печатается ведущий знак плюс для положительных чисел, а также
ведущий знак минус, который всегда печатается для отрицательных чисел. Модификатор
<code>:</code> вызывает вставку запятых между каждой группой из трех цифр.


<p>
Вы можете форматировать числа в двоичном (основание 2), восьмеричном 
(основание 8) или шестнадцатеричном (основание 16) основаниях, используя 
директивы <code>~B</code>, <code>~O</code>, и <code>~X</code> соответственно. 
За исключением основания, они ведут себя точно так, как <code>~D</code>.


<p>
Директива <code>~R</code> имеет две формы. <code>~</code><i>b</i><code>R</code>
печатает целое число по основанию <i>b</i>. Директива <code>~10R</code> идентична 
<code>~D</code>. Необязательные значения должны быть указаны после основания. 
Например, <i>~3,8R</i> выводит число по основанию - 3 в поле шириной 8.


<p>
Без спецификатора radix(основания) <code>~R</code> записывает целое число 
как кардинальное (счетное) число на английском языке.

<pre>
? (format nil "~R" 7)
"seven"
? (format nil "~R" 376)
"three hundred seventy-six"
</pre> 

<p><code>~:R</code> обозначает порядковый (позиционный) номер.

<pre>
? (format nil "~:R" 7)
"seventh"
</pre> 

<p>Вы даже можете печатать римские цифры с помощью <code>~@R</code>.

<pre>
? (format nil "~@R" 1999)
"MCMXCIX"
</pre> 

<p>
Одним из отличительных признаков профессионально выглядящего результата 
является правильное получение множественных чисел. Lisp делает это легко 
с помощью директивы формата <code>~P</code>. Если его аргумент не равен 1, 
<code>~P</code> форматирует букву "s". <code>~@P</code> форматирует "y", 
если его аргумент равен 1, или "ies", если аргумент не равен 1. 
Поскольку эти операции так часто следуют за печатью числа,
<code>~:P</code> и <code>~:@P</code>  повторно используют ранее 
использованный аргумент.

<pre>
? (format nil "~D time~:P, ~D fl~:@P" 1 1)
"1 time, 1 fly"
? (format nil "~D time~:P, ~D fl~:@P" 3 4)
"3 times, 4 flies"
</pre> 

<p>Вы можете печатать числа с плавающей запятой четырьмя 
различными способами:

<dl>
<dt><code>~F</code> 
<dd>Как число с десятичной точкой, например 723.0059
<dt><code>~E</code> 
<dd>В научной записи, например 7.230059E+2
<dt><code>~G</code> 
<dd>Как более короткое из двух приведенных выше представлений, за которым следует 
табуляция для выравнивания столбцов
<dt><code>~$</code> 
<dd>Как денежное значение, например 723.01
</dl> 

<p>
Существует множество вариантов печати чисел с плавающей запятой. 
Наиболее распространенным является спецификатор ширины поля, 
который ведет себя так же, как и в директиве <code>~D</code>.

<p>
Нечисловые данные Lisp печатаются с использованием директив <code>~A</code> и
<code>~S</code>. Используйте <code>~A</code>, когда вы хотите напечатать данные
в наиболее визуально привлекательной форме; то есть без escape-символов, которые
позволили бы правильно читать данные используя <code>READ</code>. При использовании
<code>~A</code> строки форматируются без кавычек, символы форматируются без префиксов
пакетов или экранирования для смешанных регистров или пустых знаков, а символьные
знаки печатаются как сами по себе. 
Используя <code>~S</code>, каждый объект Lisp печатается таким образом, что 
<code>READ</code> может реконструировать объект (если, конечно, объект имеет 
читаемое представление).

<h2>Итерация</h2>

<p>
Элементы списка могут быть отформатированы с помощью директивы 
<code>~{</code><i>format-control</i><code>~}</code>. Аргумент 
<em>должен быть</em> списком; <i>format-control</i> потребляет 
элементы списка. Итерация завершается, когда список пуст перед 
следующим переходом через <i>format-control</i>. Вот простой пример:

<pre>
? (format t "~&amp;Name~20TExtension~{~&amp;~A~20T~A~}"
          '("Joe" 3215 "Mary" 3246 "Fred" 3222 "Dave" 3232 "Joseph" 3212))
Name                Extension
Joe                 3215
Mary                3246
Fred                3222
Dave                3232
Joseph              3212
NIL
</pre> 

<p>
Если ваш список может закончиться в середине итерации <i>format-control</i>, 
вы можете вставить директиву <code>~^</code> в эту точку. Если список 
аргументов пуст при интерпретации директивы <code>~^</code>, то итерация 
<code>~{</code><i>format-control</i><code>~}</code> завершится в этой точке.


<p>
Дополнительные опции позволяют ограничить количество итераций и задать 
различные требования к аргументам. Для получения более подробной информации 
обратитесь к справочнику Lisp.

<h2>Условия(Conditionals)</h2>

<p>
Директивы условного формата вводятся через <code>~[</code> и разделяются через 
<code>~]</code>. Есть несколько форм, которые я буду называть порядковыми, 
двоичными и условными. Порядковая форма - это 
<code>~[</code><i>format-0</i><code>~;</code><i>format-1</i><code>~;</code><i>...</i><code>~;</code><i>format-N</i><code>~]</code>, которая выбирает предложение 
<i>format-Ith</i> для <i>I</i>-го значения аргумента. 

<pre>
? (format t "~[Lisp 1.5~;MACLISP~;PSL~;Common Lisp~]" 2)
PSL
NIL
</pre> 

<p>
В пределах <code>~[</code> и <code>~]</code> вы можете указать 
окончательное предложение <em>default</em>(по умолчанию) как 
<code>~:;</code><i>format-default</i>; оно выбирается, если аргумент 
находится вне диапазона от 0 до N.

<p>
Двоичная форма записывается 
<code>~:[</code><i>format-false</i><code>~;</code><i>format-true</i><code>~]</code>. Предложение <i>format-false</i>  интерпретируется, если аргумент равен <code>NIL</code>; 
в противном случае интерпретируется предложение <i>format-true</i>.

<pre>
? (format t "My computer ~:[doesn't~;does~] like Lisp." t)
My computer does like Lisp.
NIL
? (format t "My computer ~:[doesn't~;does~] like Lisp." nil)
My computer doesn't like Lisp.
NIL
</pre> 

<p>T
Условная форма, записанная как <code>~@[</code><i>format</i><code>~]</code>, 
сначала проверяет свой аргумент. Если аргумент не равен <code>NIL</code>,он не
потребляется; скорее, он остается для потребления <i>format</i>. Если аргумент 
равен <code>NIL</code>, то он потребляется и <i>format</i> не интерпретируется.

<pre>
? (format nil "~{~@[~A ~]~}" '(1 2 nil 3 t nil 4 nil))
"1 2 3 T 4"
</pre> 

<h2>Мутная пыль(Floobydust)</h2>

<p>
Как вы уже видели, многие директивы формата принимают необязательные параметры, 
такие как параметр ширины поля в директивах выравнивания, табуляции и числовых данных. 
В наших примерах эти параметры были закодированы в управляющую строку формата. 
Иногда бывает полезно, чтобы параметр менялся во время работы программы. 
Вы можете сделать это, указав <code>V</code>, где будет отображаться параметр; 
значение параметра затем берется из следующего аргумента в списке аргументов.

<pre>
? (format t "~{~&amp;~VD~}" '(5 37 10 253 15 9847 10 559 5 12))
   37
       253
           9847
       559
   12
NIL
</pre> 

<p>
В этом примере аргументы используются в парах, причем первый элемент из 
каждой пары указывает ширину поля, а второй - число для печати.

<hr>
<div align="center">
<a href="contents.html">Contents</a> | <a href="cover.html">Cover</a> <br> 
<a href="chapter23.html">Chapter 23</a> | Chapter 24 | <a href="chapter25.html">Chapter 25</a> 
</div>
<hr>
<address>
Copyright &copy; 1995-2001, David B. Lamkins<br>
All Rights Reserved Worldwide<br>
<br>
This book may not be reproduced without the written consent of its author.  Online distribution is restricted to the author's site.
</address> 
</body> </html>