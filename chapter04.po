#
# NuINu <don't@send.my>, 2020.
#
#. extracted from in/chapter04.html
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-04-19 13:50+0300\n"
"PO-Revision-Date: 2020-06-12 19:46+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: in/chapter04.html:5
msgid ""
"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/"
"html4/strict.dtd\">\n"
"<html><head>\n"
"<title>Successful Lisp - Chapter 4</title>\n"
"</head> "
msgstr ""
"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/"
"html4/strict.dtd\">\n"
"<html><head>\n"
"<META http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n"
"<title>Successful Lisp - Chapter 4</title>\n"
"</head> "

#: in/chapter04.html:8
msgid ""
"<body bgcolor=\"white\" text=\"black\">\n"
"<h1>Chapter 4 - Mastering the Essentials</h1> "
msgstr ""
"<body bgcolor=\"white\" text=\"black\">\n"
"<h1>Глава 4 - Овладение Основами</h1> "

#: in/chapter04.html:13
msgid ""
"<P>We've explored the fundamental concepts of Lisp through the \n"
"twelve lessons of <A HREF=\"chapter03.html\">Chapter 3</A>.  If you feel "
"that \n"
"you have a very strong grasp of these fundamentals, or if you've worked \n"
"with Lisp before, you may want to skim the remainder of this chapter.</P>"
msgstr ""
"<P>\n"
"Мы изучили основные понятия Лисп в двенадцати уроках \n"
"<A HREF=\"chapter03.html\">Главы 3</A>. Если вы чувствуете, что у вас есть \n"
"очень хорошее понимание этих основ, или если вы уже работали с Lisp "
"раньше, \n"
"вы можете просмотреть оставшуюся часть этой главы.\n"
"</P>"

#: in/chapter04.html:20
msgid ""
"<P>We'll review some of the material from <A HREF=\"chapter03.html"
"\">Chapter \n"
"3</A> using a hands-on approach.  Along the way, you'll learn some new \n"
"techniques that have had to wait until all of the fundamentals had been \n"
"introduced; if you're a beginner and haven't read <A \n"
"HREF=\"chapter03.html\">Chapter 3</A>, go back and read it before you try "
"to \n"
"do the exercises in this chapter.</P>"
msgstr ""
"<P>Мы рассмотрим некоторые материалы из \n"
"<A HREF=\"chapter03.html\">Главы 3</A>, используя практический подход. \n"
"По пути вы изучите некоторые новые техники, которые должны были подождать, \n"
"пока не будут введены все основные принципы; если вы новичок и не читали \n"
"<A HREF=\"chapter03.html\">Главу 3</A>, вернитесь и прочитайте ее, \n"
"прежде чем пытаться выполнять упражнения в этой главе.\n"
"</P>"

#: in/chapter04.html:29
msgid ""
"<P>You should have access to a Lisp development system as you work through \n"
"this chapter.  As you read this chapter, please take the time to run the \n"
"examples using your Lisp system.  This will give you a chance to learn how \n"
"your Lisp system responds to input, including any mistakes you may make.  \n"
"(If you don't make any mistakes in transcribing the examples, you should \n"
"get adventurous and try to modify some of the examples.)  <A \n"
"HREF=\"appendix-a.html\">Appendix A</A> lists several commercial, "
"shareware, \n"
"and free Lisp systems for Macintosh, DOS, and Windows computers.</P>"
msgstr ""
"<P>\n"
"Во время работы над этой главой вы должны иметь доступ к системе разработки\n"
"Lisp. Когда вы будете читать эту главу, пожалуйста, найдите время, чтобы\n"
"запустить примеры с помощью вашей системы Lisp. Это даст вам возможность\n"
"узнать, как ваша система Lisp реагирует на ввод данных, включая любые "
"ошибки,\n"
"которые вы можете сделать. (Если вы не допускаете никаких ошибок при\n"
"разборе примеров, вам следует набраться смелости и попытаться изменить\n"
"некоторые примеры. В <A HREF=\"appendix-a.html\">Приложении A</A> "
"перечислены\n"
"несколько коммерческих, условно-бесплатных и бесплатных систем Lisp для "
"компьютеров Macintosh, DOS и Windows.\n"
"</P>"

#: in/chapter04.html:32
msgid "<H2>Hands-on! The \"toploop\"</H2>"
msgstr "<H2>Руки-вверх! \"Главный(верхний) цикл\"</H2>"

#: in/chapter04.html:36
msgid ""
"<P>You interact with the Lisp system through a built-in piece of code \n"
"called the toploop, which repeats three simple steps for as long as you "
"run \n"
"the Lisp system:</P>"
msgstr ""
"<P>\n"
"Вы взаимодействуете с системой Lisp через встроенный фрагмент кода, \n"
"называемый toploop(верхний/главный цикл/REPL), который повторяет три "
"простых \n"
"шага до тех пор, пока работает ваша система Lisp:\n"
"</P>"

#: in/chapter04.html:42
msgid ""
"<PRE>\n"
"1. Read an expression (you provide the expression).\n"
"2. Evaluate the expression just read.\n"
"3. Print the result(s) of the evaluation.\n"
"</PRE>"
msgstr ""
"<PRE>\n"
"1. Read - Читает выражение (вы предоставляете выражение).\n"
"2. Evaluate - Исполняет только что прочитанное выражение.\n"
"3. Print - Печатает результат(ы) выполнения.\n"
"</PRE>"

#: in/chapter04.html:48
msgid ""
"<P>This is also called the \"read-eval-print\" loop.  Some Lisp systems "
"evaluate \n"
"the expression using a Lisp interpreter; modern systems use a compiling \n"
"evaluator, which first compiles the expression to machine code then "
"executes \n"
"the code.  A compiling evaluator is also an incremental compiler, so named \n"
"because it can compile a program in increments of one expression.</P>"
msgstr ""
"<P>\n"
"Это также называется циклом read-eval-print\" loop(REPL). Некоторые "
"системы \n"
"Lisp вычисляют выражение с помощью интерпретатора Lisp; современные системы\n"
"используют компилирующий вычислитель, который сначала компилирует \n"
"выражение в машинный код, а затем выполняет код. Компилирующий Вычислитель\n"
"также является инкрементным компилятором, названным так потому, что он "
"может\n"
"компилировать программу с шагом в одно выражение.\n"
"</P>"

#: in/chapter04.html:52
msgid ""
"<P>The toploop also provides a minimal user interface -- a prompt to "
"indicate \n"
"that it's ready to read a new expression -- and a way to gracefully catch "
"any \n"
"errors you might make.</P>"
msgstr ""
"<P>\n"
"Верхний цикл также предоставляет минимальный пользовательский интерфейс-\n"
"подсказку, указывающую, что он готов прочитать новое выражение , - \n"
"и способ изящно ловить любые ошибки, которые вы можете сделать.\n"
"</P>"

#: in/chapter04.html:55
msgid ""
"<P>If you were to write the Lisp code for a toploop, it would look "
"something \n"
"like this:</P>"
msgstr ""
"<P>\n"
"Если бы вы написали код Lisp для верхнего цикла, он выглядел бы примерно "
"так:\n"
"</P>"

#: in/chapter04.html:62
msgid ""
"<PRE>\n"
"(loop\n"
"   (terpri)\n"
"   (princ 'ready&gt;)\n"
"   (print (eval (read))))\n"
"</PRE>"
msgstr ""

#: in/chapter04.html:65
msgid ""
"<BLOCKQUOTE>\n"
"<P>NOTE 1: (terpri) prints a blank line.</P>"
msgstr ""
"<BLOCKQUOTE>\n"
"<P>Примечание 1: (terpri) выводит пустую строку.\n"
"</P>"

#: in/chapter04.html:68
msgid ""
"<P>NOTE 2: (loop ...)  executes its forms in order, then repeats -- we'll "
"see more \n"
"of <CODE>LOOP</CODE> in <A HREF=\"chapter05.html\">Chapter 5</A>.</P>"
msgstr ""
"<P>Примечание 2: (loop ...) выполняет свои формы по порядку, \n"
"а затем повторяет-мы увидим больше циклов(<CODE>LOOP</CODE>)\n"
"в <A HREF=\"chapter05.html\">главе 5</A>.\n"
"</P>"

#: in/chapter04.html:74
msgid ""
"<P>NOTE 3: (eval ...)  returns the result of evaluating a form.  This is one "
"of \n"
"the few legitimate uses of <CODE>EVAL</CODE> -- you should beware of Lisp "
"code \n"
"that uses <CODE>EVAL</CODE> for reasons other than evaluating arbitrary "
"Lisp \n"
"expressions provided at runtime.</P>\n"
"</BLOCKQUOTE>"
msgstr ""
"<P>Примечание 3: (eval ...) возвращает результат вычисления формы. \n"
"Это одно из немногих законных применений <CODE>EVAL</CODE> - вы должны\n"
"остерегаться кода Lisp, который использует <CODE>EVAL</CODE> по причинам,\n"
"отличным от вычисления произвольных выражений Lisp, предоставляемых во время "
"выполнения.\n"
"</P>\n"
"</BLOCKQUOTE>"

#: in/chapter04.html:82
msgid ""
"<P>In fact, you can type this into your Lisp system and temporarily run "
"your \n"
"own toploop <EM>on top of</EM> Lisp's toploop.  Try it!  You'll see your \n"
"system's prompt replaced with <TT>READY&gt;</TT>.  Every valid Lisp form you "
"type \n"
"will be read, evaluated, and printed by <EM>your</EM> toploop.  Depending "
"upon \n"
"your Lisp system, this may happen as soon as the expression is completed "
"-- \n"
"either by a space or a matching parenthesis or double quote mark -- or you "
"may \n"
"have to press the <TT>RETURN</TT> or <TT>ENTER</TT> key.</P>"
msgstr ""
"<P>\n"
"На самом деле, вы можете ввести это в свою систему Lisp и временно запустить "
"свой собственный верхний цикл поверх верхнего цикла Lisp. Попробуте! \n"
"Вы увидите, что приглашение вашей системы заменено на <TT>READY&gt;</TT>.\n"
"Каждая допустимая форма Lisp, которую вы введете, будет прочитана, \n"
"выполнена и напечатана вашим верхним циклом. В зависимости от вашей \n"
"системы Lisp, это может произойти, как только выражение будет завершено\n"
"- либо пробелом, либо соответствующей круглой скобкой или двойной кавычкой\n"
"- или вам, возможно, придется нажать клавишу \n"
" <TT>RETURN</TT> или <TT>ENTER</TT>.\n"
"</P>"

#: in/chapter04.html:85
msgid ""
"<P>Your Lisp session may look like the following, where <CODE>?</CODE> is "
"the \n"
"Lisp system's prompt for input:</P>"
msgstr ""
"<P>Ваш сеанс Lisp может выглядеть следующим образом, где <CODE>?</CODE>\n"
"является запросом системы Lisp на ввод данных:\n"
"</P>"

#: in/chapter04.html:91
msgid ""
"<PRE>\n"
"? (loop\n"
"     (terpri)\n"
"     (princ 'ready&gt;)\n"
"     (print (eval (read))))"
msgstr ""

#: in/chapter04.html:93
msgid "READY&gt;(+ 1 2 3)"
msgstr ""

#: in/chapter04.html:96
msgid ""
"6\n"
"READY&gt;(cons 1 (cons 2 (cons 3 nil)))"
msgstr ""

#: in/chapter04.html:100
msgid ""
"(1 2 3)\n"
"READY&gt;\n"
"</PRE>"
msgstr ""

#: in/chapter04.html:106
msgid ""
"<P>There are two ways to get out of your toploop.  One is to <EM>abort</"
"EM>, \n"
"typically using a special keystroke or a menu command -- consult your Lisp \n"
"system's manual.  The other way is to enter an erroneous expression -- such "
"as \n"
"<CODE>(+ 'A 1)</CODE> -- at the <TT>READY&gt;</TT> prompt, which will put "
"you into \n"
"the Lisp debugger.</P>"
msgstr ""
"<P>\n"
"Есть два способа выйти из вашего верхнего цикла. Один из них заключается в\n"
"прерывании, как правило, с помощью специального нажатия клавиши или \n"
"команды меню - обратитесь к руководству вашей системы Lisp. \n"
"Другой способ заключается в том, чтобы ввести ошибочное выражение - \n"
"например, <CODE>(+ 'A 1)</CODE> - в приглашении <TT>READY&gt;</TT>, \n"
"которое выбросит вас в отладчик Lisp.\n"
"</P>"

#: in/chapter04.html:112
msgid ""
"<P>In Lisp, the debugger is accessed via a \"break loop.\" This behaves just "
"like \n"
"a toploop, but accepts additional commands to inspect or alter the state of "
"the \n"
"\"broken\" computation.  Break loops vary widely among Lisp systems.  The "
"manual \n"
"will describe the break loop.  Check also under the manual's index entries "
"for \n"
"\"debugger.\"</P>"
msgstr ""
"<P>В Лиспе, отладчика доступны через \"break loop/обрыв цикла.\" Он ведет \n"
"себя так же, как верхний цикл, но принимает дополнительные команды \n"
"для проверки или изменения состояния \"broken/поврежденного\" вычисления. \n"
"\"break loop\" сильно различаются между системами Lisp. В руководстве "
"будет \n"
"описан \"break loop\". Проверьте также под индексными записями руководства "
"для \"отладчика.\"</P>"

#: in/chapter04.html:115
msgid "<H2>Spotting and avoiding common mistakes</H2>"
msgstr "<H2>Обнаружение и избежание распространенных ошибок</H2>"

#: in/chapter04.html:122
msgid ""
"<P>\"I entered a Lisp expression, but nothing happened.\"  The most common \n"
"cause of this problem is missing a matching delimiter -- typically a right \n"
"parenthesis or double-quote -- somewhere in your expression.  Unlike some\n"
"development systems which process your input each time you enter a line of\n"
"code, Lisp waits for you to enter a complete expression before attempting to "
"process \n"
"anything.  What happens if you enter the following code in your system?</P>"
msgstr ""
"<P>- Я ввел Лисп выражение, но ничего не произошло.\"Наиболее "
"распространенной\n"
"причиной этой проблемы является отсутствие соответствующего разделителя - \n"
"обычно это правая скобка или двойная кавычка- где-то в вашем выражении. \n"
"В отличие от некоторых систем разработки, которые обрабатывают ваш ввод \n"
"каждый раз, когда вы вводите строку кода, Lisp ждет, пока вы введете полное\n"
"выражение, прежде чем пытаться что-либо обработать. Что произойдет, если вы\n"
"введете в свою систему следующий код?</P>"

#: in/chapter04.html:128
msgid ""
"<PRE>\n"
"? (defun bad-1 ()\n"
"     (print \"This is a bad function definition)\n"
"     (print \"But I'll try it anyway...\"))\n"
"</PRE>"
msgstr ""

#: in/chapter04.html:136
msgid ""
"<P>Looks good, huh?  All the parentheses match, and you press the \n"
"<CODE>ENTER</CODE> key that one last time, and...  Nothing.  The string \n"
"argument to the first print statement is missing a closing double-quote, \n"
"turning the rest of your input into part of the string.  You'll do this \n"
"more than once (trust me), so the best thing to do is to consult your \n"
"Lisp system manual to find out how to edit the pending input so you can "
"add \n"
"the missing double-quote to what you've already typed.</P>"
msgstr ""
"<P>\n"
"Выглядит неплохо, да? Все скобки совпадают, и вы нажимаете клавишу \n"
"<CODE>ENTER</CODE> в последний раз, и... Ничего. В строковом аргументе "
"первого\n"
"оператора print отсутствует закрывающая двойная кавычка, что превращает\n"
"остальную часть ваших входных данных в часть строки. Вы будете так "
"ошибаться\n"
"не один раз (поверьте мне), поэтому лучше всего обратиться к вашему "
"руководству\n"
"по системе Lisp, чтобы узнать, как отредактировать ожидающий Ввод, чтобы вы "
"могли добавить недостающую двойную кавычку к тому, что вы уже набрали.\n"
"</P>"

#: in/chapter04.html:139
msgid ""
"<P>Here's another bit of code that will make your Lisp system appear to \n"
"sleep:</P>"
msgstr ""
"<P>Вот еще один кусок кода, который заставит вашу систему Lisp \n"
"казаться спящей:\n"
"</P>"

#: in/chapter04.html:145
msgid ""
"<PRE>\n"
"? (defun factorial (n)\n"
"     (cond ((&lt;= n 0)  1)\n"
"           (t (* n (factorial (- n 1)))))\n"
"</PRE>"
msgstr ""

#: in/chapter04.html:151
msgid ""
"<P>Again, a quick glance shows nothing amiss.  But count the parentheses \n"
"and you'll find that lefts outnumber rights by one.  When you press the \n"
"final enter key, the read part of Lisp's read-eval-print loop still needs \n"
"one more right parenthesis before it can finish its job and pass your \n"
"expression to the evaluator.</P>"
msgstr ""
"<P>\n"
"Опять же, быстрый просмотр не находит ничего плохого. Но посчитайте "
"скобки, \n"
"и вы обнаружите, что левые на единицу превосходят правых. Когда вы "
"нажимаете\n"
"последнюю клавишу enter, считывающая часть цикла чтения-выполнения-печати \n"
"Lisp все еще нуждается в еще одной правой скобке, прежде чем она сможет\n"
"закончить свою работу и передать ваше выражение вычислителю.\n"
"</P>"

#: in/chapter04.html:159
msgid ""
"<P>Both of these situations can be avoided if your Lisp system has an \n"
"editor that matches delimiters as you type.  In some systems, this \n"
"matching momentarily flashes the left delimiter as you type the matching \n"
"right delimiter.  Or your system might flash or highlight the matching \n"
"delimiter of whatever you have under the cursor; some systems even \n"
"highlight the entire intervening expression.  Again, check your manual -- \n"
"this feature is <STRONG>essential</STRONG> to comfortable Lisp programming.</"
"P>"
msgstr ""
"<P>\n"
"Обеих этих ситуаций можно избежать, если в вашей системе Lisp есть "
"редактор,\n"
"который соотносит разделители при вводе текста. В некоторых системах это\n"
"соответствие на мгновение мигает левым разделителем, когда вы вводите\n"
"соответствующий правый разделитель. Или ваша система может мигать или \n"
"выделять соответствующий разделитель того, что находится под курсором;\n"
"некоторые системы даже выделяют все промежуточное выражение. Еще раз \n"
"проверьте свое руководство - эта функция <STRONG>необходима</STRONG> \n"
"для комфортного программирования на Лиспе.\n"
"</P>"

#: in/chapter04.html:164
msgid ""
"<P>\"I get confused about when to use <CODE>'</CODE>.\"  This is a really \n"
"common problem for people just learning to program, but it manages to \n"
"puzzle the occasional experienced (non-Lisp) programmer as well.  The rule \n"
"is simple:</P>"
msgstr ""
"<P>Я путаюсь в том, когда использовать <CODE>'</CODE>\". Это действительно\n"
"распространенная проблема для людей, которые только учатся программировать,\n"
"но она умудряется озадачить и случайного Опытного (не Лиспового) "
"программиста.\n"
"Правило очень простое:\n"
"</P>"

#: in/chapter04.html:167
msgid ""
"<BLOCKQUOTE>\n"
"<P>If you want a name to stand for a value, <EM>don't</EM> quote it.</P>"
msgstr ""
"<BLOCKQUOTE>\n"
"<P>Если вы хотите, чтобы имя означало значение, <EM>Не</EM> \n"
"квотируйте его.\n"
"</P>"

#: in/chapter04.html:170
msgid ""
"<P>If you want a name to stand for its symbol, quote it.</P>\n"
"</BLOCKQUOTE>"
msgstr ""
"<P>Если вы хотите только имя установленное для символа, Квотируйте его.\n"
"</P>\n"
"</BLOCKQUOTE>"

#: in/chapter04.html:174
msgid ""
"<P>There are a few exceptions to the rule, all having to do with \n"
"self-evaluating symbols.  These symbols always represent themselves.  They \n"
"are:</P>"
msgstr ""
"<P>\n"
"Есть несколько исключений из этого правила, и все они связаны с \n"
"самовычисляющимися символами. Эти символы всегда представляют сами себя.\n"
"Ими являются:\n"
"</P>"

#: in/chapter04.html:179
msgid ""
"<PRE>\n"
"T\n"
"NIL\n"
"</PRE>"
msgstr ""

#: in/chapter04.html:184
msgid ""
"<P>and <EM>keyword</EM> symbols.  A keyword symbol is any symbol that \n"
"begins with a <CODE>:</CODE> character, for reasons that will become clear \n"
"when we look at <EM>packages</EM> in <A HREF=\"chapter31.html\">Chapter \n"
"31</A>.  A keyword symbol always evaluates to itself, thus:</P>"
msgstr ""
"<P>\n"
"и символы ключевые слова(<EM>keyword</EM>). Символ ключевое слово - \n"
"это любой символ, начинающийся со знака <CODE>:</CODE> по причинам, \n"
"которые станут ясны, когда мы рассмотрим <EM>пакеты</EM> в \n"
"<A HREF=\"chapter31.html\">Главе 31</A>. Символ ключевое слово всегда \n"
"вычисляется сам в себя, таким образом:\n"
"</P>"

#: in/chapter04.html:191
msgid ""
"<PRE>\n"
"? :foo\n"
":FOO\n"
"? :some-long-but-nondescript-keyword-symbol\n"
":SOME-LONG-BUT-NONDESCRIPT-KEYWORD-SYMBOL\n"
"</PRE>"
msgstr ""

#: in/chapter04.html:195
msgid ""
"<P>It usually doesn't hurt to quote a self-evaluating symbol.  For "
"example, \n"
"<CODE>NIL</CODE> is identical to <CODE>'NIL</CODE>.  Adding the quote is \n"
"a matter of style and preference.</P>"
msgstr ""
"<P>\n"
"Обычно квотирование не навредит самовычисляемому символу. \n"
"Например, <CODE>NIL</CODE> идентичен <CODE>'NIL</CODE>. \n"
"Добавление цитаты - это вопрос стиля и предпочтений.\n"
"</P>"

#: in/chapter04.html:197
msgid "<P>Time for a pop quiz!  What's wrong with the following code?</P>"
msgstr "<P>Время для поп-викторины! Что плохого в следующем коде?</P>"

#: in/chapter04.html:203
msgid ""
"<PRE>\n"
"? (defun factorial (n)\n"
"     (cond ((&lt;= 'n 0)  1)\n"
"           (t (* 'n (factorial (- 'n 1))))))\n"
"</PRE>"
msgstr ""

#: in/chapter04.html:207
msgid ""
"<P>Right.  The <CODE>'N</CODE> expressions are wrong, because we want the \n"
"value of the symbol (a number which varies with execution of the "
"function), \n"
"and <em>not</em> the symbol itself.</P>"
msgstr ""
"<P>Правильно. Выражения <CODE>'N</CODE> неверны, потому что нам нужно \n"
"значение символа (число, которое изменяется при выполнении функции), а \n"
"<em>не</em> сам символ.\n"
"</P>"

#: in/chapter04.html:210
msgid "<H2>Defining simple functions</H2>"
msgstr "<H2>Определение простых функций</H2>"

#: in/chapter04.html:215
msgid ""
"We've already seen a few function definitions: the\n"
"<code>FACTORIAL</code> function (above) and a function or two in <a\n"
"href=\"chapter03-07.html\">Chapter 3, Lesson 7</a>. To review, a\n"
"function is defined as follows:<p>"
msgstr ""
"Мы уже видели несколько определений функций: <code>FACTORIAL</code>\n"
"функция (выше) и одна или две функции в \n"
"<a href=\"chapter03-07.html\">Chapter 3, Lesson 7</a>.. Для обзора, функция "
"определяется следующим образом:\n"
"<p>"

#: in/chapter04.html:219
msgid ""
"<pre>\n"
"(defun <i>function-name</i> (<i>argument-names</i> ...)\n"
"   <i>function-body</i> )"
msgstr ""

#: in/chapter04.html:221
msgctxt "in/chapter04.html:221"
msgid "</pre> "
msgstr ""

#: in/chapter04.html:231
msgid ""
"The <code>(</code> <i>argument-names</i> <code>...)</code> is called\n"
"a <dfn>lambda list</dfn>. Names in this list are bound to values when\n"
"the function is called. The body of the function may refer to these\n"
"names; identical names appearing elsewhere in your program (that is,\n"
"outside the function body) are irrelevant to the function. Also, if\n"
"your function changes the binding of an argument inside the function,\n"
"the caller <em>does not</em> receive the changed value. The proper\n"
"way to return values from a Lisp function is to return them as the\n"
"value of the function.<p>"
msgstr ""
"<code>(</code> <i>argument-names</i> <code>...)</code> называется \n"
"лямбда-списком( <dfn>lambda list</dfn>). Имена в этом списке привязываются \n"
"к значениям при вызове функции. Тело функции может ссылаться на эти имена;\n"
"идентичные имена, появляющиеся в другом месте вашей программы (то есть вне \n"
"тела функции), не имеют отношения к функции. Кроме того, если ваша функция\n"
"изменяет привязку аргумента внутри функции, вызывающий объект не получает\n"
"измененное значение. Правильный способ вернуть значения из функции Lisp-это\n"
"вернуть их как значение функции.\n"
"<p>"

#: in/chapter04.html:233
msgid "For example:<p>"
msgstr "Например:<p>"

#: in/chapter04.html:241
msgid ""
"<pre>\n"
"? (defun quadratic-roots (a b c)\n"
"    \"Returns the roots of a quadratic equation aX^2 + bX + c = 0\"\n"
"    (let ((discriminant (- (* b b) (* 4 a c))))\n"
"      (values (/ (+ (- b) (sqrt discriminant)) (* 2 a))\n"
"              (/ (- (- b) (sqrt discriminant)) (* 2 a)))))\n"
"QUADRATIC-ROOTS"
msgstr ""

#: in/chapter04.html:245
msgid ""
"? (quadratic-roots 1 2 4)\n"
"#c(-1.0 1.7320508075688772)\n"
"#c(-1.0 -1.7320508075688772)"
msgstr ""

#: in/chapter04.html:249
msgid ""
"? (quadratic-roots 2 -16 36)\n"
"#c(4.0 1.4142135623730951)\n"
"#c(4.0 -1.4142135623730951)"
msgstr ""

#: in/chapter04.html:253
msgid ""
"? (quadratic-roots 1 4 4)\n"
"-2\n"
"-2"
msgstr ""

#: in/chapter04.html:257
msgid ""
"? (quadratic-roots 1 -14 49)\n"
"7\n"
"7"
msgstr ""

#: in/chapter04.html:261
msgid ""
"? (quadratic-roots 1 8 4)\n"
"-0.5358983848622456\n"
"-7.464101615137754"
msgstr ""

#: in/chapter04.html:265
msgid ""
"? (quadratic-roots 1 4 -5)\n"
"1\n"
"-5"
msgstr ""

#: in/chapter04.html:267
msgctxt "in/chapter04.html:267"
msgid "</pre> "
msgstr ""

#: in/chapter04.html:272
msgid ""
"The <code>QUADRATIC-ROOTS</code> function shows how to use a\n"
"documentation string. The first form in the function body is a\n"
"string. This does not affect the function result, but it <em>is</em>\n"
"recorded by the Lisp system for later reference:<p>"
msgstr ""
"Функция <code>QUADRATIC-ROOTS</code> показывает, как использовать \n"
"строку документации. Первая форма в теле функции-это строка. \n"
"Она не влияет на результат функции, но она записывается системой Lisp \n"
"для последующего использования:\n"
"<p>"

#: in/chapter04.html:276
msgid ""
"<pre>\n"
"? (documentation 'quadratic-roots 'function)\n"
"\"Returns the roots of a quadratic equation aX^2 + bX + c = 0\""
msgstr ""

#: in/chapter04.html:278
msgctxt "in/chapter04.html:278"
msgid "</pre> "
msgstr ""

#: in/chapter04.html:282
msgid ""
"This function also shows how we can return two values from a\n"
"function. You recognize the formula for the roots of a quadratic\n"
"equation:<p>"
msgstr ""
"Эта функция также показывает, как мы можем вернуть два значения из функции.\n"
"Вы узнаете формулу для корней квадратного уравнения:<p>"

#: in/chapter04.html:284
msgid "<pre>"
msgstr ""

#: in/chapter04.html:290
msgid ""
"             /--------\n"
"       +    /  2\n"
"   - b -  \\/  b  - 4ac\n"
" ----------------------\n"
"          2a"
msgstr ""

#: in/chapter04.html:292
msgctxt "in/chapter04.html:292"
msgid "</pre> "
msgstr ""

#: in/chapter04.html:297
msgid ""
"This tells you that the equation has two solutions (which may be\n"
"coincident in some cases). In Lisp it's a simple matter to return\n"
"both values at once using the form <code>(VALUES <i>value-1</i>\n"
"<i>value-2</i>)</code>.<p>"
msgstr ""
"Она говорит вам, что уравнение имеет два решения (которые в некоторых \n"
"случаях могут совпадать). В Lisp очень просто вернуть оба значения \n"
"сразу, используя форму <code>(VALUES <i>value-1</i>\n"
"<i>value-2</i>)</code>.<p>"

#: in/chapter04.html:303
msgid ""
"If you've ever solved this problem in a computer language that\n"
"doesn't support complex number arithmetic, you've had to find a way\n"
"to signal the caller when the roots are imaginary (i.e. when the\n"
"discriminant is less than zero). Lisp just does the right thing: the\n"
"square root of a negative number is a complex number:<p>"
msgstr ""
"Если вы когда-либо решали эту проблему на компьютерном языке, который \n"
"не поддерживает арифметику комплексных чисел, вам нужно было найти способ \n"
"подать сигнал вызывающему, когда корни являются мнимыми (т. е. когда \n"
"дискриминант меньше нуля). Lisp просто делает правильную вещь: \n"
"квадратный корень из отрицательного числа-это комплексное число:<p>"

#: in/chapter04.html:307
msgid ""
"<pre>\n"
"? (sqrt -1)\n"
"#c(0 1)"
msgstr ""

#: in/chapter04.html:309
msgctxt "in/chapter04.html:309"
msgid "</pre> "
msgstr ""

#: in/chapter04.html:314
msgid ""
"Suppose that you wanted <code>QUADRATIC-ROOTS</code> to only return\n"
"one value if the roots are coincident. Thinking that maybe you can\n"
"return <em>something</em> special as the second value of the\n"
"<code>VALUE</code> form, you try <code>NIL</code> : "
msgstr ""
"Предположим, что вы хотите, чтобы <code>QUADRATIC-ROOTS</code>\n"
"возвращала только одно значение, если корни совпадают. Думая, что, \n"
"возможно, вы можете вернуть что-то особенное в качестве второго значения\n"
"формы <code>VALUE</code>, вы пробуете <code>NIL</code> :\n"

#: in/chapter04.html:319
msgid ""
"<pre>\n"
"? (values 2 nil)\n"
"2\n"
"NIL"
msgstr ""

#: in/chapter04.html:321
msgctxt "in/chapter04.html:321"
msgid "</pre> "
msgstr ""

#: in/chapter04.html:325
msgid ""
"But that doesn't work, because <code>NIL</code> is a value like any\n"
"other in Lisp, and does not get special treatment like a nil pointer\n"
"would, for example, in another language.<p>"
msgstr ""
"Но это не работает, потому что <code>NIL</code>-это такое же значение, \n"
"как и любое другое в Lisp, и не получает специального обращения, как \n"
"указатель nil, например, в другом языке.\n"
"<p>"

#: in/chapter04.html:327
msgid ""
"So you think about only having one value in the <code>VALUES</code> form:"
msgstr ""
"Таким образом, вы думаете только об одном значении в форме <code>VALUES</"
"code>:"

#: in/chapter04.html:331
msgid ""
"<pre>\n"
"? (values 3)\n"
"3"
msgstr ""

#: in/chapter04.html:333
msgctxt "in/chapter04.html:333"
msgid "</pre> "
msgstr ""

#: in/chapter04.html:336
msgid ""
"Sure enough, that works. So why not <code>(VALUES <i>value-1</i>\n"
"<i>some-form-that-returns-nothing</i>)</code>?  Like this:<p>"
msgstr ""
"Конечно же, это работает. Так почему бы неработает \n"
"<code>(VALUES <i>value-1</i> \n"
"<i>некоторая форма-которая-ничего-не-возвращает</i>)</code>? Подобно этому\n"
"<p>"

#: in/chapter04.html:339
msgid ""
"<pre>\n"
"? (values)"
msgstr ""

#: in/chapter04.html:343
msgid ""
"? (values 4 (values))\n"
"4\n"
"NIL"
msgstr ""

#: in/chapter04.html:345
msgctxt "in/chapter04.html:345"
msgid "</pre> "
msgstr ""

#: in/chapter04.html:353
msgid ""
"Unfortunately, this doesn't do what you expect; the outer\n"
"<code>VALUES</code> form expects a value from its second argument,\n"
"<code>(VALUES)</code>, and substitutes <code>NIL</code> for the\n"
"missing value. This is one of the important rules of multiple values.\n"
"The other rule is that forms which receive multiple values (see <a\n"
"href=\"chapter03-09.html\">Chapter 3, Lesson 9)</a> substitute\n"
"<code>NIL</code> for a missing value.<p>"
msgstr ""
"К сожалению, это не делает того, что вы ожидаете; внешняя форма \n"
"<code>VALUES</code> ожидает значение от своего второго аргумента,\n"
"<code>(VALUES)</code> и заменяет отсутствующее значение на <code>NIL</"
"code>.\n"
"Это одно из важных правил множественных значений. \n"
"Другое правило заключается в том, что формы, получающие несколько значений \n"
"(см. <a href=\"chapter03-09.html\">Глава 3, Урок 9)</a>), заменяют "
"недостающее\n"
"значение <code>NIL</code>.\n"
"<p>"

#: in/chapter04.html:357
msgid ""
"A little reflection convinces you that you can't get\n"
"<code>VALUES</code> to return nothing for something, so you consider\n"
"having two separate returns. This yields the following function:<p>"
msgstr ""
"Небольшое размышление убеждает вас, что вы не можете получить \n"
"<code>VALUES</code>, которые ничего не возвращают для чего-то, \n"
"поэтому вы рассматриваете возможность иметь два отдельных возврата. \n"
"Это дает следующая функция:<p>"

#: in/chapter04.html:371
msgid ""
"<pre>\n"
"? (defun quadratic-roots-2 (a b c)\n"
"    \"Returns the roots of a quadratic equation aX^2 + bX + c = 0.\n"
"Returns only one value if the roots are coincident.\"\n"
"    (let ((discriminant (- (* b b) (* 4 a c))))   ; zero if one root\n"
"      (cond ((zerop discriminant)\n"
"             ;; coincident roots -- return one value\n"
"             (/ (+ (- b) (sqrt discriminant)) (* 2 a)))\n"
"            (t\n"
"             ;; two distinct roots\n"
"             (values (/ (+ (- b) (sqrt discriminant)) (* 2 a))\n"
"                     (/ (- (- b) (sqrt discriminant)) (* 2 a)))))))\n"
"QUADRATIC-ROOTS-2"
msgstr ""

#: in/chapter04.html:374
msgid ""
"? (quadratic-roots-2 1 -14 49)\n"
"7"
msgstr ""

#: in/chapter04.html:378
msgid ""
"? (quadratic-roots-2 1 4 -5)\n"
"1\n"
"-5"
msgstr ""

#: in/chapter04.html:380
msgctxt "in/chapter04.html:380"
msgid "</pre> "
msgstr ""

#: in/chapter04.html:386
msgid ""
"<blockquote> NOTE: <code>ZEROP</code> is a <i>predicate</i> (hence\n"
"the <code>P</code> suffix) that is true when its numeric argument is\n"
"zero. Writing <code>(ZEROP <i>n</i>)</code> is the same as writing\n"
"<code>(= <i>n</i> 0)</code>. \n"
"</blockquote> "
msgstr ""
"<blockquote> Примечание: <code>ZEROP</code> это <i>предикат/predicate</i> \n"
"(отсюда суффикс <code>P</code>) которые возвращает истину когда его\n"
"числовой аргумент равен нулю. Запись <code>(ZEROP <i>n</i>)</code> это тоже\n"
"самое что и запись <code>(= <i>n</i> 0)</code>. \n"
"</blockquote> "

#: in/chapter04.html:389
msgid ""
"Note how <code>QUADRATIC-ROOTS-2</code> has a two-line documentation\n"
"string. The newline is part of the string:<p>"
msgstr ""
"Обратите внимание, что <code>QUADRATIC-ROOTS-2</code> имеет две строки\n"
"документации. Новая строка является частью строки:\n"
"<p>"

#: in/chapter04.html:394
msgid ""
"<pre>\n"
"? (documentation 'quadratic-roots-2 'function)\n"
"\"Returns the roots of a quadratic equation aX^2 + bX + c = 0.\n"
"Returns only one value if the roots are coincident.\""
msgstr ""

#: in/chapter04.html:396
msgctxt "in/chapter04.html:396"
msgid "</pre> "
msgstr ""

#: in/chapter04.html:403
msgid ""
"Also note the use of comments to describe the two return choices. In\n"
"Lisp, a comment begins with a semicolon and continues until the end\n"
"of the line. By convention, comments on a line of their own within a\n"
"function body are indented to the same level as the rest of the code\n"
"and prefixed by two semicolons. A comment on the same line as code\n"
"only has one semicolon (again, by convention).<p>"
msgstr ""
"Также обратите внимание на использование комментариев для описания двух \n"
"вариантов возврата. В Lisp комментарий начинается с точки с запятой и\n"
"продолжается до конца строки. По общему правилу комментарии к собственной\n"
"строке в теле функции отступаются на тот же уровень, что и остальная часть \n"
"кода, и предваряются двумя точками с запятой. Комментарий к той же строке, \n"
"что и код, имеет только одну точку с запятой (опять же, по соглашению).\n"
"<p>"

#: in/chapter04.html:407
msgid ""
"A lambda list can have a number of additional features. We'll look at\n"
"two of these here, and the rest in <a href=\"chapter21.html\">Chapter\n"
"21</a>.<p>"
msgstr ""
"Лямбда-список может иметь ряд дополнительных функций. Мы рассмотрим два \n"
"из них здесь, а остальные-в <a href=\"chapter21.html\">Главе 21</a>.\n"
"<p>"

#: in/chapter04.html:411
msgid ""
"If you want to make a function that takes one or more optional\n"
"arguments, use the <code>&amp;OPTIONAL</code> keyword followed by a list\n"
"of parameter names, like this:<p>"
msgstr ""
"Если вы хотите создать функцию, которая принимает один или несколько\n"
"необязательных аргументов, используйте ключевое слово \n"
"<code>&amp;OPTIONAL</code>, за которым следует список имен \n"
"параметров, например:\n"
"<p>"

#: in/chapter04.html:416
msgid ""
"<pre>\n"
"? (defun silly-list-1 (p1 p2 &amp;optional p3 p4)\n"
"    (list p1 p2 p3 p4))\n"
"SILLY-LIST-1"
msgstr ""

#: in/chapter04.html:419
msgid ""
"? (silly-list-1 'foo 'bar)\n"
"(FOO BAR NIL NIL)"
msgstr ""

#: in/chapter04.html:422
msgid ""
"? (silly-list-1 'foo 'bar 'baz)\n"
"(FOO BAR BAZ NIL)"
msgstr ""

#: in/chapter04.html:425
msgid ""
"? (silly-list-1 'foo 'bar 'baz 'rux)\n"
"(FOO BAR BAZ RUX)"
msgstr ""

#: in/chapter04.html:427
msgctxt "in/chapter04.html:427"
msgid "</pre> "
msgstr ""

#: in/chapter04.html:431
msgid ""
"The optional parameters default to NIL when the call does not supply\n"
"a value. Peek ahead to <a href=\"chapter21.html\">Chapter 21</a> to see\n"
"how to change the default value of an optional parameter.<p>"
msgstr ""
"Необязательные параметры по умолчанию равны  NIL, если вызов не "
"предоставляет значения. Загляните вперед в <a href=\"chapter21.html\">Главу "
"21</a>, \n"
"чтобы узнать, как изменить значение по умолчанию необязательного \n"
"параметра.\n"
"<p>"

#: in/chapter04.html:436
msgid ""
"If you supply fewer than the number of required parameters (to the\n"
"left of <code>&amp;OPTIONAL</code> in the example above), or more than\n"
"the total number of required plus optional parameters, you'll get an\n"
"error:<p>"
msgstr ""
"Если вы укажете меньше, чем количество обязательных параметров (слева от "
"<code>&amp;OPTIONAL</code>  в приведенном выше примере), или больше, \n"
"чем общее количество обязательных плюс необязательные параметры, \n"
"вы получите ошибку:\n"
"<p>"

#: in/chapter04.html:440
msgid ""
"<pre>\n"
"? (silly-list-1 'foo)\n"
"Error: Not enough arguments."
msgstr ""

#: in/chapter04.html:443
msgid ""
"? (silly-list-1 'foo 'bar 'baz 'rux 'qup)\n"
"Error: Too many arguments."
msgstr ""

#: in/chapter04.html:445
msgctxt "in/chapter04.html:445"
msgid "</pre> "
msgstr ""

#: in/chapter04.html:449
msgid ""
"If you want to have an indefinite number of parameters, you can name\n"
"one parameter to receive a list of all the \"extras\" using the\n"
"<code>&amp;REST</code> symbol in the lambda list, like this:<p>"
msgstr ""
"Если вы хотите иметь неопределенное количество параметров, вы можете \n"
"назвать один параметр, чтобы получить список всех \"дополнительных\", \n"
"используя символ <code>&amp;REST</code> в лямбда-списке, например:\n"
"<p>\n"

#: in/chapter04.html:453
msgid ""
"<pre>\n"
"? (defun silly-list-2 (p1 p2 &amp;rest p3)\n"
"    (list p1 p2 p3))"
msgstr ""

#: in/chapter04.html:456
msgid ""
"? (silly-list-2 'foo 'bar)\n"
"(FOO BAR NIL)"
msgstr ""

#: in/chapter04.html:459
msgid ""
"? (silly-list-2 'foo 'bar 'baz)\n"
"(FOO BAR (BAZ))"
msgstr ""

#: in/chapter04.html:462
msgid ""
"? (silly-list-2 'foo 'bar 'baz 'bob 'tom 'don)\n"
"(FOO BAR (BAZ BOB TOM DON))"
msgstr ""

#: in/chapter04.html:464
msgctxt "in/chapter04.html:464"
msgid "</pre> "
msgstr ""

#: in/chapter04.html:468
msgid ""
"The <code>&amp;REST</code> parameter must follow all of the required\n"
"parameters. You can combine <code>&amp;REST</code> and\n"
"<code>&amp;OPTIONAL</code> parameters, observing the following order:<p>"
msgstr ""
"Параметр <code>&amp;REST</code> должен соответствовать всем необходимым\n"
"параметрам. Вы можете комбинировать <code>&amp;REST</code> и \n"
"<code>&amp;OPTIONAL</code> дополнительные параметры, соблюдая следующий "
"порядок:<p>"

#: in/chapter04.html:473
msgid ""
"<pre>\n"
"? (defun silly-list-3 (p1 p2 &amp;optional p3 p4 &amp;rest p5)\n"
"    (list p1 p2 p3 p4 p5))\n"
"SILLY-LIST-3"
msgstr ""

#: in/chapter04.html:476
msgid ""
"? (silly-list-3 'foo 'bar)\n"
"(FOO BAR NIL NIL NIL)"
msgstr ""

#: in/chapter04.html:479
msgid ""
"? (silly-list-3 'foo 'bar 'baz)\n"
"(FOO BAR BAZ NIL NIL)"
msgstr ""

#: in/chapter04.html:482
msgid ""
"? (silly-list-3 'foo 'bar 'baz 'bob)\n"
"(FOO BAR BAZ BOB NIL)"
msgstr ""

#: in/chapter04.html:485
msgid ""
"? (silly-list-3 'foo 'bar 'baz 'bob 'tom)\n"
"(FOO BAR BAZ BOB (TOM))"
msgstr ""

#: in/chapter04.html:488
msgid ""
"? (silly-list-3 'foo 'bar 'baz 'bob 'tom 'don)\n"
"(FOO BAR BAZ BOB (TOM DON))"
msgstr ""

#: in/chapter04.html:490
msgctxt "in/chapter04.html:490"
msgid "</pre> "
msgstr ""

#: in/chapter04.html:493
msgid ""
"<h2><a name=\"global-vars-and-consts\">Using global variables and constants</"
"a> </h2> "
msgstr ""
"<h2><a name=\"global-vars-and-consts\">Использование глобальных переменных и "
"констант</a> </h2> "

#: in/chapter04.html:498
msgid ""
"In <a href=\"chapter03-03.html\">Lesson 3</a>, we used\n"
"<code>SETQ</code> to define global variables. You can do this using a\n"
"top-level form, as in <a href=\"chapter03-03.html\">Lesson 3</a>, or\n"
"from within a function, such as this:<p>"
msgstr ""
"В <a href=\"chapter03-03.html\">Уроке 3</a> мы использовали <code>SETQ</"
"code>\n"
"для определения глобальных переменных. Вы можете сделать это с помощью формы "
"верхнего уровня, как в <a href=\"chapter03-03.html\">Уроке 3</a>, или из "
"функции, такой как эта:<p>"

#: in/chapter04.html:503
msgid ""
"<pre>\n"
"? (defun set-foo-globally (x)\n"
"    (setq foo x))\n"
"SET-FOO-GLOBALLY"
msgstr ""

#: in/chapter04.html:506
msgid ""
"? foo\n"
"Error: unbound variable FOO"
msgstr ""

#: in/chapter04.html:509
msgid ""
"? (set-foo-globally 3)\n"
"3"
msgstr ""

#: in/chapter04.html:512
msgid ""
"? foo\n"
"3"
msgstr ""

#: in/chapter04.html:514
msgctxt "in/chapter04.html:514"
msgid "</pre> "
msgstr ""

#: in/chapter04.html:517
msgid ""
"Depending upon your Lisp system, you may have seen a warning message\n"
"when you defined <code>SET-FOO-GLOBALLY</code>:<p>"
msgstr ""
"В зависимости от вашей системы Lisp, вы могли видеть предупреждающее \n"
"сообщение, когда вы определили  <code>SET-FOO-GLOBALLY</code>:<p>"

#: in/chapter04.html:523
msgid ""
"<pre>\n"
"? (defun set-foo-globally (x)\n"
"    (setq foo x))\n"
"Warning: undeclared free variable FOO, in SET-FOO-GLOBALLY.\n"
"SET-FOO-GLOBALLY"
msgstr ""

#: in/chapter04.html:525
msgctxt "in/chapter04.html:525"
msgid "</pre> "
msgstr ""

#: in/chapter04.html:532
msgid ""
"This is not an error -- the function does what we want. But\n"
"<code>FOO</code> is said to be free because the function does not\n"
"create a binding for <code>FOO</code>. Variable bindings are created\n"
"by lambda lists (the function's argument list) and by\n"
"<code>LET</code> forms (see <a href=\"chapter03-06.html\">Lesson\n"
"6</a>), among others.<p>"
msgstr ""
"Это не ошибка - функция делает то, что мы хотим. Но <code>FOO</code>\n"
"считается свободным, потому что функция не создает привязку для \n"
"<code>FOO</code>. Привязки переменных создаются, в частности, с \n"
"помощью лямбда-списков (списка аргументов функции) и форм \n"
"<code>LET</code> (см. <a href=\"chapter03-06.html\">Урок 6</a>).\n"
"<p>"

#: in/chapter04.html:535
msgid ""
"My Lisp system warns me about free variables in function definitions\n"
"because they could be a symptom of a typographical error:<p>"
msgstr ""
"Моя система Lisp предупреждает меня о свободных переменных в определениях\n"
"функций, потому что они могут быть признаком типографской ошибки:\n"
"<p>"

#: in/chapter04.html:539
msgid ""
"<pre>\n"
"? (setq *olympic-year* 1996)\n"
"1996"
msgstr ""

#: in/chapter04.html:544
msgid ""
"? (defun set-next-olympic-year ()\n"
"    (setq *olympic-year* (+ *olmpic-year* 2)))\n"
"Warning: undeclared free variable *OLMPIC-YEAR*, in SET-NEXT-OLYMPIC-YEAR.\n"
"SET-NEXT-OLYMPIC-YEAR"
msgstr ""

#: in/chapter04.html:546
msgctxt "in/chapter04.html:546"
msgid "</pre> "
msgstr ""

#: in/chapter04.html:552
msgid ""
"Here, I misspelled the second instance of my global variable\n"
"<code>*OLYMPIC-YEAR*</code>, and the compiler warned me. Notice that\n"
"I didn't get a warning for the correctly spelled\n"
"<code>*OLYMPIC-YEAR*</code> because I had defined it globally in a\n"
"top-level <code>SETQ</code> form.<p>"
msgstr ""
"Здесь я неправильно написал второй экземпляр моей глобальной переменной \n"
"<code>*OLYMPIC-YEAR*</code>, и компилятор предупредил меня. \n"
"Обратите внимание, что я не получил предупреждения за правильно написанный\n"
"<code>*OLYMPIC-YEAR*</code>, потому что я определил его глобально в форме\n"
"<code>SETQ</code> верхнего уровня.\n"
"<p>"

#: in/chapter04.html:554
msgid "There are two more ways to define global variables in Lisp:<p>"
msgstr ""
"Существует еще два способа определения глобальных переменных в Lisp:\n"
"<p>"

#: in/chapter04.html:558
msgid ""
"<pre>\n"
"? *var1*\n"
"Error: unbound variable"
msgstr ""

#: in/chapter04.html:561
msgid ""
"? (defvar *var1* 1)\n"
"*VAR1*"
msgstr ""

#: in/chapter04.html:564
msgctxt "in/chapter04.html:564"
msgid ""
"? *var1*\n"
"1"
msgstr ""

#: in/chapter04.html:567
msgid ""
"? (defvar *var1* 2)\n"
"*VAR1*"
msgstr ""

#: in/chapter04.html:570
msgctxt "in/chapter04.html:570"
msgid ""
"? *var1*\n"
"1"
msgstr ""

#: in/chapter04.html:573
msgid ""
"? (defparameter *a-var* 3)\n"
"*A-VAR*"
msgstr ""

#: in/chapter04.html:576
msgid ""
"? *a-var*\n"
"3"
msgstr ""

#: in/chapter04.html:579
msgid ""
"? (defparameter *a-var* 4)\n"
"*A-VAR*"
msgstr ""

#: in/chapter04.html:582
msgid ""
"? *a-var*\n"
"4"
msgstr ""

#: in/chapter04.html:584
msgctxt "in/chapter04.html:584"
msgid "</pre> "
msgstr ""

#: in/chapter04.html:592
msgid ""
"<code>DEFVAR</code> sets a global value only the first time -- in\n"
"other words, the variable must not have a value in order for\n"
"<code>DEFVAR</code> to have an effect. This is useful for a variable\n"
"that needs to have an initial value, but shouldn't be reset if you\n"
"re-evaluate the <code>DEFVAR</code> form (as you might if you reload\n"
"the file containing the <code>DEFVAR</code> in addition to other\n"
"code).<p>"
msgstr ""
"<code>DEFVAR</code> устанавливает глобальное значение только в певый раз-\n"
"другими словами, переменная не должна иметь значения, чтобы <code>DEFVAR</"
"code>\n"
"возимел эффект. Это полезно для переменной, которая должна иметь начальное\n"
"значение, но не должна быть сброшена, если вы повторно вычислите форму\n"
"<code>DEFVAR</code> (как это бывает, если вы перезагружаете файл, содержащий "
"<code>DEFVAR</code> в дополнение к другому коду).\n"
"<p>"

#: in/chapter04.html:599
msgid ""
"<code>DEFPARAMETER</code> sets a global value each time it is used.\n"
"Although the effect is the same as a <code>SETQ</code> form, the\n"
"<code>DEFPARAMETER</code> is preferable because it gives implicit\n"
"documentation as a <i>defining form</i> (in Lisp, any form that\n"
"begins with <code>DEF</code> is most likely a defining form), and\n"
"because it allows you to add documentation to the variable:<p>"
msgstr ""
"<code>DEFPARAMETER</code>  устанавливает глобальное значение каждый раз, \n"
"когда он используется. Хотя эффект такой же как у <code>SETQ</code> формы,\n"
"<code>DEFPARAMETER</code> является предпочтительным, поскольку он дает "
"неявное\n"
"документирование как определяющая форма(<i>defining form</i>) (в Лиспе, "
"любая\n"
"форма, которая начинается со слова <code>DEF</code>, скорее всего, \n"
"является определяющей формой), и поэтому, что она позволяет добавлять \n"
"документацию к переменной:<p>"

#: in/chapter04.html:603
msgid ""
"<pre>\n"
"? (defparameter *a-var* 3 \"The number of things I have to do today.\")\n"
"*A-VAR*"
msgstr ""

#: in/chapter04.html:606
msgid ""
"? (documentation '*a-var* 'variable)\n"
"\"The number of things I have to do today.\""
msgstr ""

#: in/chapter04.html:608
msgctxt "in/chapter04.html:608"
msgid "</pre> "
msgstr ""

#: in/chapter04.html:610
msgid ""
"You can also add a documentation string to a <code>DEFVAR</code> form.<p>"
msgstr ""
"Вы также можете добавить строку документации в форму <code>DEFVAR</code>.\n"
"<p>"

#: in/chapter04.html:615
msgid ""
"In the examples above, we've started following the convention of\n"
"making global variable names begin and end with an asterisk. When you\n"
"read other programmers' Lisp code, you'll see that they follow this\n"
"convention. They'll expect you to do the same.<p>"
msgstr ""
"В приведенных выше примерах мы начали следовать условию, согласно которому \n"
"имена глобальных переменных начинаются и заканчиваются звездочкой. \n"
"Когда вы читаете Лисп-код других программистов, вы увидите, что они \n"
"следуют этому соглашению. Они будут ожидать, что вы сделаете то же самое.\n"
"<p>"

#: in/chapter04.html:624
msgid ""
"<code>DEFCONSTANT</code> is similar to <code>DEFVAR</code> and\n"
"<code>DEFPARAMETER</code>, except that it defines a name which is\n"
"known globally and has a <i>constant</i> value. This means that\n"
"anywhere you read a name which was defined in a\n"
"<code>DEFCONSTANT</code> form, you can substitute the value given by\n"
"the <code>DEFCONSTANT</code> form. It also means that you can't\n"
"redefine the named constant, not even by using another\n"
"<code>DEFCONSTANT</code> form with a different value.<p>"
msgstr ""
"<code>DEFCONSTANT</code> аналогичен <code>DEFVAR</code> и\n"
"<code>DEFPARAMETER</code>, за исключением того, что он определяет имя, \n"
"которое известно глобально и имеет постоянное значение. \n"
"Это означает, что везде, где вы читаете имя, которое было определено \n"
"в форме <code>DEFCONSTANT</code>, вы можете заменить значение, \n"
"заданное формой <code>DEFCONSTANT</code>. Это также означает, что \n"
"вы не можете переопределить именованную константу, даже используя \n"
"другую форму <code>DEFCONSTANT</code> с другим значением.\n"
"<p>"

#: in/chapter04.html:631
msgid ""
"Some Lisp programmers give constants names which begin and end with\n"
"plus signs. It's helpful to name constants in a distinctive way so\n"
"you don't inadvertently try to use the name for another purpose. Once\n"
"a name has been defined constant, you can't even use it for a\n"
"seemingly innocuous use, such as a parameter in a lambda list or\n"
"<code>LET</code> binding.<p>"
msgstr ""
"Некоторые Лисп-программисты дают константам имена, которые начинаются и\n"
"заканчиваются знаками плюс. Полезно называть константы особым образом, \n"
"чтобы вы случайно не попытались использовать это имя для другой цели. \n"
"После того, как имя было определено константой, вы не можете даже \n"
"использовать его для кажущегося безобидным использования, такого как \n"
"параметр в лямбда-списке или привязке <code>LET</code>.\n"
"<p>"

#: in/chapter04.html:633
msgid "<h2>Defining recursive functions</h2> "
msgstr "<h2>Определение рекурсивных функций</h2> "

#: in/chapter04.html:638
msgid ""
"A function that calls itself is <em>recursive</em>. The recursive\n"
"call may be direct (the function calls itself) or indirect (the\n"
"function calls another function which -- perhaps after calling still\n"
"more functions -- calls the original function).<p>"
msgstr ""
"Функция, которая сама себя вызывает, является рекурсивной(<em>recursive</"
"em>).\n"
"Рекурсивный вызов может быть прямым (функция вызывает саму себя) или \n"
"косвенным (функция вызывает другую функцию, которая-возможно, после \n"
"вызова еще некоторого числа функций-вызывает исходную функцию).\n"
"<p>"

#: in/chapter04.html:643
msgid ""
"You need to follow two simple rules of thumb to make recursive\n"
"functions work. These rules suggest the structure of a recursive\n"
"function -- it must behave appropriately according to its current\n"
"inputs:<p>"
msgstr ""
"Вам нужно следовать двум простым эмпирическим правилам, чтобы заставить\n"
"рекурсивные функции работать. Эти правила предполагают структуру "
"рекурсивной\n"
"функции - она должна вести себя соответствующим образом в соответствии со с\n"
"воими текущими входными данными:<p>"

#: in/chapter04.html:649
msgid ""
"<ol>\n"
"<li>One case must <em>not</em> make a recursive call.\n"
"<li>Other cases must <em>reduce</em> the amount of work to be done in a\n"
" recursive call.\n"
"</ol> "
msgstr ""
"<ol>\n"
"<li>Один случай <em>не</em> должен выполнять рекурсивный вызов.\n"
"<li>В других случаях необходимо <em>уменьшить</em> объем работы, \n"
"выполняемой при рекурсивном вызове.\n"
"</ol> "

#: in/chapter04.html:651
msgid ""
"Let's dig up the <code>FACTORIAL</code> function that we've already used in "
"several examples, and see how it follows these rules:"
msgstr ""
"Давайте возьмем функцию <code>FACTORIAL</code>, которую мы уже "
"использовали \n"
"в нескольких примерах, и посмотрим, как она следует этим правилам:"

#: in/chapter04.html:657
msgid ""
"<pre>\n"
"(defun factorial (n)\n"
"  (cond ((zerop n) 1)\n"
"        (t (* n (factorial (1- n))))))\n"
"</pre> "
msgstr ""

#: in/chapter04.html:667
msgid ""
"This function has two cases, corresponding to the two branches of the\n"
"<code>COND</code>. The first case says that the factorial of zero is\n"
"just one -- no recursive call is needed. The second case says that\n"
"the factorial of some number is the number multiplied by the\n"
"factorial of one less than the number -- this is a recursive call\n"
"which reduces the amount of work remaining because it brings the\n"
"number closer to the terminating condition of the first\n"
"<code>COND</code> clause. (For clarity, I've assumed that the number\n"
"initially given to <code>FACTORIAL</code> is non-negative.)<p>"
msgstr ""
"Эта функция имеет два случая, соответствующие двум ветвям <code>COND</"
"code>.\n"
"Первый случай говорит о том, что факториал нуля-это всего лишь единица, \n"
"и никакого рекурсивного вызова не требуется. Второй случай говорит, \n"
"что факториал некоторого числа-это число, умноженное на факториал на \n"
"единицу меньшего числа, - это рекурсивный вызов, который уменьшает \n"
"количество оставшейся работы, потому что он приближает число к \n"
"завершающему условию первого предложения <code>COND</code>. (Для ясности я\n"
"предположил, что число, изначально данное <code>FACTORIAL</code>,\n"
"неотрицательно.)\n"
"<p>"

#: in/chapter04.html:676
msgid ""
"Let's work through another simple recursive definition. The length of\n"
"an empty list is zero. The length of a non-empty list is one plus the\n"
"length of the list reduced by one element. These two statements state\n"
"exactly what is required by our rules of thumb, above. The first\n"
"statement gives the answer for a list of known length -- the trivial\n"
"case of an empty list. The second statement gives the answer for a\n"
"list of unknown length <em>in terms of the answer for a list of\n"
"reduced length</em>. Here's how it translates into code:<p>"
msgstr ""
"Давайте рассмотрим еще одно простое рекурсивное определение. Длина пустого \n"
"списка равна нулю. Длина непустого списка равна единице плюс длина списка,\n"
"уменьшенная на один элемент. Эти два утверждения точно указывают на то, \n"
"что требуется по нашим эмпирическим правилам, приведенным выше. \n"
"Первое утверждение дает ответ для списка известной длины - тривиальный \n"
"случай - пустой список. Второе утверждение дает ответ для списка \n"
"неизвестной длины в терминах ответа для списка уменьшенной длины. \n"
"Вот как это переводится в код:\n"
"<p>"

#: in/chapter04.html:682
msgid ""
"<pre>\n"
"? (defun my-length (list)\n"
"    (cond ((null list) 0)\n"
"          (t (1+ (my-length (rest list))))))\n"
"MY-LENGTH"
msgstr ""

#: in/chapter04.html:685
msgid ""
"? (my-length '(a b c d))\n"
"4"
msgstr ""

#: in/chapter04.html:687
msgctxt "in/chapter04.html:687"
msgid "</pre> "
msgstr ""

#: in/chapter04.html:695
msgid ""
"<code>NULL</code> is true for an empty list, so the first\n"
"<code>COND</code> clause returns zero for the empty list. The second\n"
"<code>COND</code> clause gets evaluated (if the first clause if\n"
"skipped) because its condition is <code>T</code>; it adds one to the\n"
"result of the recursive call on a list which is one element shorter\n"
"(a list consists of its <code>FIRST</code> element and the\n"
"<code>REST</code> of the list.)<p>"
msgstr ""
"<code>NULL</code> является истинным для пустого списка, поэтому первое\n"
"предложение <code>COND</code> возвращает ноль для пустого списка. \n"
"Второе предложение <code>COND</code> вычисляется (если первое предложение\n"
"пропущено), потому что его условие равно <code>T</code>; оно добавляет один\n"
"к результату рекурсивного вызова списка, который на один элемент короче \n"
"(список состоит из его первого(<code>FIRST</code>) элемента и остальной\n"
"(<code>REST</code>) части списка.)\n"
"<p>"

#: in/chapter04.html:701
msgid ""
"Note the similarities between <code>FACTORIAL</code> and\n"
"<code>MY-LENGTH</code>. The base case is always the first in the\n"
"<code>COND</code> because it must be tested <em>before</em> the\n"
"recursive case -- otherwise, the recursive function calls would never\n"
"end.<p>"
msgstr ""
"Обратите внимание на сходство между <code>FACTORIAL</code> и \n"
"<code>MY-LENGTH</code>. Базовый случай всегда является первым в \n"
"<code>COND</code>, потому что он должен быть проверен <em>перед</em> \n"
"рекурсивным случаем - в противном случае рекурсивные вызовы функций\n"
"никогда бы не закончились.<p>"

#: in/chapter04.html:704
msgid ""
"If you want to visualize how recursive calls work, you can use you\n"
"Lisp system's <code>TRACE</code> macro:<p>"
msgstr ""
"Если вы хотите визуализировать, как работают рекурсивные вызовы, \n"
"вы можете использовать макрос трассировки(<code>TRACE</code>) вашей \n"
"системы Lisp:<p>"

#: in/chapter04.html:708
msgid ""
"<pre>\n"
"? (trace my-length)\n"
"NIL"
msgstr ""

#: in/chapter04.html:721
msgid ""
"? (my-length '(a b c d))\n"
"; Calling (MY-LENGTH (A B C D)) \n"
";  Calling (MY-LENGTH (B C D)) \n"
";   Calling (MY-LENGTH (C D)) \n"
";    Calling (MY-LENGTH (D)) \n"
";     Calling (MY-LENGTH NIL) \n"
";     MY-LENGTH returned 0\n"
";    MY-LENGTH returned 1\n"
";   MY-LENGTH returned 2\n"
";  MY-LENGTH returned 3\n"
"; MY-LENGTH returned 4\n"
"4"
msgstr ""

#: in/chapter04.html:723
msgctxt "in/chapter04.html:723"
msgid "</pre> "
msgstr ""

#: in/chapter04.html:728
msgid ""
"Here, you can clearly see the recursive calls upon lists of\n"
"decreasing length, the terminating call with the empty list\n"
"(<code>NIL</code>), and the returns each adding one to the length of\n"
"a shorter list.<p>"
msgstr ""
"Здесь вы можете ясно видеть рекурсивные вызовы списков уменьшающейся \n"
"длины, завершающий вызов с пустым списком (<code>NIL</code>) и возврат \n"
"каждого из них, добавляющий единицу к длине более короткого списка.\n"
"<p>"

#: in/chapter04.html:735
msgid ""
"<blockquote> NOTE: Your Lisp compiler may internally optimize the\n"
"recursive calls to <code>MY-LENGTH</code> so you don't see them using\n"
"<code>TRACE</code>. If this happens, you may be able to disable the\n"
"optimization by evaluating the form <code>(DECLAIM (OPTIMIZE (SPEED\n"
"0) (DEBUG 3)))</code>, then re-evaluating the <code>(DEFUN MY-LIST\n"
"...)</code> form.</blockquote> "
msgstr ""
"<blockquote> Примечание: ваш компилятор Lisp может внутренне оптимизировать\n"
"рекурсивные вызовы <code>MY-LENGTH</code>, так что вы не увидите их с "
"помощью\n"
"трассировки(<code>TRACE</code>). Если это произойдет, вы можете отключить\n"
"оптимизацию, вычислив форму <code>(DECLAIM (OPTIMIZE (SPEED\n"
"0) (DEBUG 3)))</code>, а затем повторно вычислив форму\n"
"<code>(DEFUN MY-LIST ...)</code>.\n"
"</blockquote> "

#: in/chapter04.html:738
msgid ""
"<a name=\"tail-recursion\"></a> \n"
"<h2>Tail recursion</h2> "
msgstr ""
"<a name=\"tail-recursion\"></a> \n"
"<h2>Хвостовая/Tail рекурсия</h2> "

#: in/chapter04.html:743
msgid ""
"A function that calls itself as its very last action is said to make\n"
"a tail-recursive call. Here are two versions of the factorial\n"
"function to illustrate the difference between a tail-recursive call\n"
"and an ordinary recusive call:<p>"
msgstr ""
"Вызов функции, которая вызывает себя в качестве своего самого \n"
"последнего действия, называется хвостовым рекурсивным вызовом. \n"
"Вот две версии  функции расчета факториала, чтобы проиллюстрировать \n"
"разницу между хвостовым рекурсивным вызовом и обычным рекурсивным \n"
"вызовом:\n"
"<p>"

#: in/chapter04.html:746
msgid ""
"<pre>\n"
"<i>; Normal recursive call</i> "
msgstr ""

#: in/chapter04.html:752
msgid ""
"(defun factorial (n)\n"
"  (cond ((zerop n) 1)\n"
"        (t (*      <i>; * is the last function called</i> \n"
"            n\n"
"            (factorial (- n 1))))))"
msgstr ""

#: in/chapter04.html:754
msgid "<i>; Tail-recursive call</i> "
msgstr ""

#: in/chapter04.html:757
msgid ""
"(defun factorial-tr (n)\n"
"  (factorial-tr-helper n 1))"
msgstr ""

#: in/chapter04.html:763
msgid ""
"(defun factorial-tr-helper (n product)\n"
"  (cond ((zerop n) product)\n"
"        (t \n"
"         <i>; factorial-tr-helper is the last function called</i> \n"
"         (factorial-tr-helper (- n 1) (* product n)))))"
msgstr ""

#: in/chapter04.html:765
msgctxt "in/chapter04.html:765"
msgid "</pre> "
msgstr ""

#: in/chapter04.html:775
msgid ""
"<code>FACTORIAL-TR</code> calls <code>FACTORIAL-TR-HELPER</code>,\n"
"passing the original argument, <code>N</code>, plus an additional\n"
"argument used as the initial value of an accumulator for the product\n"
"which will become the value of the factorial calculation.\n"
"<code>FACTORIAL-TR-HELPER</code> calls itself recursively,\n"
"decrementing <code>N</code> in the process (this moves the\n"
"calculation closer to its terminating condition, <code>(ZEROP\n"
"N)</code>) and at the same time multiplying the product by the\n"
"current value of <code>N</code>.<p>"
msgstr ""
"<code>FACTORIAL-TR</code> вызывает <code>FACTORIAL-TR-HELPER</code>,\n"
"передавая исходный аргумент <code>N</code>, плюс дополнительный аргумент,\n"
"используемый в качестве начального значения накопителя(accumulator) \n"
"для расчета  результата, который станет значением расчета факториала. \n"
"<code>FACTORIAL-TR-HELPER</code> вывает себя рекурсивно, уменьшая \n"
"<code>N</code> в процессе (это приближает вычисление к его конечному \n"
"условию, <code>(ZEROP N)</code>)) и в то же время умножая произведение \n"
"на текущее значение <code>N</code>.\n"
"<p>"

#: in/chapter04.html:782
msgid ""
"Because <code>FACTORIAL-TR-HELPER</code> is the last function\n"
"executed in the recursive call, this is a tail-recursive call.\n"
"Compare this to the recursive call in the <code>FACTORIAL</code>\n"
"function, where the result is used by <code>*</code> to produce the\n"
"function's value. A recursive call is tail-recursive only if it is\n"
"the very last function executed in the recursive invocation.<p>"
msgstr ""
"Поскольку <code>FACTORIAL-TR-HELPER</code> является последней выполняемой\n"
"функцией при рекурсивном вызове, это хвостовой рекурсивный вызов. \n"
"Сравните его с рекурсивным вызовом предыдущий факториальной функции, \n"
"где результат используется функцией <code>*</code> для получения \n"
"значения функции. Рекурсивный вызов является хвосто-рекурсивным только \n"
"в том случае, если он является самой последней функцией, выполняемой в "
"рекурсивном вызове.\n"
"<p>"

#: in/chapter04.html:788
msgid ""
"With all that explanation out of the way, you're probably wondering\n"
"\"What good is tail-recursion? For the factorial calculation, it only\n"
"seemed to complicate the code.\" The answer is in two parts: what Lisp\n"
"can do <em>for</em> you, and what Lisp can do <em>to</em> you in the\n"
"presence of tail-recursion.<p>"
msgstr ""
"После всего этого объяснения вы, вероятно, задаетесь вопросом: \n"
"\"Что хорошего в хвостовой рекурсии? Для  расчета факториала это только \n"
"усложнило код.\" Ответ состоит из двух частей: что Лисп может сделать \n"
"<em>для</em> вас, и что Лисп может сделать <em>для</em> вас в присутствии\n"
"хвостовой рекурсии.\n"
"<p>"

#: in/chapter04.html:799
msgid ""
"Some Lisp compilers can optimize tail-recursive calls. To understand\n"
"the benefits of such an optimization, let's first look at what a\n"
"compiler must do for a normal function call: it must generate code to\n"
"evaluate the arguments and push them on a stack (where they can be\n"
"found by the called function), save the address in the code to which\n"
"control will return after the recursive call, and finally call the\n"
"function. One implication of this code sequence is that a function\n"
"which makes a lot of recursive calls (as <code>FACTORIAL</code> will\n"
"do for large value of <code>N</code>) will use a lot of stack space\n"
"-- normally a limited resource.<p>"
msgstr ""
"Некоторые компиляторы Lisp могут оптимизировать хвостовые рекурсивные "
"вызовы.\n"
"Чтобы понять преимущества такой оптимизации, давайте сначала рассмотрим, "
"что\n"
"должен делать компилятор для обычного вызова функции: он должен "
"генерировать\n"
"код для вычисления аргументов и помещать их в стек (где они могут быть "
"найдены\n"
"вызываемой функцией), сохранить адрес в коде, к какому элемент управления\n"
"вернется после рекурсивного вызова, и, наконец, вызывать функцию. Одним из\n"
"следствий этой кодовой последовательности является то, что функция, которая\n"
"делает много рекурсивных вызовов (как это делает <code>FACTORIAL</code> \n"
"для большого значения <code>N</code>), будет использовать много стекового\n"
"пространства-обычно очень ограниченного ресурса.\n"
"<p>"

#: in/chapter04.html:807
msgid ""
"A compiler that optimizes tail-recursive calls will generate code to\n"
"perform the following operations for a tail-recursive call: evaluate\n"
"the arguments and replace the old argument values with those just\n"
"calculated, and then jump to the beginning of the function. Note that\n"
"this code does not use any additional stack space, and it invokes the\n"
"function with a jump instead of a call instruction -- this is a less\n"
"expensive operation on all computers.<p>"
msgstr ""
"Компилятор, оптимизирующий хвостовые рекурсивные вызовы, генерирует код\n"
"для выполнения следующих операций для хвостового рекурсивного вызова: \n"
"вычисление аргументов и замена старых значений аргументов только что\n"
"вычисленными, а затем переход к началу функции. Обратите внимание, \n"
"что этот код не использует никакого дополнительного пространства стека, \n"
"и вызывает функцию с помощью jump вместо инструкции call - это менее\n"
"дорогостоящая операция на всех компьютерах.<p>"

#: in/chapter04.html:812
msgid ""
"So, that's the answer to the first question, \"What can Lisp do\n"
"<em>for</em> me if I write a tail-recursive function call?\" You get\n"
"more efficient code -- <strong>if</strong> the compiler performs that\n"
"optimization; it is not required to do so, but the better ones do.<p>"
msgstr ""
"Итак, это ответ на первый вопрос: \"что Лисп может сделать <em>для</em> "
"меня,\n"
"если я напишу вызов хвосто-рекурсивной функции?\" Вы получаете более \n"
"эффективный код, если компилятор выполняет эту оптимизацию; это \n"
"не обязательно, но лучшие из них делают это.\n"
"<p>"

#: in/chapter04.html:819
msgid ""
"Tail recursion optimization sounds like a good thing. It must be --\n"
"it produces faster code -- but it it may confuse you during\n"
"debugging. The debugger normally displays each function call by\n"
"looking at the stack frame created at entry to the function. So if\n"
"you happen to break in the middle of a recursive function, you'd\n"
"expect to see a stack frame for each recursive call:<p>"
msgstr ""
"Оптимизация хвостовой рекурсии звучит как хорошая вещь. Она должна\n"
"производить более быстрый код - но она может сбить вас с толку во \n"
"время отладки. Отладчик обычно отображает каждый вызов функции, глядя \n"
"на кадр стека, созданный при входе в функцию. Таким образом, если \n"
"вы случайно вылетаете(break) из середины рекурсивной функции, вы \n"
"ожидаете увидеть кадр стека для каждого рекурсивного вызова:\n"
"<p>"

#: in/chapter04.html:826
msgid ""
"<pre> \n"
"? (defun broken-factorial (n)\n"
"    (cond ((= n 0) 1)\n"
"          ((= n 1) (break))\n"
"          (t (* n (broken-factorial (- n 1))))))\n"
"BROKEN-FACTORIAL"
msgstr ""

#: in/chapter04.html:829
msgid ""
"? (broken-factorial 6)\n"
"; Break: While executing: BROKEN-FACTORIAL"
msgstr ""

#: in/chapter04.html:840
msgid ""
"&gt; (backtrace)\n"
"1: (BROKEN-FACTORIAL 1)\n"
"2: (BROKEN-FACTORIAL 2)\n"
"3: (BROKEN-FACTORIAL 3)\n"
"4: (BROKEN-FACTORIAL 4)\n"
"5: (BROKEN-FACTORIAL 5)\n"
"6: (BROKEN-FACTORIAL 6)\n"
"7: <i>... more stack frames, unrelated to BROKEN-FACTORIAL ...</i> \n"
"&gt; (abort)\n"
"; Return to top level"
msgstr ""

#: in/chapter04.html:844
msgid ""
"? (defun broken-tr-factorial (n)\n"
"    (broken-tr-factorial-1 n 1))\n"
"BROKEN-TR-FACTORIAL"
msgstr ""

#: in/chapter04.html:850
msgid ""
"? (defun broken-tr-factorial-1 (n v)\n"
"    (cond ((= n 0) v)\n"
"          ((= n 1) (break))\n"
"          (t (broken-tr-factorial-1 (- n 1) (* n v)))))\n"
"BROKEN-TR-FACTORIAL"
msgstr ""

#: in/chapter04.html:853
msgid ""
"? (broken-tr-factorial 6)\n"
"; Break: While executing: BROKEN-TR-FACTORIAL-1"
msgstr ""

#: in/chapter04.html:857
msgid ""
"&gt; (backtrace)\n"
"1: (broken-tr-factorial-1 1)\n"
"2: <i>... more stack frames, unrelated to BROKEN-TR-FACTORIAL ...</i> "
msgstr ""

#: in/chapter04.html:859
msgctxt "in/chapter04.html:859"
msgid "</pre> "
msgstr ""

#: in/chapter04.html:867
msgid ""
"So what happened to all the recursive calls in\n"
"<code>BROKEN-TR-FACTORIAL-1</code>? For that matter, what happened to\n"
"the call to <code>BROKEN-TR-FACTORIAL</code>? The compiler did tail\n"
"recursion elimination in <code>BROKEN-TR-FACTORIAL-1</code>,\n"
"replacing function calls with jumps. The function only generated one\n"
"stack frame, then the tail-recursive calls replaced the values in\n"
"that frame for subsequent calls.<p>"
msgstr ""
"Так что же случилось со всеми рекурсивными вызовами в \n"
"<code>BROKEN-TR-FACTORIAL-1</code>? Если уж на то пошло, то что же \n"
"случилось со вызовом <code>BROKEN-TR-FACTORIAL-1</code>? Компилятор \n"
"сделал исключение хвостовой рекурсии в <code>BROKEN-TR-FACTORIAL-1</code>,\n"
"заменив вызовы функций jump переходами. Функция генерировала только \n"
"один кадр стека, а затем хвостовые рекурсивные вызовы заменяли \n"
"значения в этом кадре для последующих вызовов.\n"
"<p>"

#: in/chapter04.html:874
msgid ""
"The compiler also noticed that <code>BROKEN-TR-FACTORIAL</code> calls\n"
"<code>BROKEN-TR-FACTORIAL-1</code> and immediately returns its value.\n"
"This is just another tail-recursive call. The compiler arranged to\n"
"build the stack frame using the value provided for the call to\n"
"<code>BROKEN-TR-FACTORIAL</code> and the constant 1; there was no\n"
"need to generate a stack frame for <code>BROKEN-TR-FACTORIAL</code>.<p>"
msgstr ""
"Компилятор также заметил, что <code>BROKEN-TR-FACTORIAL</code> вызывает \n"
"<code>BROKEN-TR-FACTORIAL-1</code> и немедленно возвращает его значение. \n"
"Это просто еще один хвосто-рекурсивный вызов. Компилятор организовал \n"
"построение кадра стека, используя значение, предоставленное для вызова \n"
"<code>BROKEN-TR-FACTORIAL</code> и константу 1; не было никакой \n"
"необходимости генерировать кадр стека для <code>BROKEN-TR-FACTORIAL</code>.\n"
"<p>"

#: in/chapter04.html:883
msgid ""
"I mention all of this because you may think that your compiler is\n"
"broken the first time you encounter a backtrace with \"missing\"\n"
"frames. Compilers that do tail recursion usually give you a way to\n"
"disable that optimization; consult the manual for details. You're\n"
"probably better off, however, learning to recognize tail recursion,\n"
"and how to read backtraces in the presence of this optimization. Some\n"
"code which relies on tail recursion could break (by overflowing the\n"
"stack) if you disable the optimization.<p>"
msgstr ""
"Я упоминаю все это, потому что вы можете подумать, что ваш компилятор \n"
"сломан, когда вы в первый раз сталкиваетесь с при обратной трассировке\n"
"с \"отсутствующими\" кадрами. Компиляторы, которые делают хвостовую "
"рекурсию,\n"
"обычно дают вам способ отключить эту оптимизацию; обратитесь к руководству\n"
"для получения подробной информации. Однако вам, вероятно, лучше научиться\n"
"распознавать хвостовую рекурсию и читать обратную трассировку вызовов в\n"
"присутствии этой оптимизации. Некоторый код, который полагается на "
"хвостовую\n"
"рекурсию, может сломаться(переполняя стек), если вы отключите оптимизацию.\n"
"<p>"

#: in/chapter04.html:886
msgid "<h2>Exercises in naming</h2> "
msgstr "<h2>Упражнения по именованию</h2> "

#: in/chapter04.html:896
msgid ""
"A name in Lisp can be made of any non-whitespace characters except\n"
"for certain characters reserved as reader macro characters (see <a\n"
"href=\"chapter03-11.html\">Chapter 3, Lesson 11</a>), namely\n"
"<code>\"</code>, <code>'</code>, <code>(</code>, <code>)</code>,\n"
"<code>,</code>, <code>;</code>, <code>`</code>, and <code>#</code>.\n"
"Furthermore, the name can't be a number in the current number base,\n"
"as set by <code>*READ-BASE*</code>. Thus, FACE is a name when\n"
"<code>*READ-BASE*</code> is 10, but a number when\n"
"<code>*READ-BASE*</code> is 16 (or higher).<p>"
msgstr ""
"Имя в Lisp может быть создано из любых знаков, не являющихся пробелами,\n"
"за исключением некоторых знаков, зарезервированных в качестве макрознаков\n"
"чтения (см. <a href=\"chapter03-11.html\">Глава 3, Урок 11</a>), а именно:\n"
"<code>\"</code>, <code>'</code>, <code>(</code>, <code>)</code>,\n"
"<code>,</code>, <code>;</code>, <code>`</code>, and <code>#</code>. \n"
"Кроме того, имя не может быть числом в текущем основании чисел, \n"
"как оно задано <code>*READ-BASE*</code>. Таким образом, FACE это имя, когда "
"<code>*READ-BASE*</code> является 10, но когда <code>*READ-BASE*</code> "
"составляет 16 (либо выше) это число.\n"
"<p>"

#: in/chapter04.html:900
msgid ""
"Most Lisp programmers follow a few naming conventions to identify the\n"
"names that certain roles. Global variables are almost always written\n"
"with a leading and trailing <code>*</code>, for example:<p>"
msgstr ""
"Большинство программистов Lisp следуют нескольким соглашениям об \n"
"именовании, чтобы идентифицировать имена определенных ролей. \n"
"Глобальные переменные почти всегда пишутся с начальным и конечным\n"
"<code>*</code>, например:\n"
"<p>"

#: in/chapter04.html:906
msgid ""
"<pre>\n"
"*next-id*\n"
"*home-directory*\n"
"*software-version*\n"
"</pre> "
msgstr ""

#: in/chapter04.html:910
msgid ""
"Other conventions vary somewhat among Lisp programmers. It is fairly\n"
"common to see the name of a constant written with a leading and\n"
"trailing <code>+</code>, such as:<p>"
msgstr ""
"Другие соглашения несколько различаются среди программистов Lisp. \n"
"Довольно часто можно увидеть имя константы, написанное с начальным \n"
"и конечным <code>+</code>, например:\n"
"<p>"

#: in/chapter04.html:915
msgid ""
"<pre>\n"
"+initial-allocation-count+\n"
"+maximum-iteration-limit+\n"
"</pre> "
msgstr ""

#: in/chapter04.html:918
msgid ""
"However, Lisp itself does not follow this convention for\n"
"constants defined by the language:<p>"
msgstr ""
"Однако сам Лисп не следует этому соглашению для констант, \n"
"определенных языком:\n"
"<p>"

#: in/chapter04.html:924
msgid ""
"<pre>\n"
"pi\n"
"most-positive-fixnum\n"
"least-negative-short-float\n"
"</pre> "
msgstr ""

#: in/chapter04.html:933
msgid ""
"Lisp programmers tend to set aside certain characters as prefixes for\n"
"names of functions which use implementation-dependent features of the\n"
"Lisp implementation, or which which are otherwise considered\n"
"\"dangerous\" because they violate abstraction. The <code>%</code>\n"
"character is most often seen in this role, but others are used -- you\n"
"should be aware that any name which starts with a non-alphabetic\n"
"character <em>may</em> have some special significance to the\n"
"programmer who wrote the code:<p>"
msgstr ""
"Программисты Lisp склонны выделять определенные знаки в качестве \n"
"префиксов для имен функций, которые используют зависящие от реализации\n"
"особенности реализации Lisp, или которые иначе считаются \"опасными\", \n"
"поскольку они нарушают абстракцию. Знак <code>%</code> чаще всего \n"
"встречается в этой роли, но используются и другие - вы должны знать, \n"
"что любое имя, начинающееся с неалфавитного знака, может иметь какое-то \n"
"особое значение для программиста, написавшего код:\n"
"<p>"

#: in/chapter04.html:941
msgid ""
"<pre>\n"
"%open-file-id\n"
"%structure-slot-names\n"
"$reserve_heap\n"
"_call-event-handler\n"
"@frame-marker\n"
"</pre> "
msgstr ""

#: in/chapter04.html:949
msgid ""
"Don't forget to use the proper forms (<a\n"
"href=\"#global-vars-and-consts\">described earlier in this chapter</a>\n"
") to declare global variables and constants. Many Lisp compilers will\n"
"let you get away with using a SETQ form to define global variables.\n"
"Although this is convenient for debugging purposes, you should not\n"
"rely on this behavior in your final program, as it is not guaranteed\n"
"to work in all implementations.<p>"
msgstr ""
"Не забудьте использовать соответствующие формы \n"
"(<a href=\"#global-vars-and-consts\">описанные ранее в этой главе</a> ) \n"
"для объявления глобальных переменных и констант. Многие компиляторы Lisp \n"
"позволят вам избежать использования формы SETQ для определения глобальных\n"
"переменных. Хотя это удобно для целей отладки, вы не должны полагаться на \n"
"такое поведение в вашей окончательной программе, так как оно не "
"гарантировано работает во всех реализациях.\n"
"<p>"

#: in/chapter04.html:958
msgid ""
"If you don't define a constant using a <code>DEFCONSTANT</code> form,\n"
"the compiler can not guarantee that its value will remain constant.\n"
"Even worse is the requirement that a constant name be neither\n"
"assigned (through a <code>SETQ</code> form, for example) nor bound\n"
"(in a <code>LET</code> form or as the name of a function parameter,\n"
"for example). If you don't define your constants using\n"
"<code>DEFCONSTANT</code>, the compiler has no way to enforce these\n"
"requirements.<p>"
msgstr ""
"Если вы не определяете константу с помощью формы <code>DEFCONSTANT</code>,\n"
"компилятор не может гарантировать, что ее значение останется постоянным. \n"
"Еще хуже требование, чтобы имя константы не было ни присвоено (через форму \n"
"<code>SETQ</code>, например), ни привязано (в форме <code>LET</code> или \n"
"в качестве имени параметра функции, например). Если вы не определяете свои\n"
"константы с помощью <code>DEFCONSTANT</code>, компилятор не имеет "
"возможности\n"
"соблюдать эти требования.\n"
"<p>"

#: in/chapter04.html:960
msgid "<h2>Lexical binding, and multiple name spaces</h2> "
msgstr "<h2>Лексическое связывание и несколько пространств имен</h2> "

#: in/chapter04.html:964
msgid ""
"The following piece of code illustrates how you can use the same name\n"
"for different purposes. Take a minute to read this, and see how many\n"
"separate uses you can count for the name <code>FUNNY</code>.<p>"
msgstr ""
"В следующем фрагменте кода показано, как можно использовать одно и то \n"
"же имя для различных целей. Потратьте минуту, чтобы прочитать его, и \n"
"посмотрите, сколько отдельных применений вы можете подсчитать для \n"
"имени <code>FUNNY</code>.<p>"

#: in/chapter04.html:977
msgid ""
"<pre>\n"
"(defun funny (funny)\n"
"  \"funny...\"\n"
"  (if (zerop funny)\n"
"    :funny\n"
"    (list\n"
"     (cons funny \n"
"           (let ((funny funny))\n"
"             (setq funny (1- funny))\n"
"             (funny funny))) \n"
"     funny)))\n"
"</pre> "
msgstr ""

#: in/chapter04.html:979
msgid "Here are the five roles played by this one name:<p>"
msgstr ""
"Вот пять ролей, которые играет это одно имя:\n"
"<p>"

#: in/chapter04.html:987
msgid ""
"<ol>\n"
"<li>function name\n"
"<li>function argument\n"
"<li>a word in the documentation string\n"
"<li>a constant in the keyword package\n"
"<li>a new lexical variable\n"
"</ol> "
msgstr ""
"<ol>\n"
"<li>имя функции\n"
"<li>аргумент функции\n"
"<li>слово в строке документации\n"
"<li>константа в пакете ключевых слов\n"
"<li>новая лексическая переменная\n"
"</ol> "

#: in/chapter04.html:999
msgid ""
"Considering only the symbols named <code>FUNNY</code>, there are\n"
"different values according to its use and position in the code.\n"
"First, there is its value as a function object -- this is created by\n"
"the <code>DEFUN</code> form and called recursively inside the\n"
"<code>LET</code> form. Next, the value of the actual parameter is\n"
"passed in a call to the function and bound to this name. Then,\n"
"there's the constant value of the keyword, appearing as the\n"
"consequent return value of the <code>IF</code> form. And finally,\n"
"inside the <code>LET</code> form, a new binding is created (by the\n"
"<code>LET</code> form) and its value changed (by the\n"
"<code>SETQ</code> form).<p>"
msgstr ""
"Учитывая только символы, названные <code>FUNNY</code>, существуют \n"
"различные значения в зависимости от их использования и положения в коде. \n"
"Во-первых, существует его значение как объекта функции - оно создается \n"
"формой <code>DEFUN</code> и вызывается рекурсивно внутри формы \n"
"<code>LET</code>. Далее значение фактического параметра передающегося\n"
"в вызове функции и привязывается к этому имени. Затем есть постоянное \n"
"значение ключевое слово, появляющееся как последовательное возвращаемое "
"значение формы <code>IF</code>. И наконец, внутри формы <code>LET</code> "
"создается новая привязка (с помощью формы <code>LET</code>) и изменяется \n"
"ее значение (с помощью формы <code>SETQ</code>).\n"
"<p>"

#: in/chapter04.html:1004
msgid ""
"Is this hard to follow? Yes. As a rule of thumb, you should be shot\n"
"if you write code that looks like this. I, on the other hand, get to\n"
"do this because it's instructive -- the lesson here is that there are\n"
"a number of different namespaces in Lisp.<p>"
msgstr ""
"Неужели за этим трудно уследить? Да. Как правило, вы должны быть "
"застрелены, \n"
"если вы пишете код, который выглядит так. С другой стороны, я делаю \n"
"это потому, что это поучительно - урок здесь заключается в том, что \n"
"в Lisp есть несколько различных пространств имен.\n"
"<p>"

#: in/chapter04.html:1006
msgid "And what happens when you invoke this bizarre function? This:<p>"
msgstr ""
"И что происходит, когда вы вызываете эту странную функцию? \n"
"Этот:<p>"

#: in/chapter04.html:1010
msgid ""
"<pre>\n"
"? (funny 3)\n"
"((3 (2 (1 . :FUNNY) 1) 2) 3)"
msgstr ""

#: in/chapter04.html:1014
msgid ""
"? (funny 0)\n"
":funny\n"
"</pre> "
msgstr ""

#: in/chapter04.html:1016
msgid "Now consider the following Lisp session:<p>"
msgstr ""
"Теперь рассмотрим следующий сеанс Lisp:\n"
"<p>"

#: in/chapter04.html:1020
msgid ""
"<pre>\n"
"? (defun foo () 1)\n"
"FOO"
msgstr ""

#: in/chapter04.html:1026
msgid ""
"? (defun baz ()\n"
"    (flet ((foo () 2)\n"
"           (bar () (foo)))\n"
"      (values (foo) (bar))))\n"
"BAZ"
msgstr ""

#: in/chapter04.html:1030
msgid ""
"? (baz)\n"
"2\n"
"1"
msgstr ""

#: in/chapter04.html:1036
msgid ""
"? (defun raz ()\n"
"    (labels ((foo () 2)\n"
"             (bar () (foo)))\n"
"      (values (foo) (bar))))\n"
"RAZ"
msgstr ""

#: in/chapter04.html:1041
msgid ""
"? (raz)\n"
"2\n"
"2\n"
"</pre> "
msgstr ""

#: in/chapter04.html:1044
msgid ""
"This is pretty subtle, but it's worth understanding because this is\n"
"fairly common practice. Here's what happened:<p>"
msgstr ""
"Это довольно тонко, но стоит понять, потому что это довольно \n"
"распространенная практика. Вот что произошло:\n"
"<p>"

#: in/chapter04.html:1062
msgid ""
"<ol>\n"
"<li>define function <code>FOO</code> to return 1\n"
"<li>define function <code>BAZ</code>, which\n"
"<ol>\n"
"<li>defines function <code>FOO</code> locally to return 2\n"
"<li>defines function <code>BAR</code> locally to call <code>FOO</code> \n"
"<li>calls <code>FOO</code> and <code>BAR</code>, and returns their values\n"
"</ol> \n"
"<li>call <code>BAZ</code>, which returns the values 2 and 1\n"
"<li>define function <code>RAZ</code>, which\n"
"<ol>\n"
"<li>defines function <code>FOO</code> locally to return 2\n"
"<li>defines function <code>BAR</code> locally to call <code>FOO</code> \n"
"<li>calls <code>FOO</code> and <code>BAR</code>, and returns their values\n"
"</ol> \n"
"<li>call <code>RAZ</code>, which returns the values 2 and 2\n"
"</ol> "
msgstr ""
"<ol>\n"
"<li>определяется функция <code>FOO</code> возвращающая 1\n"
"<li>определяется функция <code>BAZ</code>, с\n"
"<ol>\n"
"<li>определением локальной функции <code>FOO</code> возвращающей 2\n"
"<li>определением локальной функции <code>BAR</code> вызывающей \n"
"<code>FOO</code> \n"
"<li>вызовов <code>FOO</code> и <code>BAR</code>, и возврата их значений\n"
"</ol> \n"
"<li>вызова <code>BAZ</code>, который возвращает значения 2 и 1\n"
"<li>определения функции <code>RAZ</code>, которая\n"
"<ol>\n"
"<li>определяет локальную функцию <code>FOO</code> возвращающую 2\n"
"<li>определяет локальную функцию <code>BAR</code> возвращающую\n"
"вызов <code>FOO</code> \n"
"<li>вызова <code>FOO</code> и <code>BAR</code>, и возврата их значений\n"
"</ol> \n"
"<li>вызова <code>RAZ</code>, который возвращает значения 2 и 2\n"
"</ol> "

#: in/chapter04.html:1065
msgid ""
"Even though <code>BAZ</code> and <code>RAZ</code> ostensibly do the\n"
"same thing, they return different values.<p>"
msgstr ""
"Даже если <code>BAZ</code> и <code>RAZ</code> якобы делают одно и то же, \n"
"они возвращают разные значения.\n"
"<p>"

#: in/chapter04.html:1073
msgid ""
"<code>BAZ</code> defines its local functions inside an\n"
"<code>FLET</code> form, which does not allow reference to the\n"
"functions it defines. So the <code>FOO</code> called by\n"
"<code>BAR</code> inside <code>BAZ</code> is actually the global\n"
"<code>FOO</code>, which returns 1. The <code>FOO</code> defined\n"
"inside the <code>FLET</code> form is never referenced by\n"
"<code>BAZ</code>.<p>"
msgstr ""
"<code>BAZ</code> определяет свои локальные функции внутри формы\n"
"<code>FLET</code>, что не позволяет ссылаться на определяемые ею функции.\n"
"Таким образом, <code>FOO</code>, вызываемый <code>BAR</code> изнутри \n"
"<code>BAZ</code>, на самом деле является глобальным <code>FOO</code>, \n"
"который возвращает 1. <code>FOO</code> определенный внутри формы \n"
"<code>FLET</code>, никогда не упоминается в <code>BAZ</code>.\n"
"<p>"

#: in/chapter04.html:1081
msgid ""
"<code>RAZ</code> defines its local functions inside a\n"
"<code>LABELS</code> form, within which functions defined may refer to\n"
"themselves or each other. Thus, the <code>FOO</code> called by\n"
"<code>BAR</code> inside <code>RAZ</code> is the one defined inside\n"
"the <code>LABELS</code> form, which returns 2. The globally defined\n"
"<code>FOO</code> is shadowed by the <code>FOO</code> named in the\n"
"<code>LABELS</code> form.<p>"
msgstr ""
"<code>RAZ</code> определяет свои локальные функции внутри формы \n"
"<code>LABELS</code>, в пределах которой определенные функции могут \n"
"ссылаться на себя или друг на друга. Таким образом, <code>FOO</code>, \n"
"вызываемый <code>BAR</code> внутри <code>RAZ</code>, является тем, \n"
"который определен внутри формы <code>LABELS</code>, который возвращает 2.\n"
"Определенный глобальный <code>FOO</code> является затененным\n"
"именем <code>FOO</code> в форме <code>LABELS</code>.\n"
"<p>"

#: in/chapter04.html:1087
msgid ""
"In both cases, <code>FOO</code> is lexically apparent at two places:\n"
"globally, and within the local defining form (<code>FLET</code> or\n"
"<code>LABELS</code>). For something to be lexically apparent, or\n"
"lexically scoped, means that its definition can be determined by\n"
"reading the program.<p>"
msgstr ""
"В обоих случаях <code>FOO</code> лексически проявляется в двух местах: \n"
"глобально и в пределах локальной определяющей формы (<code>FLET</code> или\n"
"<code>LABELS</code>). Для того чтобы что-то было лексически очевидным или\n"
"лексически ограниченным, это означает, что его определение можно определить, "
"прочитав программу.\n"
"<p>"

#: in/chapter04.html:1095
msgid ""
"In <code>BAZ</code>, I know that the local\n"
"definition of <code>FOO</code> is not visible within\n"
"<code>BAR</code>, so the global definition must be referenced. (If\n"
"there was an enclosing form within <code>BAZ</code> which defined a\n"
"local function <code>FOO</code>, that would be referenced rather than\n"
"the global definition -- again, because it's lexically apparent to the \n"
"caller.)<p>"
msgstr ""
"В <code>BAZ</code> я знаю, что локальное определение <code>FOO</code> \n"
"не видно в <code>BAR</code>, поэтому необходимо ссылаться на глобальное\n"
"определение. (Если бы в <code>BAZ</code> существовала окружающая форма, "
"определяющая локальную функцию <code>FOO</code>,то можно было бы ссылаться\n"
"на нее, а не на глобальное определение, потому что оно лексически очевидно\n"
"для вызывающего.)<p>"

#: in/chapter04.html:1103
msgid ""
"In <code>RAZ</code>, I know that the local definition of\n"
"<code>FOO</code> is visible to <code>BAR</code>, so this is used\n"
"instead of the global definition. Even if there was an enclosing form\n"
"that defined another <code>FOO</code> locally within\n"
"<code>RAZ</code>, it would -- from the viewpoint of <code>BAR</code>\n"
"-- be shadowed by the <code>FOO</code> defined in the\n"
"<code>LABELS</code> form.<p>"
msgstr ""
"В <code>RAZ</code> я знаю, что локальное определение <code>FOO</code> \n"
"видно <code>BAR</code>, поэтому оно используется вместо глобального \n"
"определения. Даже если бы существовала охватывающая форма, которая \n"
"определяла бы другую бы <code>FOO</code> локально в пределах \n"
"<code>BAR</code>, она была бы - с точки зрения <code>BAR</code> -\n"
"затенена <code>FOO</code>, определенным в форме <code>LABELS</code>.\n"
"<p>"

#: in/chapter04.html:1105
msgid "<h2>Reading, writing, and arithmetic</h2> "
msgstr "<h2>Чтение, запись и арифметика</h2> "

#: in/chapter04.html:1112
msgid ""
"Your programs usually need to get input and produce output. If you're\n"
"working with a system that supports windows and dialogs, you can\n"
"certainly use these graphical devices. Relying instead on Lisp's\n"
"built-in facilities for reading and writing strings of characters\n"
"will ensure that your program is useful (or at least usable) on all\n"
"kinds of computers.<p>"
msgstr ""
"Ваши программы обычно должны получать входные данные и производить \n"
"выходные данные. Если вы работаете с системой, которая поддерживает \n"
"windows и диалоговые окна, вы, безусловно, можете использовать эти \n"
"графические устройства. Вместо этого, полагаясь на встроенные средства \n"
"Lisp для чтения и записи строк символов, вы гарантируете, что ваша \n"
"программа полезна (или, по крайней мере, пригодна для использования) \n"
"на всех типах компьютеров.\n"
"<p>"

#: in/chapter04.html:1117
msgid ""
"Most elementary programming texts include a simple program to\n"
"demonstrate the \"input, process, output\" approach. Our example in\n"
"Lisp reads a series of numbers, adds them, and prints the sum when we\n"
"enter a special token instead of a number:<p>"
msgstr ""
"Большинство элементарных текстов по программированию включают \n"
"простую программу для демонстрации подхода \"ввод, процесс, вывод\". \n"
"Наш пример на Lisp считывает ряд чисел, складывает их и печатает сумму, \n"
"когда мы вводим специальный маркер вместо числа:\n"
"<p>"

#: in/chapter04.html:1133
msgid ""
"<pre>\n"
"(defun simple-adding-machine-1 ()\n"
"  (let ((sum 0)\n"
"        next)\n"
"    (loop\n"
"      (setq next (read))\n"
"      (cond ((numberp next)\n"
"             (incf sum next))\n"
"            ((eq '= next)\n"
"             (print sum)\n"
"             (return))\n"
"            (t\n"
"             (format t \"~&amp;~A ignored!~%\" next))))\n"
"    (values)))\n"
"</pre>"
msgstr ""

#: in/chapter04.html:1135
msgid "Our <code>SIMPLE-ADDING-MACHINE-1</code> works like this:<p>"
msgstr ""
"Наша <code>SIMPLE-ADDING-MACHINE-1</code> работает следующим образом:\n"
"<p>"

#: in/chapter04.html:1144
msgid ""
"<pre>\n"
"(SIMPLE-ADDING-MACHINE-1)\n"
"3\n"
"5\n"
"FOO\n"
"FOO ignored!\n"
"11\n"
"="
msgstr ""

#: in/chapter04.html:1147
msgid ""
"19\n"
"</pre> "
msgstr ""

#: in/chapter04.html:1154
msgid ""
"<code>SIMPLE-ADDING-MACHINE-1</code> gets its input via the keyboard,\n"
"and writes output to the screen. This happens because <code>READ</code> and\n"
"<code>PRINT</code> have optional arguments which specify a <em>stream</em> \n"
"(see <a href=\"chapter19.html\">Chapter 19</a>) and because using <code>T</"
"code>\n"
"as the second argument to <code>FORMAT</code> is the same as specifying the\n"
"standard output stream -- the screen.<p>"
msgstr ""
"<code>SIMPLE-ADDING-MACHINE-1</code>  получает свой ввод через клавиатуру,\n"
"а вывод записывает на экран. Это происходит потому, что <code>READ</code> \n"
"и <code>PRINT</code> имеют необязательные аргументы, которые определяют "
"поток\n"
"(см. <a href=\"chapter19.html\">Главу 19</a>), и потому, что использование \n"
"<code>T</code> в качестве второго аргумента для <code>FORMAT</code> \n"
"равнозначно указанию стандартного выходного потока - экрана.\n"
"<p>"

#: in/chapter04.html:1158
msgid ""
"What if we wanted to read inputs from a file, and write to another file?\n"
"One way is to bind the standard input and output streams to files, and \n"
"continue to use <code>SIMPLE-ADDING-MACHINE-1</code>:"
msgstr ""
"Что делать, если мы хотим прочитать входные данные из файла и записать \n"
"их в другой файл? Один из способов-привязать стандартные входные и выходные\n"
"потоки к файлам и продолжать использовать <code>SIMPLE-ADDING-MACHINE-1</"
"code>:"

#: in/chapter04.html:1167
msgid ""
"<pre>\n"
"(let ((*standard-input* (open \"infile.dat\" :direction :input))\n"
"      (*standard-output* (open \"outfile.dat\" :direction :output)))\n"
"  (declare (special *standard-input* *standard-output*))\n"
"  (simple-adding-machine-1)\n"
"  (close *standard-input*)\n"
"  (close *standard-output))\n"
"</pre> "
msgstr ""

#: in/chapter04.html:1176
msgid ""
"This is almost, but not quite, satisfactory. We bind the standard input\n"
"and output streams to newly opened files, process the data, and close the\n"
"files. We use <code>LET</code> to temporarily bind the standard streams\n"
"to files; upon leaving the <code>LET</code> form, <code>*STANDARD-INPUT*</"
"code> \n"
"and <code>*STANDARD-OUTPUT*</code> regain their original values. The "
"problem\n"
"lurking in this piece of code is that an abnormal exit -- an error or a\n"
"deliberate interrupt -- can cause one or both of the <code>CLOSE</code> \n"
"calls to be skipped.<p>"
msgstr ""
"Это почти, но не совсем удовлетворительно. Мы привязываем стандартные "
"входные\n"
"и выходные потоки к вновь открытым файлам, обрабатываем данные и закрываем \n"
"файлы. Мы используем <code>LET</code> для временной привязки стандартных \n"
"потоков к файлам; при выходе из формы <code>LET</code> \n"
"<code>*STANDARD-INPUT*</code> и <code>*STANDARD-OUTPUT*</code>\n"
"восстанавливают свои исходные значения. Проблема, скрывающаяся в этом \n"
"фрагменте кода, заключается в том, что ненормальный выход - ошибка или\n"
"преднамеренное прерывание-может привести к пропуску одного или обоих \n"
"вызовов <code>CLOSE</code>.\n"
"<p>"

#: in/chapter04.html:1178
msgid ""
"A better way to write this kind of code uses <code>WITH-OPEN-FILE</code>:<p>"
msgstr ""
"Лучший способ написания такого рода кода использование \n"
"<code>WITH-OPEN-FILE</code>:<p>"

#: in/chapter04.html:1187
msgid ""
"<pre>\n"
"(with-open-file (in-stream \"infile.dat\" :direction :input)\n"
"  (with-open-file (out-stream \"outfile.dat\" :direction :output)\n"
"    (let ((*standard-input* in-stream)\n"
"          (*standard-output* out-stream))\n"
"      (declare (special *standard-input* *standard-output*))\n"
"      (simple-adding-machine-1))))\n"
"</pre> "
msgstr ""

#: in/chapter04.html:1192
msgid ""
"This does exactly the same thing, except that a file opened by\n"
"<code>WITH-OPEN-FILE</code> is guaranteed to be closed upon exiting the\n"
"form, whether the exit is normal or not.  We'll take a look at how this is\n"
"possible in <a href=\"chapter09.html\">Chapter 9</a>.<p>"
msgstr ""
"Это делает почти то же самое, за исключением того, что файл, \n"
"открытый с помощью команды <code>WITH-OPEN-FILE</code>, гарантированно\n"
"закрывается при выходе из формы, независимо от того, является ли выход \n"
"нормальным или нет. Мы рассмотрим, как это возможно, в \n"
"<a href=\"chapter09.html\">Главе 9</a>.\n"
"<p>"

#: in/chapter04.html:1199
msgid ""
"The technique of rebinding the standard input and output streams can be\n"
"very handy if you have to redirect input and output for a program you\n"
"didn't write, don't want to rewrite, or can't get the source code to.\n"
"If you're writing a program from scratch, you might want to plan for it\n"
"to be used either with the standard streams or streams (perhaps attached\n"
"to files) provided by the caller:<p>"
msgstr ""
"Метод повторного связывания стандартных потоков ввода и вывода может быть \n"
"очень удобен, если вам нужно перенаправить ввод и вывод для программы, \n"
"которую вы не писали, не хотите переписывать или не можете получить \n"
"исходный код. Если вы пишете программу с нуля, вы можете запланировать \n"
"ее использование либо со стандартными потоками, либо с потоками \n"
"(возможно, прикрепленными к файлам), предоставленными вызывающим\n"
"кодом:\n"
"<p>"

#: in/chapter04.html:1216
msgid ""
"<pre>\n"
"(defun simple-adding-machine-2 (&amp;optional (in-stream *standard-input*)\n"
"                                          (out-stream *standard-output*))\n"
"  (let ((sum 0)\n"
"        next)\n"
"    (loop\n"
"      (setq next (read in-stream))\n"
"      (cond ((numberp next)\n"
"             (incf sum next))\n"
"            ((eq '= next)\n"
"             (print sum out-stream)\n"
"             (return))\n"
"            (t\n"
"             (format out-stream \"~&amp;~A ignored!~%\" next))))\n"
"    (values)))\n"
"</pre> "
msgstr ""

#: in/chapter04.html:1220
msgid ""
"If you want to use <code>SIMPLE-ADDING-MACHINE-2</code> with the keyboard\n"
"and screen, call it without any arguments. To call it with file streams, do\n"
"this:<p>"
msgstr ""
"Если вы хотите использовать <code>SIMPLE-ADDING-MACHINE-2</code> с "
"клавиатурой \n"
"и экраном, вызовите его без каких-либо аргументов. Чтобы вызвать его с \n"
"файловми потоками, сделайте это:\n"
"<p>"

#: in/chapter04.html:1226
msgid ""
"<pre>\n"
"(with-open-file (in-stream \"infile.dat\" :direction :input)\n"
"  (with-open-file (out-stream \"outfile.dat\" :direction :output)\n"
"    (simple-adding-machine-2 in-stream out-stream)))\n"
"</pre> "
msgstr ""

#: in/chapter04.html:1231
msgid ""
"We don't have to rebind the standard input and output streams as we did to\n"
"redirect I/O for <code>SIMPLE-ADDING-MACHINE-1</code>. This leaves the \n"
"standard streams free other purposes -- such as reporting progress or \n"
"interacting with the user.<p>"
msgstr ""
"Нам не нужно повторно связывать стандартные входные и выходные потоки, \n"
"как это было сделано для перенаправления ввода-вывода для \n"
"<code>SIMPLE-ADDING-MACHINE-1</code>. Это оставляет стандартные \n"
"потоки свободными для других целей - таких как отчет о ходе выполнения \n"
"или взаимодействие с пользователем.\n"
"<p>"

#: in/chapter04.html:1238
msgid ""
"To close out this section, let's take a brief look at arithmetic.\n"
"Lisp has an extensive repertoire of mathematical functions, consult a\n"
"reference book for details. <a href=\"chapter03-10.html\">Chapter 3,\n"
"Lesson 10</a> covered numbers very briefly. Now, we're going to look\n"
"at how and when numbers get converted automatically from one type to\n"
"another.<p>"
msgstr ""
"Чтобы закрыть этот раздел, давайте кратко рассмотрим арифметику. \n"
"Lisp имеет обширный репертуар математических функций, обратитесь \n"
"к справочнику для получения подробной информации. \n"
"<a href=\"chapter03-10.html\">Глава 3, Урок 10</a> очень коротко \n"
"описала цифры. Теперь мы рассмотрим, как и когда числа \n"
"автоматически преобразуются из одного типа в другой.\n"
"<p>"

#: in/chapter04.html:1242
msgid ""
"The simplest rule is that of <em>floating point contagion</em>, an \n"
"ominous-sounding term which means, \"If you use a floating point number\n"
"in a calculation, the result will be a floating point number.\"<p>"
msgstr ""
"Самое простое правило - это <em>заражение плавающей запятой</em>, \n"
"зловеще звучащий термин, который означает: \"Если вы используете \n"
"число с плавающей запятой в вычислении, результатом будет \n"
"число с плавающей запятой.\"\n"
"<p>"

#: in/chapter04.html:1250
msgid ""
"The next rule involves floating point components of complex numbers.\n"
"A complex number has a real part and an imaginary part, read (and\n"
"printed) by Lisp as <code>#C(</code><i>real-part\n"
"imaginary-part</i><code>)</code>, where <i>real-part</i> and\n"
"<i>imaginary-part</i> are any kind of Lisp number except for another\n"
"complex number. If either part is a floating point number, then Lisp \n"
"converts both parts to floating point numbers.<p>"
msgstr ""
"Следующее правило включает компоненты комплексных чисел \n"
"с плавающей запятой. Комплексное число имеет действительную часть\n"
"и мнимую часть, чтение (и печать) в lisp'е имеет формат \n"
"<code>#C(</code><i>real-part imaginary-part</i><code>)</code>, где <i>real-"
"part</i> и <i>imaginary-part</i> какое либо Лисп число, за исключением "
"другого\n"
"комплексного числа. Если любая из сторон является числом с плавающей "
"запятой, \n"
"то Lisp преобразует обе части в числа с плавающей запятой.\n"
"<p>"

#: in/chapter04.html:1253
msgid ""
"If you reduce the imaginary part of a complex number to zero, you get\n"
"the non-complex value of the real part.<p>"
msgstr ""
"Если вы сократите мнимую часть комплексного числа до нуля, вы получите\n"
"не комплексное значение равное действительной части.\n"
"<p>"

#: in/chapter04.html:1260
msgid ""
"Ratios are read and printed as\n"
"<i>numerator</i><code>/</code><i>denominator</i>, where\n"
"<i>numerator</i> and <i>denominator</i> are always integers. The advantage\n"
"of a ratio is that it is exact -- <code>(/ 1.0 3)</code> is a floating \n"
"point number which is very close to (but not exactly) one-third, but\n"
"<code>1/3</code> (or <code>(/ 1 3)</code>) is <em>exactly</em> one-third.<p>"
msgstr ""
"Отношения считываются и печатаются в виде \n"
"<i>numerator</i><code>/</code><i>denominator</i>, где \n"
"<i>numerator</i>(числитель) и <i>denominator</i>(знаменатель) \n"
"всегда являются целыми числами. Преимущество соотношения состоит в том, \n"
"что оно точно - <code>(/ 1.0 3)</code> - это число с плавающей запятой, \n"
"которое очень близко (но не точно) к одной трети, но <code>1/3</code>\n"
" (или <code>(/ 1 3)</code>) - это ровно одна треть.\n"
"<p>"

#: in/chapter04.html:1263
msgid ""
"A ratio whose numerator is exactly divisible by its denominator will\n"
"be reduced to an integer -- again, this is an exact number.<p>"
msgstr ""
"Отношение, числитель которого точно делится на его знаменатель, \n"
"будет сведено к целому числу - опять же, это точное число.\n"
"<p>"

#: in/chapter04.html:1267
msgid ""
"And finally, an integer is just an integer. If an integer gets too large to\n"
"fit the machine's representation, Lisp converts it to a <em>bignum</em> --\n"
"the number of digits is limited only by the computer's memory.<p>"
msgstr ""
"И наконец, целое число-это просто целое число. Если целое число становится\n"
"слишком большим, чтобы соответствовать представлению машины, Lisp \n"
"преобразует его в <em>bignum</em> - количество цифр ограничено только \n"
"памятью компьютера.<p>"

#: in/chapter04.html:1271
msgid ""
"Just to make sure you understand all of this, try adding some numbers\n"
"of different types to see whether you can invoke all of the\n"
"conversions described above.<p>"
msgstr ""
"Просто чтобы убедиться, что вы все это понимаете, попробуйте сложить \n"
"несколько чисел различных типов, чтобы увидеть, можно ли вызвать все\n"
"преобразования, описанные выше.<p>"

#: in/chapter04.html:1273
msgid "<h2>Other data types</h2> "
msgstr "<h2>Другие типы данных</h2> "

#: in/chapter04.html:1282
msgid ""
"Let's put together an extended example to show how we might use several\n"
"of Lisp's built-in data types. We'll build a simple application to keep\n"
"track of bank checks as we write them. For each check, we'll track the\n"
"check number, payee, date, amount, and memo. We'll support queries to\n"
"display an individual check, to list all checks paid to a payee, to list\n"
"all the payees, to sum all of the check amounts, and to list all of the\n"
"checks we've paid. We'll also provide a way to void a check once\n"
"written.<p>"
msgstr ""
"Давайте приведем расширенный пример, чтобы показать, как мы можем \n"
"использовать несколько встроенных типов данных Lisp. Мы создадим \n"
"простое приложение, чтобы отслеживать банковские чеки, когда мы их \n"
"выписываем. Для каждого чека мы будем отслеживать номер чека, \n"
"получателя платежа, дату, сумму и памятку. Мы будем поддерживать \n"
"запросы для отображения отдельного чека, чтобы перечислить все чеки,\n"
"выплаченные получателю, перечислить всех получателей, суммировать \n"
"все суммы чеков и перечислить все чеки, которые мы заплатили. \n"
"Мы также предоставим способ аннулировать чек, как только он будет выписан.\n"
"<p>"

#: in/chapter04.html:1284
msgctxt "in/chapter04.html:1284"
msgid "Here's the code:<p>"
msgstr ""
"Вот вам и код:\n"
"<p>"

#: in/chapter04.html:1288
msgid ""
"<pre>\n"
"(defvar *checks* (make-array 100 :adjustable t :fill-pointer 0)\n"
"  \"A vector of checks.\")"
msgstr ""

#: in/chapter04.html:1291
msgid ""
"(defconstant +first-check-number+ 100 \n"
"  \"The number of the first check.\")"
msgstr ""

#: in/chapter04.html:1294
msgid ""
"(defvar *next-check-number* +first-check-number+ \n"
"  \"The number of the next check.\")"
msgstr ""

#: in/chapter04.html:1297
msgid ""
"(defvar *payees* (make-hash-table :test #'equal) \n"
"  \"Payees with checks paid to each.\")"
msgstr ""

#: in/chapter04.html:1300
msgid ""
"(defstruct check\n"
"  number date amount payee memo)"
msgstr ""

#: in/chapter04.html:1307
msgid ""
"(defun current-date-string ()\n"
"  \"Returns current date as a string.\"\n"
"  (multiple-value-bind (sec min hr day mon yr dow dst-p tz)\n"
"                       (get-decoded-time)\n"
"    (declare (ignore sec min hr dow dst-p tz))\n"
"    (format nil \"~A-~A-~A\" yr mon day)))"
msgstr ""

#: in/chapter04.html:1320
msgid ""
"(defun write-check (amount payee memo)\n"
"  \"Writes the next check in sequence.\"\n"
"  (let ((new-check (make-check \n"
"                    :number *next-check-number*\n"
"                    :date (current-date-string)\n"
"                    :amount amount\n"
"                    :payee payee\n"
"                    :memo memo)))\n"
"    (incf *next-check-number*)\n"
"    (vector-push-extend new-check *checks*)\n"
"    (push new-check (gethash payee *payees*))\n"
"    new-check))"
msgstr ""

#: in/chapter04.html:1325
msgid ""
"(defun get-check (number)\n"
"  \"Returns a check given its number, or NIL if no such check.\"\n"
"  (when (and (<= +first-check-number+ number) (< number *next-check-"
"number*))\n"
"    (aref *checks* (- number +first-check-number+))))"
msgstr ""

#: in/chapter04.html:1334
msgid ""
"(defun void-check (number)\n"
"  \"Voids a check and returns T.  Returns NIL if no such check.\"\n"
"  (let ((check (get-check number)))\n"
"    (when check\n"
"      (setf (gethash (check-payee check) *payees*)\n"
"            (delete check (gethash (check-payee check) *payees*)))\n"
"      (setf (aref *checks* (- number +first-check-number+)) nil)\n"
"      t)))"
msgstr ""

#: in/chapter04.html:1338
msgid ""
"(defun list-checks (payee)\n"
"  \"Lists all of the checks written to payee.\"\n"
"  (gethash payee *payees*))"
msgstr ""

#: in/chapter04.html:1342
msgid ""
"(defun list-all-checks ()\n"
"  \"Lists all checks written.\"\n"
"  (coerce *checks* 'list))"
msgstr ""

#: in/chapter04.html:1350
msgid ""
"(defun sum-checks ()\n"
"  (let ((sum 0))\n"
"    (map nil #'(lambda (check)\n"
"                 (when check\n"
"                   (incf sum (check-amount check))))\n"
"         *checks*)\n"
"    sum))"
msgstr ""

#: in/chapter04.html:1360
msgid ""
"(defun list-payees ()\n"
"  \"Lists all payees.\"\n"
"  (let ((payees ()))\n"
"    (maphash #'(lambda (key value)\n"
"                 (declare (ignore value))\n"
"                 (push key payees))\n"
"             *payees*)\n"
"    payees))\n"
"</pre> "
msgstr ""

#: in/chapter04.html:1362
msgid "And here's an example of how it works:<p>"
msgstr ""
"А вот пример того, как это работает:\n"
"<p>"

#: in/chapter04.html:1366
msgid ""
"<pre>\n"
"? (write-check 100.00 \"Acme\" \"T-1000 rocket booster\")\n"
"#S(CHECK :NUMBER 100 :DATE \"1996-11-3\" :AMOUNT 100.0 :PAYEE \"Acme\" :MEMO "
"\"T-1000 rocket booster\")"
msgstr ""

#: in/chapter04.html:1369
msgid ""
"? (write-check 50.00 \"Acme\" \"1 gross bungee cords\")\n"
"#S(CHECK :NUMBER 101 :DATE \"1996-11-3\" :AMOUNT 50.0 :PAYEE \"Acme\" :MEMO "
"\"1 gross bungee cords\")"
msgstr ""

#: in/chapter04.html:1372
msgid ""
"? (write-check 300.72 \"WB Infirmary\" \"body cast\")\n"
"#S(CHECK :NUMBER 102 :DATE \"1996-11-3\" :AMOUNT 300.72 :PAYEE \"WB Infirmary"
"\" :MEMO \"body cast\")"
msgstr ""

#: in/chapter04.html:1377
msgid ""
"? (list-checks \"Acme\")\n"
"(#S(CHECK :NUMBER 101 :DATE \"1996-11-3\" :AMOUNT 50.0 :PAYEE \"Acme\" :MEMO "
"\"1 gross bungee cords\")\n"
" #S(CHECK :NUMBER 100 :DATE \"1996-11-3\" :AMOUNT 100.0 :PAYEE \"Acme\" :"
"MEMO \"T-1000 rocket booster\"))\n"
"T"
msgstr ""

#: in/chapter04.html:1380
msgid ""
"? (get-check 101)\n"
"#S(CHECK :NUMBER 101 :DATE \"1996-11-3\" :AMOUNT 50.0 :PAYEE \"Acme\" :MEMO "
"\"1 gross bungee cords\")"
msgstr ""

#: in/chapter04.html:1383
msgid ""
"? (sum-checks)\n"
"450.72"
msgstr ""

#: in/chapter04.html:1388
msgid ""
"? (list-all-checks)\n"
"(#S(CHECK :NUMBER 100 :DATE \"1996-11-3\" :AMOUNT 100.0 :PAYEE \"Acme\" :"
"MEMO \"T-1000 rocket booster\")\n"
" #S(CHECK :NUMBER 101 :DATE \"1996-11-3\" :AMOUNT 50.0 :PAYEE \"Acme\" :MEMO "
"\"1 gross bungee cords\")\n"
" #S(CHECK :NUMBER 102 :DATE \"1996-11-3\" :AMOUNT 300.72 :PAYEE \"WB "
"Infirmary\" :MEMO \"body cast\"))"
msgstr ""

#: in/chapter04.html:1391
msgid ""
"? (list-payees)\n"
"(\"WB Infirmary\" \"Acme\")"
msgstr ""

#: in/chapter04.html:1394
msgid ""
"? (void-check 101)\n"
"T"
msgstr ""

#: in/chapter04.html:1398
msgid ""
"? (list-checks \"Acme\")\n"
"(#S(CHECK :NUMBER 100 :DATE \"1996-11-3\" :AMOUNT 100.0 :PAYEE \"Acme\" :"
"MEMO \"T-1000 rocket booster\"))\n"
"T"
msgstr ""

#: in/chapter04.html:1403
msgid ""
"? (list-all-checks)\n"
"(#S(CHECK :NUMBER 100 :DATE \"1996-11-3\" :AMOUNT 100.0 :PAYEE \"Acme\" :"
"MEMO \"T-1000 rocket booster\")\n"
" NIL\n"
" #S(CHECK :NUMBER 102 :DATE \"1996-11-3\" :AMOUNT 300.72 :PAYEE \"WB "
"Infirmary\" :MEMO \"body cast\"))"
msgstr ""

#: in/chapter04.html:1407
msgid ""
"? (sum-checks)\n"
"400.72\n"
"</pre> "
msgstr ""

#: in/chapter04.html:1413
msgid ""
"In about a page of code, we've built a simple check-writing application\n"
"with efficient data structures to store checks and payees. We also have\n"
"basic I/O facilities without any additional effort on our part. And\n"
"thanks to garbage collection, we don't have to worry at all about\n"
"storage deallocation or memory leaks.<p>"
msgstr ""
"Примерно за одну страницу кода мы создали простое приложение для записи "
"чеков \n"
"с эффективными структурами данных для хранения чеков и получателей "
"платежей. \n"
"У нас также есть базовые средства ввода-вывода без каких-либо "
"дополнительных\n"
"усилий с нашей стороны. А благодаря сборке мусора нам совсем не нужно\n"
"беспокоиться об освобождении хранилища или утечках памяти.\n"
"<p>"

#: in/chapter04.html:1416
msgid "<h2>Simple macros</h2> "
msgstr "<h2>Простые Макросы</h2> "

#: in/chapter04.html:1424
msgid ""
"The one important feature missing from our check writing program is the\n"
"ability to save and restore its state. Since the state is completely\n"
"contained in three global variables, <code>*CHECKS*</code>,\n"
"<code>*NEXT-CHECK-NUMBER*</code>, and <code>*PAYEES*</code>, all we\n"
"really have to do is to use <code>PRINT</code> to write the values of\n"
"these variables to a file, and <code>READ</code> to reload them at a\n"
"later time.<p>"
msgstr ""
"Одна важная особенность, отсутствующая в нашей программе записи чеков, \n"
"- это возможность сохранять и восстанавливать ее состояние. \n"
"Поскольку состояние полностью содержится в трех глобальных переменных: \n"
"<code>*CHECKS*</code>, <code>*NEXT-CHECK-NUMBER*</code>, и \n"
"<code>*PAYEES*</code>, все, что нам действительно нужно сделать, \n"
"это использовать <code>PRINT</code> для записи значений этих переменных \n"
"в файл и <code>READ</code> - чтобы перезагрузить их позже.<p>"

#: in/chapter04.html:1429
msgid ""
"But with a little more work we can write a macro that will write our\n"
"save and restore functions. Then we can use this macro not only for our\n"
"check writing program, but also for any program which keeps its state in\n"
"global variables.<p>"
msgstr ""
"Но поработав чуть больше мы можем написать макрос, который будет сам писать\n"
"наши функции сохранения и восстановления. Тогда мы сможем использовать "
"этот \n"
"макрос не только для нашей программы написания чеков, но и для любой \n"
"программы, которая сохраняет свое состояние в глобальных переменных.\n"
"<p>"

#: in/chapter04.html:1431
msgid "First take a look at the finished macro, then we'll dissect it:<p>"
msgstr ""
"Сначала взгляните на готовый макрос, а потом мы его разберем:\n"
"<p>"

#: in/chapter04.html:1451
msgid ""
"<pre>\n"
"(defmacro def-i/o (writer-name reader-name (&amp;rest vars))\n"
"  (let ((file-name (gensym))\n"
"        (var (gensym))\n"
"        (stream (gensym)))\n"
"    `(progn\n"
"       (defun ,writer-name (,file-name)\n"
"         (with-open-file (,stream ,file-name\n"
"                                  :direction :output :if-exists :supersede)\n"
"           (dolist (,var (list ,@vars))\n"
"             (declare (special ,@vars))\n"
"             (print ,var ,stream))))\n"
"       (defun ,reader-name (,file-name)\n"
"         (with-open-file (,stream ,file-name\n"
"                                  :direction :input :if-does-not-exist :"
"error)\n"
"           (dolist (,var ',vars)\n"
"             (set ,var (read ,stream)))))\n"
"       t)))\n"
"</pre> "
msgstr ""

#: in/chapter04.html:1458
msgid ""
"The initial <code>LET</code> form defines symbols that will appear in the\n"
"expanded macro. Each symbol is created by <code>(GENSYM)</code> so that\n"
"no other symbol can possibly be the same. This avoids a problem which could\n"
"arise if we wrote a macro using a particular symbol as a variable, then \n"
"called the macro with an argument having the same name as one of the "
"symbols\n"
"in the expansion.<p>"
msgstr ""
"Начальная форма <code>LET</code> определяет символы, которые будут \n"
"отображаться в развернутом макросе. Каждый символ создается (GENSYM) так, \n"
"что ни какой другой символ не может быть таким же. Это позволяет избежать\n"
"проблемы, которая могла бы возникнуть, если бы мы написали макрос, \n"
"используя определенный символ в качестве переменной, а затем вызвали \n"
"макрос с аргументом, имеющим то же имя, что и один из символов в \n"
"расширении.\n"
"<p>"

#: in/chapter04.html:1463
msgid ""
"The expanded macro is generated by the <code>`</code> form. The form is\n"
"returned as the macro's expansion, then evaluated. Substitutions take\n"
"place for symbols following <code>,</code> or <code>,@</code>.\n"
"Everything else appears literally in the expanded macro.<p>"
msgstr ""
"Расширенние макроса создается формой  <code>`</code>. Форма возвращается\n"
"как расширение макроса,а затем вычисляется. Замены происходят для символов\n"
"расположенных после <code>,</code> или <code>,@</code>. Все остальное "
"появляется \n"
"буквально(переносится как есть) в расширении макроса.\n"
"<p>"

#: in/chapter04.html:1468
msgid ""
"The expansion of <code>DEF-I/O</code> is a <code>PROGN</code> form\n"
"containing two <code>DEFUN</code> forms. We wrap the <code>DEFUN</code>s\n"
"like this because a macro's expansion can only be a single form, and we\n"
"need to have this macro define two functions.<p>"
msgstr ""
"Расширение <code>DEF-I/O</code> - это <code>PROGN</code> форма, \n"
"содержащая две формы <code>DEFUN</code>. Мы оборачиваем  <code>DEFUN</code>\n"
"таким образом, потому что расширение макроса может быть только одной "
"формой, \n"
"а нам нужно, чтобы этот макрос определял две функции.\n"
"<p>"

#: in/chapter04.html:1476
msgid ""
"The macro defines a writer function which loops over the list of the\n"
"<code>VARS</code> specified in the macro call, printing each in turn to a\n"
"named output file. The reader function loops over the <em>names</em> of\n"
"the <code>VARS</code>, reading values from an input file and assigning the\n"
"values to the named variables. Note that <code>SET</code> evaluates its\n"
"first argument; this lets us use a variable to contain the name of the\n"
"variable to which we want to assign a value.<p>"
msgstr ""
"Макрос определяет функцию записи, которая циклически перемещается \n"
"по списку <code>VARS</code>, указанных в вызове макроса, печатая каждую\n"
"из них по очереди в именованный выходной файл. Функция чтения(reader) \n"
"выполняет циклический перебор имен <code>VARS</code>, считывая значения \n"
"из входного файла и присваивая их именованным переменным. Обратите \n"
"внимание, что <code>SET</code> вычисляет свой первый аргумент; \n"
"это позволяет нам использовать переменную, чтобы содержать имя \n"
"переменной, которой мы хотим присвоить значение.\n"
"<p>"

#: in/chapter04.html:1479
msgid ""
"Here's how the macro expands to create load and save functions for our\n"
"check writer program:<p>"
msgstr ""
"Вот как макрос расширяется для создания функций загрузки и сохранения \n"
"для нашей программы:<p>"

#: in/chapter04.html:1493
msgid ""
"<pre>\n"
"? (pprint (macroexpand '(def-i/o save-checks load-checks (*checks* *next-"
"check-number* *payees*))))\n"
"(PROGN (DEFUN SAVE-CHECKS (#:G2655)\n"
"            (WITH-OPEN-FILE (#:G2657 #:G2655 :DIRECTION :OUTPUT :IF-EXISTS :"
"SUPERSEDE)\n"
"              (DOLIST (#:G2656 (LIST *CHECKS* *NEXT-CHECK-NUMBER* "
"*PAYEES*))\n"
"                (DECLARE (SPECIAL *CHECKS* *NEXT-CHECK-NUMBER* *PAYEES*))\n"
"                (PRINT #:G2656 #:G2657))))\n"
"          (DEFUN LOAD-CHECKS (#:G2655)\n"
"            (WITH-OPEN-FILE (#:G2657 #:G2655 :DIRECTION :INPUT :IF-DOES-NOT-"
"EXIST\n"
"                             :ERROR)\n"
"              (DOLIST (#:G2656 '(*CHECKS* *NEXT-CHECK-NUMBER* *PAYEES*))\n"
"                (SET #:G2656 (READ #:G2657))))))\n"
"</pre> "
msgstr ""

#: in/chapter04.html:1496
msgid ""
"And here's how we would use the macro, and the functions it defines, to "
"save\n"
"and restore the state information for our program:<p>"
msgstr ""
"А вот как мы будем использовать макрос и функции, которые он определяет, \n"
"чтобы сохранить и восстановить информацию о состоянии для нашей программы:\n"
"<p>"

#: in/chapter04.html:1500
msgid ""
"<pre>\n"
"? (def-i/o save-checks load-checks (*checks* *next-check-number* *payees*))\n"
"T"
msgstr ""

#: in/chapter04.html:1503
msgid ""
"? (save-checks \"checks.dat\")\n"
"NIL"
msgstr ""

#: in/chapter04.html:1506
msgid ""
"? (makunbound '*checks*)\n"
"*CHECKS*"
msgstr ""

#: in/chapter04.html:1509
msgid ""
"? (makunbound '*next-check-number*)\n"
"*NEXT-CHECK-NUMBER*"
msgstr ""

#: in/chapter04.html:1512
msgid ""
"? (makunbound '*payees*)\n"
"*PAYEES*"
msgstr ""

#: in/chapter04.html:1515
msgid ""
"? *PAYEES*\n"
"Error: Unbound variable."
msgstr ""

#: in/chapter04.html:1518
msgid ""
"? (load-checks \"checks.dat\")\n"
"NIL"
msgstr ""
"? (load-checks \"checks.dat\")\n"
"NIL\n"
"</pre>\n"
"<p>Прим. переводчика: здесь мой лисп выдал ошибку, т.к. READER всретил в "
"файле checks.dat\n"
"не читаемый(т.е не востанавливаемый) им префикс: <code> #&ltHASH-TABLE .. </"
"code>.\n"
"Решение состоит в том чтобы отказаться от сохранения *payees* и создавать "
"его\n"
"заново при загрузке, итак необходимо создать функцию \n"
"<pre>\n"
"(defun restore-check (file-name)\n"
"  (load-checks file-name)\n"
"  (setf *payees* (make-hash-table :test #'equal))\n"
"  (map nil #'(lambda (check)\n"
"               (when check\n"
"                 (push check (gethash (check-payee check) *payees*))))\n"
"       *checks*))\n"
";;отказаться от сохранения *payees*\n"
"(def-i/o save-checks load-checks (*checks* *next-check-number*))\n"
"\n"
";;и при загрузке чеков использовать не на прямую (load-checks \"checks.dat"
"\"), а:\n"
"(restore-check \"checks.dat\")\n"
"</pre>\n"
"\n"
" \n"

#: in/chapter04.html:1522
msgid ""
"? *PAYEES*\n"
"(\"WB Infirmary\" \"Acme\")\n"
"</pre> "
msgstr ""
"<pre>\n"
"? *PAYEES*\n"
"(\"WB Infirmary\" \"Acme\")\n"
"</pre> \n"
"<p>(прим. переводчика) не понятно как автор получил этот вывод, т.к это "
"должна быть\n"
"хеш-таблица."

#: in/chapter04.html:1525
msgid "<h2>Reader macros</h2> "
msgstr "<h2>Макросы чтения(или макросы Reader-а)</h2> "

#: in/chapter04.html:1532
msgid ""
"Our check-writing application has one small problem. If we use floating "
"point\n"
"numbers to represent dollars and cents, our sums could be off by a penny in "
"some\n"
"cases.  What we should really do is to represent all currency in terms of "
"whole\n"
"pennies.  We can make a reader macro to help with the input of dollar and "
"cent\n"
"amounts, converting input like <code>$10.95</code> into the corresponding "
"number\n"
"of pennies.<p>"
msgstr ""
"У нашего приложения для записи чеков есть одна небольшая проблема. \n"
"Если мы используем числа с плавающей запятой для представления долларов \n"
"и центов, то в некоторых случаях наши суммы могут быть уменьшены на пенни. \n"
"То, что мы действительно должны сделать, - это представить всю валюту в \n"
"виде целых Пенни. Мы можем сделать макрос считывателя, чтобы помочь с \n"
"вводом долларовых и центовых сумм, Преобразуя входные данные, такие как \n"
"$10,95 в соответствующее количество пенни.\n"
"<p>"

#: in/chapter04.html:1534
msgctxt "in/chapter04.html:1534"
msgid "Here's the code:<p>"
msgstr "Вот вам и код::<p>"

#: in/chapter04.html:1541
msgid ""
"<pre>\n"
"(set-macro-character #\\$\n"
"                     #'(lambda (stream char)\n"
"                         (declare (ignore char))\n"
"                         (round (* 100 (read stream)))))\n"
"</pre> "
msgstr ""

#: in/chapter04.html:1549
msgid ""
"<blockquote>\n"
"The rounding step ensures that the amount is a whole number. Binary\n"
"floating point numbers can not precisely represent all decimal fractions.\n"
"For example, <code>(* 100 9.95)</code> yields\n"
"<code>994.9999999999999</code> and <code>(* 100 1.10)</code> yields\n"
"<code>110.00000000000001</code> on my Lisp system.<p>\n"
"</blockquote> "
msgstr ""
"<blockquote>\n"
"Шаг округления гарантирует, что amount(сумма) является целым числом. \n"
"Двоичные числа с плавающей запятой не могут точно представлять все \n"
"десятичные дроби. Например, <code>(* 100 9.95)</code> дает \n"
"<code>994.9999999999999</code> и <code>(* 100 1.10)</code> дает\n"
"<code>110.00000000000001</code> в моей системе Lisp.<p>\n"
"</blockquote> "

#: in/chapter04.html:1553
msgid ""
"This says to set <code>$</code> to be a macro character which, when "
"encountered\n"
"by the reader, calls <code>READ</code> to get a number and return the "
"nearest\n"
"whole number after multiplying by 100.  It's used like this:<p>"
msgstr ""
"Он говорит о том, чтобы установить знак <code>$</code> в качестве \n"
"макрознака, который, когда он встречается с читателем, вызывает \n"
"<code>READ</code>, чтобы получить число и вернуть ближайшее целое \n"
"число после умножения на 100. Он используется вот так:\n"
"<p>"

#: in/chapter04.html:1557
msgid ""
"<pre>\n"
"? $9.95\n"
"995"
msgstr ""

#: in/chapter04.html:1561
msgid ""
"? $-7.10\n"
"-710\n"
"</pre> "
msgstr ""

#: in/chapter04.html:1566
msgid ""
"Now that you can enter dollar amounts directly, you may want to modify the\n"
"check-writing application to print amounts in whole cents as dollars and\n"
"cents. To do this, you would redefine the <code>CHECK</code> structure\n"
"with a custom print function, as follows:<p>"
msgstr ""
"Теперь, когда вы можете вводить суммы в долларах напрямую, вы можете "
"изменить\n"
"приложение для записи чеков, чтобы печатать суммы в целых центах как доллары "
"и\n"
"центы. Для этого необходимо переопределить структуру проверки с помощью\n"
"пользовательской функции печати следующим образом:<p>"

#: in/chapter04.html:1580
msgid ""
"<pre>\n"
"(defstruct (check\n"
"            (:print-function\n"
"             (lambda (check stream depth)\n"
"               (declare (ignore depth))\n"
"               (format stream \"#S(CHECK NUMBER ~S DATE ~S AMOUNT $~,2,-2F "
"PAYEE ~S MEMO ~S)\"\n"
"                       (check-number check)\n"
"                       (check-date check)\n"
"                       (check-amount check)\n"
"                       (check-payee check)\n"
"                       (check-memo check)))))\n"
"  number date amount payee memo)\n"
"</pre> "
msgstr ""

#: in/chapter04.html:1583
msgid ""
"Then, the <code>$</code> reader macro and the <code>CHECK</code> print "
"function \n"
"for its <code>AMOUNT</code> slot complement each other perfectly:<p>"
msgstr ""
"Затем, макрос чтения <code>$</code> и функция печати <code>CHECK</code>\n"
" для его слота <code>AMOUNT</code> прекрасно дополняют друг друга:<p>"

#: in/chapter04.html:1588
msgid ""
"<pre>\n"
"? (make-check :amount $9.95)\n"
"#S(CHECK NUMBER NIL DATE NIL AMOUNT $9.95 PAYEE NIL MEMO NIL)\n"
"</pre> "
msgstr ""

#: in/chapter04.html:1601
msgid ""
"<hr>\n"
"<div align=\"center\">\n"
"<a href=\"contents.html\">Contents</a> | <a href=\"cover.html\">Cover</a> "
"<br> \n"
"<a href=\"chapter03.html\">Chapter 3</a> | Chapter 4 | <a href=\"chapter05."
"html\">Chapter 5</a> \n"
"</div>\n"
"<hr>\n"
"<address>\n"
"Copyright &copy; 1995-2001, David B. Lamkins<br>\n"
"All Rights Reserved Worldwide<br>\n"
"<br>\n"
"This book may not be reproduced without the written consent of its author.  "
"Online distribution is restricted to the author's site.\n"
"</address> \n"
"</body> </html> "
msgstr ""
