<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<title>Successful Lisp - Chapter 4</title>
</head> 

<body bgcolor="white" text="black">
<h1>Глава 4 - Овладение Основами</h1> 

<P>
Мы изучили основные понятия Лисп в двенадцати уроках 
<A HREF="chapter03.html">Главы 3</A>. Если вы чувствуете, что у вас есть 
очень хорошее понимание этих основ, или если вы уже работали с Lisp раньше, 
вы можете просмотреть оставшуюся часть этой главы.
</P>

<P>Мы рассмотрим некоторые материалы из 
<A HREF="chapter03.html">Главы 3</A>, используя практический подход. 
По пути вы изучите некоторые новые техники, которые должны были подождать, 
пока не будут введены все основные принципы; если вы новичок и не читали 
<A HREF="chapter03.html">Главу 3</A>, вернитесь и прочитайте ее, 
прежде чем пытаться выполнять упражнения в этой главе.
</P>

<P>
Во время работы над этой главой вы должны иметь доступ к системе разработки
Lisp. Когда вы будете читать эту главу, пожалуйста, найдите время, чтобы
запустить примеры с помощью вашей системы Lisp. Это даст вам возможность
узнать, как ваша система Lisp реагирует на ввод данных, включая любые ошибки,
которые вы можете сделать. (Если вы не допускаете никаких ошибок при
разборе примеров, вам следует набраться смелости и попытаться изменить
некоторые примеры. В <A HREF="appendix-a.html">Приложении A</A> перечислены
несколько коммерческих, условно-бесплатных и бесплатных систем Lisp для компьютеров Macintosh, DOS и Windows.
</P>

<H2>Руки-вверх! "Главный(верхний) цикл"</H2>

<P>
Вы взаимодействуете с системой Lisp через встроенный фрагмент кода, 
называемый toploop(верхний/главный цикл/REPL), который повторяет три простых 
шага до тех пор, пока работает ваша система Lisp:
</P>

<PRE>
1. Read - Читает выражение (вы предоставляете выражение).
2. Evaluate - Исполняет только что прочитанное выражение.
3. Print - Печатает результат(ы) выполнения.
</PRE>

<P>
Это также называется циклом read-eval-print" loop(REPL). Некоторые системы 
Lisp вычисляют выражение с помощью интерпретатора Lisp; современные системы
используют компилирующий вычислитель, который сначала компилирует 
выражение в машинный код, а затем выполняет код. Компилирующий Вычислитель
также является инкрементным компилятором, названным так потому, что он может
компилировать программу с шагом в одно выражение.
</P>

<P>
Верхний цикл также предоставляет минимальный пользовательский интерфейс-
подсказку, указывающую, что он готов прочитать новое выражение , - 
и способ изящно ловить любые ошибки, которые вы можете сделать.
</P>

<P>
Если бы вы написали код Lisp для верхнего цикла, он выглядел бы примерно так:
</P>

<PRE>
(loop
   (terpri)
   (princ 'ready&gt;)
   (print (eval (read))))
</PRE>

<BLOCKQUOTE>
<P>Примечание 1: (terpri) выводит пустую строку.
</P>

<P>Примечание 2: (loop ...) выполняет свои формы по порядку, 
а затем повторяет-мы увидим больше циклов(<CODE>LOOP</CODE>)
в <A HREF="chapter05.html">главе 5</A>.
</P>

<P>Примечание 3: (eval ...) возвращает результат вычисления формы. 
Это одно из немногих законных применений <CODE>EVAL</CODE> - вы должны
остерегаться кода Lisp, который использует <CODE>EVAL</CODE> по причинам,
отличным от вычисления произвольных выражений Lisp, предоставляемых во время выполнения.
</P>
</BLOCKQUOTE>

<P>
На самом деле, вы можете ввести это в свою систему Lisp и временно запустить свой собственный верхний цикл поверх верхнего цикла Lisp. Попробуте! 
Вы увидите, что приглашение вашей системы заменено на <TT>READY&gt;</TT>.
Каждая допустимая форма Lisp, которую вы введете, будет прочитана, 
выполнена и напечатана вашим верхним циклом. В зависимости от вашей 
системы Lisp, это может произойти, как только выражение будет завершено
- либо пробелом, либо соответствующей круглой скобкой или двойной кавычкой
- или вам, возможно, придется нажать клавишу 
 <TT>RETURN</TT> или <TT>ENTER</TT>.
</P>

<P>Ваш сеанс Lisp может выглядеть следующим образом, где <CODE>?</CODE>
является запросом системы Lisp на ввод данных:
</P>

<PRE>
? (loop
     (terpri)
     (princ 'ready&gt;)
     (print (eval (read))))

READY&gt;(+ 1 2 3)

6
READY&gt;(cons 1 (cons 2 (cons 3 nil)))

(1 2 3)
READY&gt;
</PRE>

<P>
Есть два способа выйти из вашего верхнего цикла. Один из них заключается в
прерывании, как правило, с помощью специального нажатия клавиши или 
команды меню - обратитесь к руководству вашей системы Lisp. 
Другой способ заключается в том, чтобы ввести ошибочное выражение - 
например, <CODE>(+ 'A 1)</CODE> - в приглашении <TT>READY&gt;</TT>, 
которое выбросит вас в отладчик Lisp.
</P>

<P>В Лиспе, отладчика доступны через "break loop/обрыв цикла." Он ведет 
себя так же, как верхний цикл, но принимает дополнительные команды 
для проверки или изменения состояния "broken/поврежденного" вычисления. 
"break loop" сильно различаются между системами Lisp. В руководстве будет 
описан "break loop". Проверьте также под индексными записями руководства для "отладчика."</P>

<H2>Обнаружение и избежание распространенных ошибок</H2>

<P>- Я ввел Лисп выражение, но ничего не произошло."Наиболее распространенной
причиной этой проблемы является отсутствие соответствующего разделителя - 
обычно это правая скобка или двойная кавычка- где-то в вашем выражении. 
В отличие от некоторых систем разработки, которые обрабатывают ваш ввод 
каждый раз, когда вы вводите строку кода, Lisp ждет, пока вы введете полное
выражение, прежде чем пытаться что-либо обработать. Что произойдет, если вы
введете в свою систему следующий код?</P>

<PRE>
? (defun bad-1 ()
     (print "This is a bad function definition)
     (print "But I'll try it anyway..."))
</PRE>

<P>
Выглядит неплохо, да? Все скобки совпадают, и вы нажимаете клавишу 
<CODE>ENTER</CODE> в последний раз, и... Ничего. В строковом аргументе первого
оператора print отсутствует закрывающая двойная кавычка, что превращает
остальную часть ваших входных данных в часть строки. Вы будете так ошибаться
не один раз (поверьте мне), поэтому лучше всего обратиться к вашему руководству
по системе Lisp, чтобы узнать, как отредактировать ожидающий Ввод, чтобы вы могли добавить недостающую двойную кавычку к тому, что вы уже набрали.
</P>

<P>Вот еще один кусок кода, который заставит вашу систему Lisp 
казаться спящей:
</P>

<PRE>
? (defun factorial (n)
     (cond ((&lt;= n 0)  1)
           (t (* n (factorial (- n 1)))))
</PRE>

<P>
Опять же, быстрый просмотр не находит ничего плохого. Но посчитайте скобки, 
и вы обнаружите, что левые на единицу превосходят правых. Когда вы нажимаете
последнюю клавишу enter, считывающая часть цикла чтения-выполнения-печати 
Lisp все еще нуждается в еще одной правой скобке, прежде чем она сможет
закончить свою работу и передать ваше выражение вычислителю.
</P>

<P>
Обеих этих ситуаций можно избежать, если в вашей системе Lisp есть редактор,
который соотносит разделители при вводе текста. В некоторых системах это
соответствие на мгновение мигает левым разделителем, когда вы вводите
соответствующий правый разделитель. Или ваша система может мигать или 
выделять соответствующий разделитель того, что находится под курсором;
некоторые системы даже выделяют все промежуточное выражение. Еще раз 
проверьте свое руководство - эта функция <STRONG>необходима</STRONG> 
для комфортного программирования на Лиспе.
</P>

<P>Я путаюсь в том, когда использовать <CODE>'</CODE>". Это действительно
распространенная проблема для людей, которые только учатся программировать,
но она умудряется озадачить и случайного Опытного (не Лиспового) программиста.
Правило очень простое:
</P>

<BLOCKQUOTE>
<P>Если вы хотите, чтобы имя означало значение, <EM>Не</EM> 
квотируйте его.
</P>

<P>Если вы хотите только имя установленное для символа, Квотируйте его.
</P>
</BLOCKQUOTE>

<P>
Есть несколько исключений из этого правила, и все они связаны с 
самовычисляющимися символами. Эти символы всегда представляют сами себя.
Ими являются:
</P>

<PRE>
T
NIL
</PRE>

<P>
и символы ключевые слова(<EM>keyword</EM>). Символ ключевое слово - 
это любой символ, начинающийся со знака <CODE>:</CODE> по причинам, 
которые станут ясны, когда мы рассмотрим <EM>пакеты</EM> в 
<A HREF="chapter31.html">Главе 31</A>. Символ ключевое слово всегда 
вычисляется сам в себя, таким образом:
</P>

<PRE>
? :foo
:FOO
? :some-long-but-nondescript-keyword-symbol
:SOME-LONG-BUT-NONDESCRIPT-KEYWORD-SYMBOL
</PRE>

<P>
Обычно квотирование не навредит самовычисляемому символу. 
Например, <CODE>NIL</CODE> идентичен <CODE>'NIL</CODE>. 
Добавление цитаты - это вопрос стиля и предпочтений.
</P>

<P>Время для поп-викторины! Что плохого в следующем коде?</P>

<PRE>
? (defun factorial (n)
     (cond ((&lt;= 'n 0)  1)
           (t (* 'n (factorial (- 'n 1))))))
</PRE>

<P>Правильно. Выражения <CODE>'N</CODE> неверны, потому что нам нужно 
значение символа (число, которое изменяется при выполнении функции), а 
<em>не</em> сам символ.
</P>

<H2>Определение простых функций</H2>

Мы уже видели несколько определений функций: <code>FACTORIAL</code>
функция (выше) и одна или две функции в 
<a href="chapter03-07.html">Chapter 3, Lesson 7</a>.. Для обзора, функция определяется следующим образом:
<p>

<pre>
(defun <i>function-name</i> (<i>argument-names</i> ...)
   <i>function-body</i> )

</pre> 

<code>(</code> <i>argument-names</i> <code>...)</code> называется 
лямбда-списком( <dfn>lambda list</dfn>). Имена в этом списке привязываются 
к значениям при вызове функции. Тело функции может ссылаться на эти имена;
идентичные имена, появляющиеся в другом месте вашей программы (то есть вне 
тела функции), не имеют отношения к функции. Кроме того, если ваша функция
изменяет привязку аргумента внутри функции, вызывающий объект не получает
измененное значение. Правильный способ вернуть значения из функции Lisp-это
вернуть их как значение функции.
<p>

Например:<p>

<pre>
? (defun quadratic-roots (a b c)
    "Returns the roots of a quadratic equation aX^2 + bX + c = 0"
    (let ((discriminant (- (* b b) (* 4 a c))))
      (values (/ (+ (- b) (sqrt discriminant)) (* 2 a))
              (/ (- (- b) (sqrt discriminant)) (* 2 a)))))
QUADRATIC-ROOTS

? (quadratic-roots 1 2 4)
#c(-1.0 1.7320508075688772)
#c(-1.0 -1.7320508075688772)

? (quadratic-roots 2 -16 36)
#c(4.0 1.4142135623730951)
#c(4.0 -1.4142135623730951)

? (quadratic-roots 1 4 4)
-2
-2

? (quadratic-roots 1 -14 49)
7
7

? (quadratic-roots 1 8 4)
-0.5358983848622456
-7.464101615137754

? (quadratic-roots 1 4 -5)
1
-5

</pre> 

Функция <code>QUADRATIC-ROOTS</code> показывает, как использовать 
строку документации. Первая форма в теле функции-это строка. 
Она не влияет на результат функции, но она записывается системой Lisp 
для последующего использования:
<p>

<pre>
? (documentation 'quadratic-roots 'function)
"Returns the roots of a quadratic equation aX^2 + bX + c = 0"

</pre> 

Эта функция также показывает, как мы можем вернуть два значения из функции.
Вы узнаете формулу для корней квадратного уравнения:<p>

<pre>

             /--------
       +    /  2
   - b -  \/  b  - 4ac
 ----------------------
          2a

</pre> 

Она говорит вам, что уравнение имеет два решения (которые в некоторых 
случаях могут совпадать). В Lisp очень просто вернуть оба значения 
сразу, используя форму <code>(VALUES <i>value-1</i>
<i>value-2</i>)</code>.<p>

Если вы когда-либо решали эту проблему на компьютерном языке, который 
не поддерживает арифметику комплексных чисел, вам нужно было найти способ 
подать сигнал вызывающему, когда корни являются мнимыми (т. е. когда 
дискриминант меньше нуля). Lisp просто делает правильную вещь: 
квадратный корень из отрицательного числа-это комплексное число:<p>

<pre>
? (sqrt -1)
#c(0 1)

</pre> 

Предположим, что вы хотите, чтобы <code>QUADRATIC-ROOTS</code>
возвращала только одно значение, если корни совпадают. Думая, что, 
возможно, вы можете вернуть что-то особенное в качестве второго значения
формы <code>VALUE</code>, вы пробуете <code>NIL</code> :


<pre>
? (values 2 nil)
2
NIL

</pre> 

Но это не работает, потому что <code>NIL</code>-это такое же значение, 
как и любое другое в Lisp, и не получает специального обращения, как 
указатель nil, например, в другом языке.
<p>

Таким образом, вы думаете только об одном значении в форме <code>VALUES</code>:

<pre>
? (values 3)
3

</pre> 

Конечно же, это работает. Так почему бы неработает 
<code>(VALUES <i>value-1</i> 
<i>некоторая форма-которая-ничего-не-возвращает</i>)</code>? Подобно этому
<p>

<pre>
? (values)

? (values 4 (values))
4
NIL

</pre> 

К сожалению, это не делает того, что вы ожидаете; внешняя форма 
<code>VALUES</code> ожидает значение от своего второго аргумента,
<code>(VALUES)</code> и заменяет отсутствующее значение на <code>NIL</code>.
Это одно из важных правил множественных значений. 
Другое правило заключается в том, что формы, получающие несколько значений 
(см. <a href="chapter03-09.html">Глава 3, Урок 9)</a>), заменяют недостающее
значение <code>NIL</code>.
<p>

Небольшое размышление убеждает вас, что вы не можете получить 
<code>VALUES</code>, которые ничего не возвращают для чего-то, 
поэтому вы рассматриваете возможность иметь два отдельных возврата. 
Это дает следующая функция:<p>

<pre>
? (defun quadratic-roots-2 (a b c)
    "Returns the roots of a quadratic equation aX^2 + bX + c = 0.
Returns only one value if the roots are coincident."
    (let ((discriminant (- (* b b) (* 4 a c))))   ; zero if one root
      (cond ((zerop discriminant)
             ;; coincident roots -- return one value
             (/ (+ (- b) (sqrt discriminant)) (* 2 a)))
            (t
             ;; two distinct roots
             (values (/ (+ (- b) (sqrt discriminant)) (* 2 a))
                     (/ (- (- b) (sqrt discriminant)) (* 2 a)))))))
QUADRATIC-ROOTS-2

? (quadratic-roots-2 1 -14 49)
7

? (quadratic-roots-2 1 4 -5)
1
-5

</pre> 

<blockquote> Примечание: <code>ZEROP</code> это <i>предикат/predicate</i> 
(отсюда суффикс <code>P</code>) которые возвращает истину когда его
числовой аргумент равен нулю. Запись <code>(ZEROP <i>n</i>)</code> это тоже
самое что и запись <code>(= <i>n</i> 0)</code>. 
</blockquote> 

Обратите внимание, что <code>QUADRATIC-ROOTS-2</code> имеет две строки
документации. Новая строка является частью строки:
<p>

<pre>
? (documentation 'quadratic-roots-2 'function)
"Returns the roots of a quadratic equation aX^2 + bX + c = 0.
Returns only one value if the roots are coincident."

</pre> 

Также обратите внимание на использование комментариев для описания двух 
вариантов возврата. В Lisp комментарий начинается с точки с запятой и
продолжается до конца строки. По общему правилу комментарии к собственной
строке в теле функции отступаются на тот же уровень, что и остальная часть 
кода, и предваряются двумя точками с запятой. Комментарий к той же строке, 
что и код, имеет только одну точку с запятой (опять же, по соглашению).
<p>

Лямбда-список может иметь ряд дополнительных функций. Мы рассмотрим два 
из них здесь, а остальные-в <a href="chapter21.html">Главе 21</a>.
<p>

Если вы хотите создать функцию, которая принимает один или несколько
необязательных аргументов, используйте ключевое слово 
<code>&amp;OPTIONAL</code>, за которым следует список имен 
параметров, например:
<p>

<pre>
? (defun silly-list-1 (p1 p2 &amp;optional p3 p4)
    (list p1 p2 p3 p4))
SILLY-LIST-1

? (silly-list-1 'foo 'bar)
(FOO BAR NIL NIL)

? (silly-list-1 'foo 'bar 'baz)
(FOO BAR BAZ NIL)

? (silly-list-1 'foo 'bar 'baz 'rux)
(FOO BAR BAZ RUX)

</pre> 

Необязательные параметры по умолчанию равны  NIL, если вызов не предоставляет значения. Загляните вперед в <a href="chapter21.html">Главу 21</a>, 
чтобы узнать, как изменить значение по умолчанию необязательного 
параметра.
<p>

Если вы укажете меньше, чем количество обязательных параметров (слева от <code>&amp;OPTIONAL</code>  в приведенном выше примере), или больше, 
чем общее количество обязательных плюс необязательные параметры, 
вы получите ошибку:
<p>

<pre>
? (silly-list-1 'foo)
Error: Not enough arguments.

? (silly-list-1 'foo 'bar 'baz 'rux 'qup)
Error: Too many arguments.

</pre> 

Если вы хотите иметь неопределенное количество параметров, вы можете 
назвать один параметр, чтобы получить список всех "дополнительных", 
используя символ <code>&amp;REST</code> в лямбда-списке, например:
<p>


<pre>
? (defun silly-list-2 (p1 p2 &amp;rest p3)
    (list p1 p2 p3))

? (silly-list-2 'foo 'bar)
(FOO BAR NIL)

? (silly-list-2 'foo 'bar 'baz)
(FOO BAR (BAZ))

? (silly-list-2 'foo 'bar 'baz 'bob 'tom 'don)
(FOO BAR (BAZ BOB TOM DON))

</pre> 

Параметр <code>&amp;REST</code> должен соответствовать всем необходимым
параметрам. Вы можете комбинировать <code>&amp;REST</code> и 
<code>&amp;OPTIONAL</code> дополнительные параметры, соблюдая следующий порядок:<p>

<pre>
? (defun silly-list-3 (p1 p2 &amp;optional p3 p4 &amp;rest p5)
    (list p1 p2 p3 p4 p5))
SILLY-LIST-3

? (silly-list-3 'foo 'bar)
(FOO BAR NIL NIL NIL)

? (silly-list-3 'foo 'bar 'baz)
(FOO BAR BAZ NIL NIL)

? (silly-list-3 'foo 'bar 'baz 'bob)
(FOO BAR BAZ BOB NIL)

? (silly-list-3 'foo 'bar 'baz 'bob 'tom)
(FOO BAR BAZ BOB (TOM))

? (silly-list-3 'foo 'bar 'baz 'bob 'tom 'don)
(FOO BAR BAZ BOB (TOM DON))

</pre> 

<h2><a name="global-vars-and-consts">Использование глобальных переменных и констант</a> </h2> 

В <a href="chapter03-03.html">Уроке 3</a> мы использовали <code>SETQ</code>
для определения глобальных переменных. Вы можете сделать это с помощью формы верхнего уровня, как в <a href="chapter03-03.html">Уроке 3</a>, или из функции, такой как эта:<p>

<pre>
? (defun set-foo-globally (x)
    (setq foo x))
SET-FOO-GLOBALLY

? foo
Error: unbound variable FOO

? (set-foo-globally 3)
3

? foo
3

</pre> 

В зависимости от вашей системы Lisp, вы могли видеть предупреждающее 
сообщение, когда вы определили  <code>SET-FOO-GLOBALLY</code>:<p>

<pre>
? (defun set-foo-globally (x)
    (setq foo x))
Warning: undeclared free variable FOO, in SET-FOO-GLOBALLY.
SET-FOO-GLOBALLY

</pre> 

Это не ошибка - функция делает то, что мы хотим. Но <code>FOO</code>
считается свободным, потому что функция не создает привязку для 
<code>FOO</code>. Привязки переменных создаются, в частности, с 
помощью лямбда-списков (списка аргументов функции) и форм 
<code>LET</code> (см. <a href="chapter03-06.html">Урок 6</a>).
<p>

Моя система Lisp предупреждает меня о свободных переменных в определениях
функций, потому что они могут быть признаком типографской ошибки:
<p>

<pre>
? (setq *olympic-year* 1996)
1996

? (defun set-next-olympic-year ()
    (setq *olympic-year* (+ *olmpic-year* 2)))
Warning: undeclared free variable *OLMPIC-YEAR*, in SET-NEXT-OLYMPIC-YEAR.
SET-NEXT-OLYMPIC-YEAR

</pre> 

Здесь я неправильно написал второй экземпляр моей глобальной переменной 
<code>*OLYMPIC-YEAR*</code>, и компилятор предупредил меня. 
Обратите внимание, что я не получил предупреждения за правильно написанный
<code>*OLYMPIC-YEAR*</code>, потому что я определил его глобально в форме
<code>SETQ</code> верхнего уровня.
<p>

Существует еще два способа определения глобальных переменных в Lisp:
<p>

<pre>
? *var1*
Error: unbound variable

? (defvar *var1* 1)
*VAR1*

? *var1*
1

? (defvar *var1* 2)
*VAR1*

? *var1*
1

? (defparameter *a-var* 3)
*A-VAR*

? *a-var*
3

? (defparameter *a-var* 4)
*A-VAR*

? *a-var*
4

</pre> 

<code>DEFVAR</code> устанавливает глобальное значение только в певый раз-
другими словами, переменная не должна иметь значения, чтобы <code>DEFVAR</code>
возимел эффект. Это полезно для переменной, которая должна иметь начальное
значение, но не должна быть сброшена, если вы повторно вычислите форму
<code>DEFVAR</code> (как это бывает, если вы перезагружаете файл, содержащий <code>DEFVAR</code> в дополнение к другому коду).
<p>

<code>DEFPARAMETER</code>  устанавливает глобальное значение каждый раз, 
когда он используется. Хотя эффект такой же как у <code>SETQ</code> формы,
<code>DEFPARAMETER</code> является предпочтительным, поскольку он дает неявное
документирование как определяющая форма(<i>defining form</i>) (в Лиспе, любая
форма, которая начинается со слова <code>DEF</code>, скорее всего, 
является определяющей формой), и поэтому, что она позволяет добавлять 
документацию к переменной:<p>

<pre>
? (defparameter *a-var* 3 "The number of things I have to do today.")
*A-VAR*

? (documentation '*a-var* 'variable)
"The number of things I have to do today."

</pre> 

Вы также можете добавить строку документации в форму <code>DEFVAR</code>.
<p>

В приведенных выше примерах мы начали следовать условию, согласно которому 
имена глобальных переменных начинаются и заканчиваются звездочкой. 
Когда вы читаете Лисп-код других программистов, вы увидите, что они 
следуют этому соглашению. Они будут ожидать, что вы сделаете то же самое.
<p>

<code>DEFCONSTANT</code> аналогичен <code>DEFVAR</code> и
<code>DEFPARAMETER</code>, за исключением того, что он определяет имя, 
которое известно глобально и имеет постоянное значение. 
Это означает, что везде, где вы читаете имя, которое было определено 
в форме <code>DEFCONSTANT</code>, вы можете заменить значение, 
заданное формой <code>DEFCONSTANT</code>. Это также означает, что 
вы не можете переопределить именованную константу, даже используя 
другую форму <code>DEFCONSTANT</code> с другим значением.
<p>

Некоторые Лисп-программисты дают константам имена, которые начинаются и
заканчиваются знаками плюс. Полезно называть константы особым образом, 
чтобы вы случайно не попытались использовать это имя для другой цели. 
После того, как имя было определено константой, вы не можете даже 
использовать его для кажущегося безобидным использования, такого как 
параметр в лямбда-списке или привязке <code>LET</code>.
<p>

<h2>Определение рекурсивных функций</h2> 

Функция, которая сама себя вызывает, является рекурсивной(<em>recursive</em>).
Рекурсивный вызов может быть прямым (функция вызывает саму себя) или 
косвенным (функция вызывает другую функцию, которая-возможно, после 
вызова еще некоторого числа функций-вызывает исходную функцию).
<p>

Вам нужно следовать двум простым эмпирическим правилам, чтобы заставить
рекурсивные функции работать. Эти правила предполагают структуру рекурсивной
функции - она должна вести себя соответствующим образом в соответствии со с
воими текущими входными данными:<p>

<ol>
<li>Один случай <em>не</em> должен выполнять рекурсивный вызов.
<li>В других случаях необходимо <em>уменьшить</em> объем работы, 
выполняемой при рекурсивном вызове.
</ol> 

Давайте возьмем функцию <code>FACTORIAL</code>, которую мы уже использовали 
в нескольких примерах, и посмотрим, как она следует этим правилам:

<pre>
(defun factorial (n)
  (cond ((zerop n) 1)
        (t (* n (factorial (1- n))))))
</pre> 

Эта функция имеет два случая, соответствующие двум ветвям <code>COND</code>.
Первый случай говорит о том, что факториал нуля-это всего лишь единица, 
и никакого рекурсивного вызова не требуется. Второй случай говорит, 
что факториал некоторого числа-это число, умноженное на факториал на 
единицу меньшего числа, - это рекурсивный вызов, который уменьшает 
количество оставшейся работы, потому что он приближает число к 
завершающему условию первого предложения <code>COND</code>. (Для ясности я
предположил, что число, изначально данное <code>FACTORIAL</code>,
неотрицательно.)
<p>

Давайте рассмотрим еще одно простое рекурсивное определение. Длина пустого 
списка равна нулю. Длина непустого списка равна единице плюс длина списка,
уменьшенная на один элемент. Эти два утверждения точно указывают на то, 
что требуется по нашим эмпирическим правилам, приведенным выше. 
Первое утверждение дает ответ для списка известной длины - тривиальный 
случай - пустой список. Второе утверждение дает ответ для списка 
неизвестной длины в терминах ответа для списка уменьшенной длины. 
Вот как это переводится в код:
<p>

<pre>
? (defun my-length (list)
    (cond ((null list) 0)
          (t (1+ (my-length (rest list))))))
MY-LENGTH

? (my-length '(a b c d))
4

</pre> 

<code>NULL</code> является истинным для пустого списка, поэтому первое
предложение <code>COND</code> возвращает ноль для пустого списка. 
Второе предложение <code>COND</code> вычисляется (если первое предложение
пропущено), потому что его условие равно <code>T</code>; оно добавляет один
к результату рекурсивного вызова списка, который на один элемент короче 
(список состоит из его первого(<code>FIRST</code>) элемента и остальной
(<code>REST</code>) части списка.)
<p>

Обратите внимание на сходство между <code>FACTORIAL</code> и 
<code>MY-LENGTH</code>. Базовый случай всегда является первым в 
<code>COND</code>, потому что он должен быть проверен <em>перед</em> 
рекурсивным случаем - в противном случае рекурсивные вызовы функций
никогда бы не закончились.<p>

Если вы хотите визуализировать, как работают рекурсивные вызовы, 
вы можете использовать макрос трассировки(<code>TRACE</code>) вашей 
системы Lisp:<p>

<pre>
? (trace my-length)
NIL

? (my-length '(a b c d))
; Calling (MY-LENGTH (A B C D)) 
;  Calling (MY-LENGTH (B C D)) 
;   Calling (MY-LENGTH (C D)) 
;    Calling (MY-LENGTH (D)) 
;     Calling (MY-LENGTH NIL) 
;     MY-LENGTH returned 0
;    MY-LENGTH returned 1
;   MY-LENGTH returned 2
;  MY-LENGTH returned 3
; MY-LENGTH returned 4
4

</pre> 

Здесь вы можете ясно видеть рекурсивные вызовы списков уменьшающейся 
длины, завершающий вызов с пустым списком (<code>NIL</code>) и возврат 
каждого из них, добавляющий единицу к длине более короткого списка.
<p>

<blockquote> Примечание: ваш компилятор Lisp может внутренне оптимизировать
рекурсивные вызовы <code>MY-LENGTH</code>, так что вы не увидите их с помощью
трассировки(<code>TRACE</code>). Если это произойдет, вы можете отключить
оптимизацию, вычислив форму <code>(DECLAIM (OPTIMIZE (SPEED
0) (DEBUG 3)))</code>, а затем повторно вычислив форму
<code>(DEFUN MY-LIST ...)</code>.
</blockquote> 

<a name="tail-recursion"></a> 
<h2>Хвостовая/Tail рекурсия</h2> 

Вызов функции, которая вызывает себя в качестве своего самого 
последнего действия, называется хвостовым рекурсивным вызовом. 
Вот две версии  функции расчета факториала, чтобы проиллюстрировать 
разницу между хвостовым рекурсивным вызовом и обычным рекурсивным 
вызовом:
<p>

<pre>
<i>; Normal recursive call</i> 

(defun factorial (n)
  (cond ((zerop n) 1)
        (t (*      <i>; * is the last function called</i> 
            n
            (factorial (- n 1))))))

<i>; Tail-recursive call</i> 

(defun factorial-tr (n)
  (factorial-tr-helper n 1))

(defun factorial-tr-helper (n product)
  (cond ((zerop n) product)
        (t 
         <i>; factorial-tr-helper is the last function called</i> 
         (factorial-tr-helper (- n 1) (* product n)))))

</pre> 

<code>FACTORIAL-TR</code> вызывает <code>FACTORIAL-TR-HELPER</code>,
передавая исходный аргумент <code>N</code>, плюс дополнительный аргумент,
используемый в качестве начального значения накопителя(accumulator) 
для расчета  результата, который станет значением расчета факториала. 
<code>FACTORIAL-TR-HELPER</code> вывает себя рекурсивно, уменьшая 
<code>N</code> в процессе (это приближает вычисление к его конечному 
условию, <code>(ZEROP N)</code>)) и в то же время умножая произведение 
на текущее значение <code>N</code>.
<p>

Поскольку <code>FACTORIAL-TR-HELPER</code> является последней выполняемой
функцией при рекурсивном вызове, это хвостовой рекурсивный вызов. 
Сравните его с рекурсивным вызовом предыдущий факториальной функции, 
где результат используется функцией <code>*</code> для получения 
значения функции. Рекурсивный вызов является хвосто-рекурсивным только 
в том случае, если он является самой последней функцией, выполняемой в рекурсивном вызове.
<p>

После всего этого объяснения вы, вероятно, задаетесь вопросом: 
"Что хорошего в хвостовой рекурсии? Для  расчета факториала это только 
усложнило код." Ответ состоит из двух частей: что Лисп может сделать 
<em>для</em> вас, и что Лисп может сделать <em>для</em> вас в присутствии
хвостовой рекурсии.
<p>

Некоторые компиляторы Lisp могут оптимизировать хвостовые рекурсивные вызовы.
Чтобы понять преимущества такой оптимизации, давайте сначала рассмотрим, что
должен делать компилятор для обычного вызова функции: он должен генерировать
код для вычисления аргументов и помещать их в стек (где они могут быть найдены
вызываемой функцией), сохранить адрес в коде, к какому элемент управления
вернется после рекурсивного вызова, и, наконец, вызывать функцию. Одним из
следствий этой кодовой последовательности является то, что функция, которая
делает много рекурсивных вызовов (как это делает <code>FACTORIAL</code> 
для большого значения <code>N</code>), будет использовать много стекового
пространства-обычно очень ограниченного ресурса.
<p>

Компилятор, оптимизирующий хвостовые рекурсивные вызовы, генерирует код
для выполнения следующих операций для хвостового рекурсивного вызова: 
вычисление аргументов и замена старых значений аргументов только что
вычисленными, а затем переход к началу функции. Обратите внимание, 
что этот код не использует никакого дополнительного пространства стека, 
и вызывает функцию с помощью jump вместо инструкции call - это менее
дорогостоящая операция на всех компьютерах.<p>

Итак, это ответ на первый вопрос: "что Лисп может сделать <em>для</em> меня,
если я напишу вызов хвосто-рекурсивной функции?" Вы получаете более 
эффективный код, если компилятор выполняет эту оптимизацию; это 
не обязательно, но лучшие из них делают это.
<p>

Оптимизация хвостовой рекурсии звучит как хорошая вещь. Она должна
производить более быстрый код - но она может сбить вас с толку во 
время отладки. Отладчик обычно отображает каждый вызов функции, глядя 
на кадр стека, созданный при входе в функцию. Таким образом, если 
вы случайно вылетаете(break) из середины рекурсивной функции, вы 
ожидаете увидеть кадр стека для каждого рекурсивного вызова:
<p>

<pre> 
? (defun broken-factorial (n)
    (cond ((= n 0) 1)
          ((= n 1) (break))
          (t (* n (broken-factorial (- n 1))))))
BROKEN-FACTORIAL

? (broken-factorial 6)
; Break: While executing: BROKEN-FACTORIAL

&gt; (backtrace)
1: (BROKEN-FACTORIAL 1)
2: (BROKEN-FACTORIAL 2)
3: (BROKEN-FACTORIAL 3)
4: (BROKEN-FACTORIAL 4)
5: (BROKEN-FACTORIAL 5)
6: (BROKEN-FACTORIAL 6)
7: <i>... more stack frames, unrelated to BROKEN-FACTORIAL ...</i> 
&gt; (abort)
; Return to top level

? (defun broken-tr-factorial (n)
    (broken-tr-factorial-1 n 1))
BROKEN-TR-FACTORIAL

? (defun broken-tr-factorial-1 (n v)
    (cond ((= n 0) v)
          ((= n 1) (break))
          (t (broken-tr-factorial-1 (- n 1) (* n v)))))
BROKEN-TR-FACTORIAL

? (broken-tr-factorial 6)
; Break: While executing: BROKEN-TR-FACTORIAL-1

&gt; (backtrace)
1: (broken-tr-factorial-1 1)
2: <i>... more stack frames, unrelated to BROKEN-TR-FACTORIAL ...</i> 

</pre> 

Так что же случилось со всеми рекурсивными вызовами в 
<code>BROKEN-TR-FACTORIAL-1</code>? Если уж на то пошло, то что же 
случилось со вызовом <code>BROKEN-TR-FACTORIAL-1</code>? Компилятор 
сделал исключение хвостовой рекурсии в <code>BROKEN-TR-FACTORIAL-1</code>,
заменив вызовы функций jump переходами. Функция генерировала только 
один кадр стека, а затем хвостовые рекурсивные вызовы заменяли 
значения в этом кадре для последующих вызовов.
<p>

Компилятор также заметил, что <code>BROKEN-TR-FACTORIAL</code> вызывает 
<code>BROKEN-TR-FACTORIAL-1</code> и немедленно возвращает его значение. 
Это просто еще один хвосто-рекурсивный вызов. Компилятор организовал 
построение кадра стека, используя значение, предоставленное для вызова 
<code>BROKEN-TR-FACTORIAL</code> и константу 1; не было никакой 
необходимости генерировать кадр стека для <code>BROKEN-TR-FACTORIAL</code>.
<p>

Я упоминаю все это, потому что вы можете подумать, что ваш компилятор 
сломан, когда вы в первый раз сталкиваетесь с при обратной трассировке
с "отсутствующими" кадрами. Компиляторы, которые делают хвостовую рекурсию,
обычно дают вам способ отключить эту оптимизацию; обратитесь к руководству
для получения подробной информации. Однако вам, вероятно, лучше научиться
распознавать хвостовую рекурсию и читать обратную трассировку вызовов в
присутствии этой оптимизации. Некоторый код, который полагается на хвостовую
рекурсию, может сломаться(переполняя стек), если вы отключите оптимизацию.
<p>

<h2>Упражнения по именованию</h2> 

Имя в Lisp может быть создано из любых знаков, не являющихся пробелами,
за исключением некоторых знаков, зарезервированных в качестве макрознаков
чтения (см. <a href="chapter03-11.html">Глава 3, Урок 11</a>), а именно:
<code>"</code>, <code>'</code>, <code>(</code>, <code>)</code>,
<code>,</code>, <code>;</code>, <code>`</code>, and <code>#</code>. 
Кроме того, имя не может быть числом в текущем основании чисел, 
как оно задано <code>*READ-BASE*</code>. Таким образом, FACE это имя, когда <code>*READ-BASE*</code> является 10, но когда <code>*READ-BASE*</code> составляет 16 (либо выше) это число.
<p>

Большинство программистов Lisp следуют нескольким соглашениям об 
именовании, чтобы идентифицировать имена определенных ролей. 
Глобальные переменные почти всегда пишутся с начальным и конечным
<code>*</code>, например:
<p>

<pre>
*next-id*
*home-directory*
*software-version*
</pre> 

Другие соглашения несколько различаются среди программистов Lisp. 
Довольно часто можно увидеть имя константы, написанное с начальным 
и конечным <code>+</code>, например:
<p>

<pre>
+initial-allocation-count+
+maximum-iteration-limit+
</pre> 

Однако сам Лисп не следует этому соглашению для констант, 
определенных языком:
<p>

<pre>
pi
most-positive-fixnum
least-negative-short-float
</pre> 

Программисты Lisp склонны выделять определенные знаки в качестве 
префиксов для имен функций, которые используют зависящие от реализации
особенности реализации Lisp, или которые иначе считаются "опасными", 
поскольку они нарушают абстракцию. Знак <code>%</code> чаще всего 
встречается в этой роли, но используются и другие - вы должны знать, 
что любое имя, начинающееся с неалфавитного знака, может иметь какое-то 
особое значение для программиста, написавшего код:
<p>

<pre>
%open-file-id
%structure-slot-names
$reserve_heap
_call-event-handler
@frame-marker
</pre> 

Не забудьте использовать соответствующие формы 
(<a href="#global-vars-and-consts">описанные ранее в этой главе</a> ) 
для объявления глобальных переменных и констант. Многие компиляторы Lisp 
позволят вам избежать использования формы SETQ для определения глобальных
переменных. Хотя это удобно для целей отладки, вы не должны полагаться на 
такое поведение в вашей окончательной программе, так как оно не гарантировано работает во всех реализациях.
<p>

Если вы не определяете константу с помощью формы <code>DEFCONSTANT</code>,
компилятор не может гарантировать, что ее значение останется постоянным. 
Еще хуже требование, чтобы имя константы не было ни присвоено (через форму 
<code>SETQ</code>, например), ни привязано (в форме <code>LET</code> или 
в качестве имени параметра функции, например). Если вы не определяете свои
константы с помощью <code>DEFCONSTANT</code>, компилятор не имеет возможности
соблюдать эти требования.
<p>

<h2>Лексическое связывание и несколько пространств имен</h2> 

В следующем фрагменте кода показано, как можно использовать одно и то 
же имя для различных целей. Потратьте минуту, чтобы прочитать его, и 
посмотрите, сколько отдельных применений вы можете подсчитать для 
имени <code>FUNNY</code>.<p>

<pre>
(defun funny (funny)
  "funny..."
  (if (zerop funny)
    :funny
    (list
     (cons funny 
           (let ((funny funny))
             (setq funny (1- funny))
             (funny funny))) 
     funny)))
</pre> 

Вот пять ролей, которые играет это одно имя:
<p>

<ol>
<li>имя функции
<li>аргумент функции
<li>слово в строке документации
<li>константа в пакете ключевых слов
<li>новая лексическая переменная
</ol> 

Учитывая только символы, названные <code>FUNNY</code>, существуют 
различные значения в зависимости от их использования и положения в коде. 
Во-первых, существует его значение как объекта функции - оно создается 
формой <code>DEFUN</code> и вызывается рекурсивно внутри формы 
<code>LET</code>. Далее значение фактического параметра передающегося
в вызове функции и привязывается к этому имени. Затем есть постоянное 
значение ключевое слово, появляющееся как последовательное возвращаемое значение формы <code>IF</code>. И наконец, внутри формы <code>LET</code> создается новая привязка (с помощью формы <code>LET</code>) и изменяется 
ее значение (с помощью формы <code>SETQ</code>).
<p>

Неужели за этим трудно уследить? Да. Как правило, вы должны быть застрелены, 
если вы пишете код, который выглядит так. С другой стороны, я делаю 
это потому, что это поучительно - урок здесь заключается в том, что 
в Lisp есть несколько различных пространств имен.
<p>

И что происходит, когда вы вызываете эту странную функцию? 
Этот:<p>

<pre>
? (funny 3)
((3 (2 (1 . :FUNNY) 1) 2) 3)

? (funny 0)
:funny
</pre> 

Теперь рассмотрим следующий сеанс Lisp:
<p>

<pre>
? (defun foo () 1)
FOO

? (defun baz ()
    (flet ((foo () 2)
           (bar () (foo)))
      (values (foo) (bar))))
BAZ

? (baz)
2
1

? (defun raz ()
    (labels ((foo () 2)
             (bar () (foo)))
      (values (foo) (bar))))
RAZ

? (raz)
2
2
</pre> 

Это довольно тонко, но стоит понять, потому что это довольно 
распространенная практика. Вот что произошло:
<p>

<ol>
<li>определяется функция <code>FOO</code> возвращающая 1
<li>определяется функция <code>BAZ</code>, с
<ol>
<li>определением локальной функции <code>FOO</code> возвращающей 2
<li>определением локальной функции <code>BAR</code> вызывающей 
<code>FOO</code> 
<li>вызовов <code>FOO</code> и <code>BAR</code>, и возврата их значений
</ol> 
<li>вызова <code>BAZ</code>, который возвращает значения 2 и 1
<li>определения функции <code>RAZ</code>, которая
<ol>
<li>определяет локальную функцию <code>FOO</code> возвращающую 2
<li>определяет локальную функцию <code>BAR</code> возвращающую
вызов <code>FOO</code> 
<li>вызова <code>FOO</code> и <code>BAR</code>, и возврата их значений
</ol> 
<li>вызова <code>RAZ</code>, который возвращает значения 2 и 2
</ol> 

Даже если <code>BAZ</code> и <code>RAZ</code> якобы делают одно и то же, 
они возвращают разные значения.
<p>

<code>BAZ</code> определяет свои локальные функции внутри формы
<code>FLET</code>, что не позволяет ссылаться на определяемые ею функции.
Таким образом, <code>FOO</code>, вызываемый <code>BAR</code> изнутри 
<code>BAZ</code>, на самом деле является глобальным <code>FOO</code>, 
который возвращает 1. <code>FOO</code> определенный внутри формы 
<code>FLET</code>, никогда не упоминается в <code>BAZ</code>.
<p>

<code>RAZ</code> определяет свои локальные функции внутри формы 
<code>LABELS</code>, в пределах которой определенные функции могут 
ссылаться на себя или друг на друга. Таким образом, <code>FOO</code>, 
вызываемый <code>BAR</code> внутри <code>RAZ</code>, является тем, 
который определен внутри формы <code>LABELS</code>, который возвращает 2.
Определенный глобальный <code>FOO</code> является затененным
именем <code>FOO</code> в форме <code>LABELS</code>.
<p>

В обоих случаях <code>FOO</code> лексически проявляется в двух местах: 
глобально и в пределах локальной определяющей формы (<code>FLET</code> или
<code>LABELS</code>). Для того чтобы что-то было лексически очевидным или
лексически ограниченным, это означает, что его определение можно определить, прочитав программу.
<p>

В <code>BAZ</code> я знаю, что локальное определение <code>FOO</code> 
не видно в <code>BAR</code>, поэтому необходимо ссылаться на глобальное
определение. (Если бы в <code>BAZ</code> существовала окружающая форма, определяющая локальную функцию <code>FOO</code>,то можно было бы ссылаться
на нее, а не на глобальное определение, потому что оно лексически очевидно
для вызывающего.)<p>

В <code>RAZ</code> я знаю, что локальное определение <code>FOO</code> 
видно <code>BAR</code>, поэтому оно используется вместо глобального 
определения. Даже если бы существовала охватывающая форма, которая 
определяла бы другую бы <code>FOO</code> локально в пределах 
<code>BAR</code>, она была бы - с точки зрения <code>BAR</code> -
затенена <code>FOO</code>, определенным в форме <code>LABELS</code>.
<p>

<h2>Чтение, запись и арифметика</h2> 

Ваши программы обычно должны получать входные данные и производить 
выходные данные. Если вы работаете с системой, которая поддерживает 
windows и диалоговые окна, вы, безусловно, можете использовать эти 
графические устройства. Вместо этого, полагаясь на встроенные средства 
Lisp для чтения и записи строк символов, вы гарантируете, что ваша 
программа полезна (или, по крайней мере, пригодна для использования) 
на всех типах компьютеров.
<p>

Большинство элементарных текстов по программированию включают 
простую программу для демонстрации подхода "ввод, процесс, вывод". 
Наш пример на Lisp считывает ряд чисел, складывает их и печатает сумму, 
когда мы вводим специальный маркер вместо числа:
<p>

<pre>
(defun simple-adding-machine-1 ()
  (let ((sum 0)
        next)
    (loop
      (setq next (read))
      (cond ((numberp next)
             (incf sum next))
            ((eq '= next)
             (print sum)
             (return))
            (t
             (format t "~&amp;~A ignored!~%" next))))
    (values)))
</pre>

Наша <code>SIMPLE-ADDING-MACHINE-1</code> работает следующим образом:
<p>

<pre>
(SIMPLE-ADDING-MACHINE-1)
3
5
FOO
FOO ignored!
11
=

19
</pre> 

<code>SIMPLE-ADDING-MACHINE-1</code>  получает свой ввод через клавиатуру,
а вывод записывает на экран. Это происходит потому, что <code>READ</code> 
и <code>PRINT</code> имеют необязательные аргументы, которые определяют поток
(см. <a href="chapter19.html">Главу 19</a>), и потому, что использование 
<code>T</code> в качестве второго аргумента для <code>FORMAT</code> 
равнозначно указанию стандартного выходного потока - экрана.
<p>

Что делать, если мы хотим прочитать входные данные из файла и записать 
их в другой файл? Один из способов-привязать стандартные входные и выходные
потоки к файлам и продолжать использовать <code>SIMPLE-ADDING-MACHINE-1</code>:

<pre>
(let ((*standard-input* (open "infile.dat" :direction :input))
      (*standard-output* (open "outfile.dat" :direction :output)))
  (declare (special *standard-input* *standard-output*))
  (simple-adding-machine-1)
  (close *standard-input*)
  (close *standard-output))
</pre> 

Это почти, но не совсем удовлетворительно. Мы привязываем стандартные входные
и выходные потоки к вновь открытым файлам, обрабатываем данные и закрываем 
файлы. Мы используем <code>LET</code> для временной привязки стандартных 
потоков к файлам; при выходе из формы <code>LET</code> 
<code>*STANDARD-INPUT*</code> и <code>*STANDARD-OUTPUT*</code>
восстанавливают свои исходные значения. Проблема, скрывающаяся в этом 
фрагменте кода, заключается в том, что ненормальный выход - ошибка или
преднамеренное прерывание-может привести к пропуску одного или обоих 
вызовов <code>CLOSE</code>.
<p>

Лучший способ написания такого рода кода использование 
<code>WITH-OPEN-FILE</code>:<p>

<pre>
(with-open-file (in-stream "infile.dat" :direction :input)
  (with-open-file (out-stream "outfile.dat" :direction :output)
    (let ((*standard-input* in-stream)
          (*standard-output* out-stream))
      (declare (special *standard-input* *standard-output*))
      (simple-adding-machine-1))))
</pre> 

Это делает почти то же самое, за исключением того, что файл, 
открытый с помощью команды <code>WITH-OPEN-FILE</code>, гарантированно
закрывается при выходе из формы, независимо от того, является ли выход 
нормальным или нет. Мы рассмотрим, как это возможно, в 
<a href="chapter09.html">Главе 9</a>.
<p>

Метод повторного связывания стандартных потоков ввода и вывода может быть 
очень удобен, если вам нужно перенаправить ввод и вывод для программы, 
которую вы не писали, не хотите переписывать или не можете получить 
исходный код. Если вы пишете программу с нуля, вы можете запланировать 
ее использование либо со стандартными потоками, либо с потоками 
(возможно, прикрепленными к файлам), предоставленными вызывающим
кодом:
<p>

<pre>
(defun simple-adding-machine-2 (&amp;optional (in-stream *standard-input*)
                                          (out-stream *standard-output*))
  (let ((sum 0)
        next)
    (loop
      (setq next (read in-stream))
      (cond ((numberp next)
             (incf sum next))
            ((eq '= next)
             (print sum out-stream)
             (return))
            (t
             (format out-stream "~&amp;~A ignored!~%" next))))
    (values)))
</pre> 

Если вы хотите использовать <code>SIMPLE-ADDING-MACHINE-2</code> с клавиатурой 
и экраном, вызовите его без каких-либо аргументов. Чтобы вызвать его с 
файловми потоками, сделайте это:
<p>

<pre>
(with-open-file (in-stream "infile.dat" :direction :input)
  (with-open-file (out-stream "outfile.dat" :direction :output)
    (simple-adding-machine-2 in-stream out-stream)))
</pre> 

Нам не нужно повторно связывать стандартные входные и выходные потоки, 
как это было сделано для перенаправления ввода-вывода для 
<code>SIMPLE-ADDING-MACHINE-1</code>. Это оставляет стандартные 
потоки свободными для других целей - таких как отчет о ходе выполнения 
или взаимодействие с пользователем.
<p>

Чтобы закрыть этот раздел, давайте кратко рассмотрим арифметику. 
Lisp имеет обширный репертуар математических функций, обратитесь 
к справочнику для получения подробной информации. 
<a href="chapter03-10.html">Глава 3, Урок 10</a> очень коротко 
описала цифры. Теперь мы рассмотрим, как и когда числа 
автоматически преобразуются из одного типа в другой.
<p>

Самое простое правило - это <em>заражение плавающей запятой</em>, 
зловеще звучащий термин, который означает: "Если вы используете 
число с плавающей запятой в вычислении, результатом будет 
число с плавающей запятой."
<p>

Следующее правило включает компоненты комплексных чисел 
с плавающей запятой. Комплексное число имеет действительную часть
и мнимую часть, чтение (и печать) в lisp'е имеет формат 
<code>#C(</code><i>real-part imaginary-part</i><code>)</code>, где <i>real-part</i> и <i>imaginary-part</i> какое либо Лисп число, за исключением другого
комплексного числа. Если любая из сторон является числом с плавающей запятой, 
то Lisp преобразует обе части в числа с плавающей запятой.
<p>

Если вы сократите мнимую часть комплексного числа до нуля, вы получите
не комплексное значение равное действительной части.
<p>

Отношения считываются и печатаются в виде 
<i>numerator</i><code>/</code><i>denominator</i>, где 
<i>numerator</i>(числитель) и <i>denominator</i>(знаменатель) 
всегда являются целыми числами. Преимущество соотношения состоит в том, 
что оно точно - <code>(/ 1.0 3)</code> - это число с плавающей запятой, 
которое очень близко (но не точно) к одной трети, но <code>1/3</code>
 (или <code>(/ 1 3)</code>) - это ровно одна треть.
<p>

Отношение, числитель которого точно делится на его знаменатель, 
будет сведено к целому числу - опять же, это точное число.
<p>

И наконец, целое число-это просто целое число. Если целое число становится
слишком большим, чтобы соответствовать представлению машины, Lisp 
преобразует его в <em>bignum</em> - количество цифр ограничено только 
памятью компьютера.<p>

Просто чтобы убедиться, что вы все это понимаете, попробуйте сложить 
несколько чисел различных типов, чтобы увидеть, можно ли вызвать все
преобразования, описанные выше.<p>

<h2>Другие типы данных</h2> 

Давайте приведем расширенный пример, чтобы показать, как мы можем 
использовать несколько встроенных типов данных Lisp. Мы создадим 
простое приложение, чтобы отслеживать банковские чеки, когда мы их 
выписываем. Для каждого чека мы будем отслеживать номер чека, 
получателя платежа, дату, сумму и памятку. Мы будем поддерживать 
запросы для отображения отдельного чека, чтобы перечислить все чеки,
выплаченные получателю, перечислить всех получателей, суммировать 
все суммы чеков и перечислить все чеки, которые мы заплатили. 
Мы также предоставим способ аннулировать чек, как только он будет выписан.
<p>

Вот вам и код:
<p>

<pre>
(defvar *checks* (make-array 100 :adjustable t :fill-pointer 0)
  "A vector of checks.")

(defconstant +first-check-number+ 100 
  "The number of the first check.")

(defvar *next-check-number* +first-check-number+ 
  "The number of the next check.")

(defvar *payees* (make-hash-table :test #'equal) 
  "Payees with checks paid to each.")

(defstruct check
  number date amount payee memo)

(defun current-date-string ()
  "Returns current date as a string."
  (multiple-value-bind (sec min hr day mon yr dow dst-p tz)
                       (get-decoded-time)
    (declare (ignore sec min hr dow dst-p tz))
    (format nil "~A-~A-~A" yr mon day)))

(defun write-check (amount payee memo)
  "Writes the next check in sequence."
  (let ((new-check (make-check 
                    :number *next-check-number*
                    :date (current-date-string)
                    :amount amount
                    :payee payee
                    :memo memo)))
    (incf *next-check-number*)
    (vector-push-extend new-check *checks*)
    (push new-check (gethash payee *payees*))
    new-check))

(defun get-check (number)
  "Returns a check given its number, or NIL if no such check."
  (when (and (<= +first-check-number+ number) (< number *next-check-number*))
    (aref *checks* (- number +first-check-number+))))

(defun void-check (number)
  "Voids a check and returns T.  Returns NIL if no such check."
  (let ((check (get-check number)))
    (when check
      (setf (gethash (check-payee check) *payees*)
            (delete check (gethash (check-payee check) *payees*)))
      (setf (aref *checks* (- number +first-check-number+)) nil)
      t)))

(defun list-checks (payee)
  "Lists all of the checks written to payee."
  (gethash payee *payees*))

(defun list-all-checks ()
  "Lists all checks written."
  (coerce *checks* 'list))

(defun sum-checks ()
  (let ((sum 0))
    (map nil #'(lambda (check)
                 (when check
                   (incf sum (check-amount check))))
         *checks*)
    sum))

(defun list-payees ()
  "Lists all payees."
  (let ((payees ()))
    (maphash #'(lambda (key value)
                 (declare (ignore value))
                 (push key payees))
             *payees*)
    payees))
</pre> 

А вот пример того, как это работает:
<p>

<pre>
? (write-check 100.00 "Acme" "T-1000 rocket booster")
#S(CHECK :NUMBER 100 :DATE "1996-11-3" :AMOUNT 100.0 :PAYEE "Acme" :MEMO "T-1000 rocket booster")

? (write-check 50.00 "Acme" "1 gross bungee cords")
#S(CHECK :NUMBER 101 :DATE "1996-11-3" :AMOUNT 50.0 :PAYEE "Acme" :MEMO "1 gross bungee cords")

? (write-check 300.72 "WB Infirmary" "body cast")
#S(CHECK :NUMBER 102 :DATE "1996-11-3" :AMOUNT 300.72 :PAYEE "WB Infirmary" :MEMO "body cast")

? (list-checks "Acme")
(#S(CHECK :NUMBER 101 :DATE "1996-11-3" :AMOUNT 50.0 :PAYEE "Acme" :MEMO "1 gross bungee cords")
 #S(CHECK :NUMBER 100 :DATE "1996-11-3" :AMOUNT 100.0 :PAYEE "Acme" :MEMO "T-1000 rocket booster"))
T

? (get-check 101)
#S(CHECK :NUMBER 101 :DATE "1996-11-3" :AMOUNT 50.0 :PAYEE "Acme" :MEMO "1 gross bungee cords")

? (sum-checks)
450.72

? (list-all-checks)
(#S(CHECK :NUMBER 100 :DATE "1996-11-3" :AMOUNT 100.0 :PAYEE "Acme" :MEMO "T-1000 rocket booster")
 #S(CHECK :NUMBER 101 :DATE "1996-11-3" :AMOUNT 50.0 :PAYEE "Acme" :MEMO "1 gross bungee cords")
 #S(CHECK :NUMBER 102 :DATE "1996-11-3" :AMOUNT 300.72 :PAYEE "WB Infirmary" :MEMO "body cast"))

? (list-payees)
("WB Infirmary" "Acme")

? (void-check 101)
T

? (list-checks "Acme")
(#S(CHECK :NUMBER 100 :DATE "1996-11-3" :AMOUNT 100.0 :PAYEE "Acme" :MEMO "T-1000 rocket booster"))
T

? (list-all-checks)
(#S(CHECK :NUMBER 100 :DATE "1996-11-3" :AMOUNT 100.0 :PAYEE "Acme" :MEMO "T-1000 rocket booster")
 NIL
 #S(CHECK :NUMBER 102 :DATE "1996-11-3" :AMOUNT 300.72 :PAYEE "WB Infirmary" :MEMO "body cast"))

? (sum-checks)
400.72
</pre> 

Примерно за одну страницу кода мы создали простое приложение для записи чеков 
с эффективными структурами данных для хранения чеков и получателей платежей. 
У нас также есть базовые средства ввода-вывода без каких-либо дополнительных
усилий с нашей стороны. А благодаря сборке мусора нам совсем не нужно
беспокоиться об освобождении хранилища или утечках памяти.
<p>

<h2>Простые Макросы</h2> 

Одна важная особенность, отсутствующая в нашей программе записи чеков, 
- это возможность сохранять и восстанавливать ее состояние. 
Поскольку состояние полностью содержится в трех глобальных переменных: 
<code>*CHECKS*</code>, <code>*NEXT-CHECK-NUMBER*</code>, и 
<code>*PAYEES*</code>, все, что нам действительно нужно сделать, 
это использовать <code>PRINT</code> для записи значений этих переменных 
в файл и <code>READ</code> - чтобы перезагрузить их позже.<p>

Но поработав чуть больше мы можем написать макрос, который будет сам писать
наши функции сохранения и восстановления. Тогда мы сможем использовать этот 
макрос не только для нашей программы написания чеков, но и для любой 
программы, которая сохраняет свое состояние в глобальных переменных.
<p>

Сначала взгляните на готовый макрос, а потом мы его разберем:
<p>

<pre>
(defmacro def-i/o (writer-name reader-name (&amp;rest vars))
  (let ((file-name (gensym))
        (var (gensym))
        (stream (gensym)))
    `(progn
       (defun ,writer-name (,file-name)
         (with-open-file (,stream ,file-name
                                  :direction :output :if-exists :supersede)
           (dolist (,var (list ,@vars))
             (declare (special ,@vars))
             (print ,var ,stream))))
       (defun ,reader-name (,file-name)
         (with-open-file (,stream ,file-name
                                  :direction :input :if-does-not-exist :error)
           (dolist (,var ',vars)
             (set ,var (read ,stream)))))
       t)))
</pre> 

Начальная форма <code>LET</code> определяет символы, которые будут 
отображаться в развернутом макросе. Каждый символ создается (GENSYM) так, 
что ни какой другой символ не может быть таким же. Это позволяет избежать
проблемы, которая могла бы возникнуть, если бы мы написали макрос, 
используя определенный символ в качестве переменной, а затем вызвали 
макрос с аргументом, имеющим то же имя, что и один из символов в 
расширении.
<p>

Расширенние макроса создается формой  <code>`</code>. Форма возвращается
как расширение макроса,а затем вычисляется. Замены происходят для символов
расположенных после <code>,</code> или <code>,@</code>. Все остальное появляется 
буквально(переносится как есть) в расширении макроса.
<p>

Расширение <code>DEF-I/O</code> - это <code>PROGN</code> форма, 
содержащая две формы <code>DEFUN</code>. Мы оборачиваем  <code>DEFUN</code>
таким образом, потому что расширение макроса может быть только одной формой, 
а нам нужно, чтобы этот макрос определял две функции.
<p>

Макрос определяет функцию записи, которая циклически перемещается 
по списку <code>VARS</code>, указанных в вызове макроса, печатая каждую
из них по очереди в именованный выходной файл. Функция чтения(reader) 
выполняет циклический перебор имен <code>VARS</code>, считывая значения 
из входного файла и присваивая их именованным переменным. Обратите 
внимание, что <code>SET</code> вычисляет свой первый аргумент; 
это позволяет нам использовать переменную, чтобы содержать имя 
переменной, которой мы хотим присвоить значение.
<p>

Вот как макрос расширяется для создания функций загрузки и сохранения 
для нашей программы:<p>

<pre>
? (pprint (macroexpand '(def-i/o save-checks load-checks (*checks* *next-check-number* *payees*))))
(PROGN (DEFUN SAVE-CHECKS (#:G2655)
            (WITH-OPEN-FILE (#:G2657 #:G2655 :DIRECTION :OUTPUT :IF-EXISTS :SUPERSEDE)
              (DOLIST (#:G2656 (LIST *CHECKS* *NEXT-CHECK-NUMBER* *PAYEES*))
                (DECLARE (SPECIAL *CHECKS* *NEXT-CHECK-NUMBER* *PAYEES*))
                (PRINT #:G2656 #:G2657))))
          (DEFUN LOAD-CHECKS (#:G2655)
            (WITH-OPEN-FILE (#:G2657 #:G2655 :DIRECTION :INPUT :IF-DOES-NOT-EXIST
                             :ERROR)
              (DOLIST (#:G2656 '(*CHECKS* *NEXT-CHECK-NUMBER* *PAYEES*))
                (SET #:G2656 (READ #:G2657))))))
</pre> 

А вот как мы будем использовать макрос и функции, которые он определяет, 
чтобы сохранить и восстановить информацию о состоянии для нашей программы:
<p>

<pre>
? (def-i/o save-checks load-checks (*checks* *next-check-number* *payees*))
T

? (save-checks "checks.dat")
NIL

? (makunbound '*checks*)
*CHECKS*

? (makunbound '*next-check-number*)
*NEXT-CHECK-NUMBER*

? (makunbound '*payees*)
*PAYEES*

? *PAYEES*
Error: Unbound variable.

? (load-checks "checks.dat")
NIL
</pre>
<p>Прим. переводчика: здесь мой лисп выдал ошибку, т.к. READER всретил в файле checks.dat
не читаемый(т.е не востанавливаемый) им префикс: <code> #&ltHASH-TABLE .. </code>.
Решение состоит в том чтобы отказаться от сохранения *payees* и создавать его
заново при загрузке, итак необходимо создать функцию 
<pre>
(defun restore-check (file-name)
  (load-checks file-name)
  (setf *payees* (make-hash-table :test #'equal))
  (map nil #'(lambda (check)
               (when check
                 (push check (gethash (check-payee check) *payees*))))
       *checks*))
;;отказаться от сохранения *payees*
(def-i/o save-checks load-checks (*checks* *next-check-number*))

;;и при загрузке чеков использовать не на прямую (load-checks "checks.dat"), а:
(restore-check "checks.dat")
</pre>

 


<pre>
? *PAYEES*
("WB Infirmary" "Acme")
</pre> 
<p>(прим. переводчика) не понятно как автор получил этот вывод, т.к это должна быть
хеш-таблица.

<h2>Макросы чтения(или макросы Reader-а)</h2> 

У нашего приложения для записи чеков есть одна небольшая проблема. 
Если мы используем числа с плавающей запятой для представления долларов 
и центов, то в некоторых случаях наши суммы могут быть уменьшены на пенни. 
То, что мы действительно должны сделать, - это представить всю валюту в 
виде целых Пенни. Мы можем сделать макрос считывателя, чтобы помочь с 
вводом долларовых и центовых сумм, Преобразуя входные данные, такие как 
$10,95 в соответствующее количество пенни.
<p>

Вот вам и код::<p>

<pre>
(set-macro-character #\$
                     #'(lambda (stream char)
                         (declare (ignore char))
                         (round (* 100 (read stream)))))
</pre> 

<blockquote>
Шаг округления гарантирует, что amount(сумма) является целым числом. 
Двоичные числа с плавающей запятой не могут точно представлять все 
десятичные дроби. Например, <code>(* 100 9.95)</code> дает 
<code>994.9999999999999</code> и <code>(* 100 1.10)</code> дает
<code>110.00000000000001</code> в моей системе Lisp.<p>
</blockquote> 

Он говорит о том, чтобы установить знак <code>$</code> в качестве 
макрознака, который, когда он встречается с читателем, вызывает 
<code>READ</code>, чтобы получить число и вернуть ближайшее целое 
число после умножения на 100. Он используется вот так:
<p>

<pre>
? $9.95
995

? $-7.10
-710
</pre> 

Теперь, когда вы можете вводить суммы в долларах напрямую, вы можете изменить
приложение для записи чеков, чтобы печатать суммы в целых центах как доллары и
центы. Для этого необходимо переопределить структуру проверки с помощью
пользовательской функции печати следующим образом:<p>

<pre>
(defstruct (check
            (:print-function
             (lambda (check stream depth)
               (declare (ignore depth))
               (format stream "#S(CHECK NUMBER ~S DATE ~S AMOUNT $~,2,-2F PAYEE ~S MEMO ~S)"
                       (check-number check)
                       (check-date check)
                       (check-amount check)
                       (check-payee check)
                       (check-memo check)))))
  number date amount payee memo)
</pre> 

Затем, макрос чтения <code>$</code> и функция печати <code>CHECK</code>
 для его слота <code>AMOUNT</code> прекрасно дополняют друг друга:<p>

<pre>
? (make-check :amount $9.95)
#S(CHECK NUMBER NIL DATE NIL AMOUNT $9.95 PAYEE NIL MEMO NIL)
</pre> 

<hr>
<div align="center">
<a href="contents.html">Contents</a> | <a href="cover.html">Cover</a> <br> 
<a href="chapter03.html">Chapter 3</a> | Chapter 4 | <a href="chapter05.html">Chapter 5</a> 
</div>
<hr>
<address>
Copyright &copy; 1995-2001, David B. Lamkins<br>
All Rights Reserved Worldwide<br>
<br>
This book may not be reproduced without the written consent of its author.  Online distribution is restricted to the author's site.
</address> 
</body> </html>