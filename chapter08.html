<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Successful Lisp - Chapter 8</title>
</head> 

<body bgcolor="white" text="black">
<h1>Глава 8 - Время жизни и Видимость</h1> 

<p>
В этой главе мы увидим, как время жизни и видимость влияют на значения 
переменных Lisp во время выполнения. Это очень похоже на локальные и 
глобальные переменные в других языках, но специальные переменные Lisp 
меняют дело. Эта глава также закладывает основу для понимания того, 
что продолжительность жизни и видимость - относятся не только к переменным.

<h2>Все в Лиспе имеет как время жизни, так и видимость.</h2> 

<p>
Каждый объект в Lisp имеет как время жизни, так и видимость. 
Мы увидим, почему это важно, в последующих разделах.


<h2>Время жизни: Создание, существование, затем разрушение</h2> 

<p>
Время жизни объекта - это период между его созданием и разрушением. 
Некоторые объекты имеют мимолетное время жизни, ограниченное формой, 
в которой они появляются. Другие объекты создаются сразу же после 
запуска программы и не уничтожаются до тех пор, пока программа не 
завершится. А другие входят и выходят из существования по 
другим правилам.

<h2>Видимость: видеть и быть увиденным</h2> 

<p>
Объект либо виден, либо не виден в определенной точке вашей программы. 
Иногда видимость контролируется путем выполнения программы. Но для 
большинства объектов в Common Lisp видимость определяется расположением в
тексте вашей программе; это хорошо, потому что вы можете рассуждать о видимости,
просто читая программу, без необходимости сначала рассуждать о потоке управления
программой.

<h2>Технические названия: Объем/Протяженность(Extent) и 
Область видимости(Scope)</h2> 

<p>
Когда вы читаете языковые спецификации для Common Lisp, вы увидите 
технические термины протяженность(extent) и область видимости(scope), 
используемые вместо времени жизни(lifetime) и видимости(visibility). 
Я хотел сначала ввести эти понятия, используя нетехнические термины, 
потому что я считаю их более выразительными. Но вы должны привыкнуть 
читая о протяженности и области видимости. Помните:


<blockquote>
<b>время жизни(lifetime)</b> это <b>протяженность(extent)</b> <br>
as<br>
<b>видимость(visibility)</b> это <b>область видимости(scope)</b> 
</blockquote> 

<h2>Действительно просты случаи: определяющие формы верхнего уровня</h2> 

<p>
Определить формы верхнего уровня очень просто. Определенные таким 
образом объекты имеют <em>неопределенную</em> протяженность и область 
видимости. Это причудливый способ сказать, что объекты, определенные 
формами верхнего уровня, "всегда" существуют и видны (или, по крайней 
мере, потенциально доступны, как я вскоре объясню) везде в программе.

<p>
Практически это означает, что каждый объект, определенный формой 
верхнего уровня, существует до тех пор, пока выполняется программа. 
Объект появляется, когда вычисляется форма верхнего уровня. 
Если форма была скомпилирована в файл, то объект, созданный формой, 
появляется при загрузке скомпилированного файла.

<p>
Объект с неопределенной областью видимости виден везде в вашей программе. 
Не имеет значения, был ли объект создан в другом исходном файле или 
в другое время - даже если он был создан <em>после</em> определения функции, 
ссылающейся на объект верхнего уровня (хотя некоторые компиляторы 
Lisp выдадут предупреждение, когда вы это сделаете), код всегда будет 
вести себя правильно, если вы вычислите определяющую форму объекта 
перед вычислением функции, ссылающейся на объект.


<blockquote>
Если вы знакомы с понятием лексической области в ее применении 
к языкам программирования,то вас, вероятно, смущает понятие 
неопределенной области. Если я представлю объект, имя которого 
<em>затеняет</em> имя объекта во внешней области, то этот 
внешний объект "не виден" во внутренней области. И в какой - 
то степени вы правы.

<p>
Лисп делает очень четкое и явное различие между объектом и его именем. 
Мы говорим, что объект привязан к имени или что для объекта установлена
(именованная) привязка. И это очень верно, что (<em>binding</em>)привязка 
во внутренней лексической области может затенять (<em>binding</em>)привязку
во внешней области. 
Однако область действия внешнего объекта распространяется и на 
внутреннюю область, даже если он недоступен из-за своей 
затеняющей привязки. Это важное различие, поскольку объект может иметь 
более одной привязки, и объект должен оставаться доступным через любую
привязку, которая не была лексически затенена.
</blockquote> 

<h2>Область видимости(Scope) и протяженность(extent) параметров и LET переменные
</h2> 

<p>Объекты, связанные параметрами функции и <code>LET</code> формы, 
имеют лексическую область видимости/действия. Их привязки видны, 
начиная с определенного текстового места в определяющей форме и 
продолжаются через текст до конца определяющей формы. Любая ссылка 
на текстуально идентичное имя вне пределов определяющей формы 
должна ссылаться на другую привязку. Вложенная определяющая форма 
может объявить привязку, которая затеняет заключающую привязку 
к текстуально идентичному имени.


<blockquote>
Это несколько более строгое повторение понятий, введенных в 
<a href="chapter03-06.html">Главе 3, Урок 6</a>. Если вам нужно освежить
свою память, то сейчас самое время вернуться 
<a href="chapter03-06.html">назад</a> и просмотреть примеры
из этого короткого отрывка.
</blockquote> 

<a name="special"></a> 
<h2>Немного сложнее: специальные переменные</h2> 

<p>Специальные переменные (также известные под более технически 
корректным термином <em>динамические переменные</em>) имеют 
<em>динамическую область</em> действия/видимости. Это означает, 
что привязка создается для специальной переменной в результате 
выполнения какой-либо формы в вашей программе. Область видимости 
динамической привязки распространяется на любую форму, вызываемую
(прямо или косвенно) формой, которая установила динамическую привязку.


<p>Протяженность(время жизни) специальной переменной длится бесконечно, 
пока форма, создавшая динамическую привязку, не перестанет быть местом 
активного выполнения программы - другими словами, пока определяющая форма 
(и все вызываемые ею формы) не завершат свое выполнение. Если динамическая
привязка создается формой верхнего уровня, протяженность будет такой же, 
как описано ранее для форм определения верхнего уровня.

<pre>
? (defparameter *my-special-variable* 17)
*MY-SPECIAL-VARIABLE*
? (defun show-my-special ()
    (declare (special *my-special-variable*))
    (print *my-special-variable*)
    nil)
SHOW-MY-SPECIAL
? (defun do-something-else ()
    (show-my-special))
DO-SOMETHING-ELSE
? (defun dynamically-shadow-my-special ()
    (let ((*my-special-variable* 8))
      (do-something-else))
    (show-my-special))
DYNAMICALLY-SHADOW-MY-SPECIAL
? (dynamically-shadow-my-special)

8
17
NIL
</pre> 

<p>
Читая вышеизложенное, обратите особое внимание на 
<code>DO-SOMETHING-ELSE</code>. вызывающий  <code>SHOW-MY-SPECIAL</code>. <code>SHOW-MY-SPECIAL</code>  обычно видит лексическое значение 
<code>*MY-SPECIAL-VARIABLE*</code> -- 17 -- кроме декларации, которая гласит, что 
<code>*MY-SPECIAL-VARIABLE*</code> - это специальная переменная.

<p><code>DYNAMICALLY-SHADOW-MY-SPECIAL</code> связывает
<code>*MY-SPECIAL-VARIABLE*</code> со значением 8, 
затем вызывает <code>DO-SOMETHING-ELSE</code> На данный момент, 
<code>LET</code> связывает  <code>*MY-SPECIAL-VARIABLE*</code> 
не лексически очевидным для кода в <code>SHOW-MY-SPECIAL</code>. 
Тем не менее, поскольку привязка объявлена Специальной в этой точке, 
и поскольку форма связывания  <code>LET</code> все еще активна, 
когда <code>DO-SOMETHING-ELSE</code> вызывает <code>SHOW-MY-SPECIAL</code>,
печатается динамическая привязка к 8 (а не лексическая привязка к 17)


<p>Позже во время выполнения второго вызова <code>SHOW-MY-SPECIAL</code>
происходит за пределами формы <code>LET</code>, и печатается значение верхнего
уровня стоимости <code>*MY-SPECIAL-VARIABLE*</code> -- 17.

<blockquote> 
Строго говоря, форма <code>(DECLARE (SPECIAL ...</code> 
не является необходимой в <code>SHOW-MY-SPECIAL</code> - форма 
<code>DEFPARAMETER</code> имеет побочный эффект объявленения её 
переменной СПЕЦИАЛЬНОЙ. Однако добавленное объявление добавляет 
избыточную документацию в месте использования специальной переменной. 
Кроме того, некоторые компиляторы Lisp выдают предупреждение (обычно:
"необъявленная свободная переменная предполагается специальной"/
"<samp>Undeclared free variable assumed special</samp>"), 
от которого легко избавиться, добавив объявление.
</blockquote> 

<hr>
<div align="center">
<a href="contents.html">Contents</a> | <a href="cover.html">Cover</a> <br> 
<a href="chapter07.html">Chapter 7</a> | Chapter 8 | <a href="chapter09.html">Chapter 9</a> 
</div>
<hr>
<address>
Copyright &copy; 1995-2001, David B. Lamkins<br>
All Rights Reserved Worldwide<br>
<br>
This book may not be reproduced without the written consent of its author.  Online distribution is restricted to the author's site.
</address> 
</body> </html>