<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Successful Lisp - Chapter 14</title>
</head> 

<body bgcolor="white" text="black">
<h1>Глава 14 - Могут ли объекты иметь собственное 
поведение?</h1> 

<P>Эта глава продолжает рассмотрение CLOS (Common Lisp Object System), 
которое мы начали в <a href="chapter07.html">Главе 7</a>, в которой мы видели, 
как объекты хранят данные. В этой главе мы узнаем о том, как объекты получают 
свое поведение.

<h2>Обобщенные функции дают объектам их поведение</h2>

<p>
Обобщенная функция обеспечивает поведение, основыванное на типе объекта. 
Поведение выбирается в соответствии с типами аргументов обобщенной функции. 
Обобщенная функция передает управление определенному методу, который обеспечивает 
наилучшее соответствие типам аргументов, используемых для вызова обобщенной функции.

<p><img src="gifs/simple-gf-invocation.gif">

<p>
Вы определяете метод с помощью макроса  Lisp <code>DEFMETHOD</code>. 
В своей простейшей форме <code>DEFMETHOD</code> ожидает имя и 
специализирующий(конкретизирующий обобщенную функцию) лямбда-список. 
Специализирующий лямбда-список аналогичен списку формальных параметров, 
который вы предоставляете для  форм <code>LAMBDA</code> или <code>DEFUN</code>; 
разница заключается в том, что вы можете указать тип каждого параметра. Метод 
будет вызываться только тогда, когда вызов обобщенной функции (который выглядит точно 
так же, как вызов функции) задает параметры, соответствующие типам его лямбда-
списка. Чтобы специализировать параметр в форме <code>DEFMETHOD</code> , 
просто назовите параметр и его тип в списке. Например:

<pre>
(defmethod method1 ((param1 number) (param2 string)) ...)
(defmethod method2 ((param2 float) (param2 sequence)) ...)
</pre> 

<p>
Вы также можете оставить тип параметра неопределенным, просто указав его имя; 
этот тип параметра будет соответствовать любому типу данных. В этом примере первый 
параметр не является специализированным:

<pre>
(defmethod method3 (param1 (param2 vector)) ...)
</pre> 

<p>
Обратите внимание, что типы параметров не обязательно должны быть типами 
классов CLOS. Если вы хотите специализировать метод для одного конкретного 
класса CLOS, вы можете специализировать один из аргументов для этого класса, 
как мы видели на первом рисунке в этой главе. Если вы специализировали один 
параметр для класса CLOS, а остальные параметры оставили неспециализированными, 
то вы эмулировали метод одиночной отправки(single-dispatch), общий для некоторых
"классических" объектно-ориентированных языков программирования. В этом ограниченном
случае вы можете думать о методе как о связанном с классом. В следующем разделе 
мы увидим, что эта ассоциация разрушается, когда мы связываем метод с несколькими
классами.

<p>
Вы, вероятно, задаетесь вопросом, как создаются обобщенные функции, когда 
все, что вы делаете, - это определяете методы. При определении метода Lisp 
создает обобщенную функцию, если она еще не существует. Когда Lisp создает эту
обобщенную универсальную функцию для вас, он отмечает имя, количество обязательных и необязательных аргументов, а также наличие и имена ключевых параметров. Когда вы 
создаете другой метод с таким же именем, он должен согласовать с обобщенной функцией
детали параметров, которые были записаны в обобщенной функции. Это соглашение называется
Lambda list congruence(совпадение лямбда-списков) - Lisp будет сигнализировать об ошибке,
если вы попытаетесь создать новый метод с несоответсвующим лямбда-списком.

<h2>Граница между методами и объектами размывается для мультиметодов</h2>

<p>
Мультиметод - это метод, который выбирается на основе типов двух или более 
его аргументов. Если у вас есть метод, выбранный для двух или более классов, 
то мы не можем действительно сказать, что класс (или объект, который является 
экземпляром этого класса) "имеет" определенный метод.

<h2>Методы на не-объектах?  Так где же живет этот метод?</h2>

<p>
Связь методов с классами становится еще более слабой, если учесть, что один 
или несколько аргументов метода могут специализироваться на объекте, который 
не является классом. Если мы рассчитываем найти какой-то удобный способ сказать, 
что метод "принадлежит" определенному классу, мы просто не найдем его.

<p>
Более простые (и менее выразительные) объектные системы, чем CLOS, действительно 
связывают метод с определенным классом. CLOS - нет. Это важный момент, поэтому 
позвольте мне перефразировать его: методы CLOS не являются частью какого - либо класса, 
для которого они могут предоставлять услуги.

<p>
Метод - это часть обобщенной функции. Обобщенная функция анализирует 
фактические параметры и выбирает метод для вызова на основе соответствия 
между фактическими параметрами и специализированными(указанными) лямбда-списками 
в определениях методов. И, повторяя замечание, сделанное в предыдущем параграфе, 
обобщенные функции <em>не являются частью</em> каких-либо классов, над которыми 
работают методы обобщенной функции.

<h2>Обобщенные функции работают путем диспетчеризации по указанным аргументам</h2>

<p>
При определении метода обявляют типы его параметров (в специализирующем 
лямбда-списке), так что метод может быть вызван только при использовании параметров
того же или более специфического типа. Например, если параметр специализируется
типом <code>NUMBER</code>, он может соответствовать
<code>INTEGER</code>, <code>FIXNUM</code>, <code>FLOAT</code>,
<code>BIGNUM</code>, <code>RATIONAL</code>, <code>COMPLEX</code>, 
или каким либо другим подтипом <code>NUMBER</code>.

<p>
Но что делать, если вы определяете два метода, которые могут соответствовать 
одним и тем же типам? Рассмотрим следующие определения.

<pre>
(defmethod op2 ((x number)  (y number))  ...) <i>; method 1</i> 
(defmethod op2 ((x float)   (y float))   ...) <i>; method 2</i> 
(defmethod op2 ((x integer) (y integer)) ...) <i>; method 3</i> 
(defmethod op2 ((x float)   (y number))  ...) <i>; method 4</i> 
(defmethod op2 ((x number)  (y float))   ...) <i>; method 5</i> 
</pre> 

<p>
Вызов формы <code>(OP2 11 23)</code> потенциально соответствует 
методам 1 и 3, поскольку оба аргумента имеют тип <i>INTEGER</i>, 
который является подтипом <code>NUMBER</code>. CLOS разрешает 
неоднозначность, выбирая более конкретное совпадение, таким образом, 
метод 3 выбирается для вызова <code>(OP2 11 23)</code>.

<p>
Та же стратегия разрешения выбирает метод 5 для <code>(OP2 13 2.9)</code>, 
метод 4 для <code>(OP2 8.3 4/5)</code> и метод 1 для <code>(OP2 5/8 11/3)</code>. 
Общее правило состоит в том, что CLOS выбирает метод, основанный на наиболее 
специфичных типах соответствия, и левый аргумент всегда более специфичен, 
чем аргументы справа от него. Вторая часть этого правила означает, что аргументы 
слева служат тай-брейкерами(уточнениями) для тех, кто находится дальше справа. Рассмотрим эти методы:

<pre>
(defmethod Xop2 ((x number)  (y number))  ...) <i>; method 1</i> 
(defmethod Xop2 ((x float)   (y number))  ...) <i>; method 2</i> 
(defmethod Xop2 ((x number)  (y float))   ...) <i>; method 3</i> 
</pre> 

<p>
Вызов <code>(XOP2 5.3 4.1)</code> вызовет метод 2. И Метод 2, и метод 3 
более специфичны, чем метод 1. Метод 2 имеет более специализированный тип 
в первой позиции аргумента по сравнению с методом 3, поэтому вызывается 
метод 2.

<p>
Помимо диспетчеризации на основе типов аргументов, CLOS может выполнять 
диспетчеризацию на основе конкретных объектов.

<pre>
? (defmethod idiv ((numerator integer) (denominator integer))
    (values (floor numerator denominator)))
#&lt;STANDARD-METHOD IDIV (INTEGER INTEGER)&gt;
? (defmethod idiv ((numerator integer) (denominator (eql 0)))
    nil)
#&lt;STANDARD-METHOD IDIV (INTEGER (EQL 0))&gt;
? (idiv 4 3)
1
? (idiv 6 2)
3
? (idiv 4 0)
NIL
</pre> 

<p>
Здесь мы специализировались на целочисленном значении 0. Вы можете 
специализироваться на любом объекте, который можно выделить с помощью 
предиката <code>EQL</code>. Числа, символы и экземпляры объектов могут 
быть проверены таким образом. См. <a href="chapter17.html">Главу 17</a> 
для получения дополнительной информации по предикату <code>EQL</code>.

<h2>В конце концов наследование объектов имеет значение; поиск подходящих методов</h2>

<p>
Класс - это тип, а подкласс-это подтип. Поэтому, когда вы определяете 
эти классы:

<pre>
(defclass c1 () ...)
(defclass c2 (c1) ...)
</pre> 

<p>
тогда <code>C2</code> - это подкласс <code>C1</code>. Если затем вы используете 
типы <code>C1</code> и <code>C2</code> в качестве специализации для определения 
метода, то <code>C2</code> будет более специфичным типом 
(см. предыдущий раздел), чем <code>C1</code>.

<p>
Но что делать, если вы определяете классы, которые наследуются от 
более чем одного класса? Как вы решаете, какой класс более специфичен, 
чем другой? Рассмотрим следующие определения классов:

<pre>
(defclass c1 () ...)
(defclass c2 () ...)
(defclass c3 (c1) ...)
(defclass c4 (c2) ...)
(defclass c5 (c3 c2) ...)
(defclass c6 (c5 c1) ...)
(defclass c7 (c4 c3) ...)
</pre> 

<p>
Эти определения дают нам иерархию наследования, которая выглядит следующим образом: 
жирные линии связывают подкласс с первым родительским классом, 
а более светлые линии - со вторым родительским классом:

<p><img src="gifs/multiple-inheritance-graph.gif">

<p>
Теперь рассмотрим следующие определения методов, которые специализируются 
на этой иерархии классов:

<pre>
(defmethod m1 ((x c1)) ...) <i>; method 1</i> 
(defmethod m1 ((x c2)) ...) <i>; method 2</i> 
</pre> 

<p>Ясно, что вызов обобщенной функции <code>M1</code> с объектом типа 
<code>C1</code> или <code>C3</code> вызовет метод 1,
а вызов обобщенной функции с объектом типа <code>C2</code> или <code>C4</code> 
вызовет метод 2. Но что произойдет, если мы вызовем обобщенную функцию M1 
с объектом типа  <code>C5</code>, <code>C6</code>, или <code>C7</code>? 
Все эти классы наследуются-прямо или косвенно-как от 
<code>C1</code>, так и от <code>C2</code>.


<p>
Если мы вызываем обобщенную функцию <code>M1</code> с объектом типа 
<code>C5</code>, <code>C6</code>, или <code>C7</code> CLOS должен решить, 
следует ли вызывать метод 1 или Метод 2. (Он не может делать и то, и другое.) 
Это решение основано на некоторой мере того, является ли 
<code>C1</code> или <code>C2</code> более конкретным родительским классом. 
Мера основана на положении родительского класса в списке предшествования/приоритетов
классов(<em>class precedence list</em>) подкласса. Вот списки предшествования классов
(CPLs) для <code>C5</code>, <code>C6</code>, и
<code>C7</code>:

<pre>
Class   CPL
-----   ---
C5      (C5 C3 C1 C2)
C6      (C6 C5 C3 C1 C2)
C7      (C7 C4 C2 C3 C1)
</pre> 

<p>
Классы в начале CPL(списке предшествования классов) являются более конкретными, 
так что <code>C5</code> и <code>C6</code> являются более конкретными для
<code>C1</code> и <code>C7</code> являются более конкретными для <code>C2</code>. 
Поэтому вызов их обобщенной функции  <code>M1</code> с объектом типа 
<code>C5</code> или <code>C6</code> вызовет метод 1. 
Вызов <code>M1</code> с объектом типа <code>C7</code> вызовет метод 2.

<p>
Следующий вопрос, который вы должны задать: "как CLOS определяет CPL?"Конечно, 
существует алгоритм вычисления CPL - вы можете найти его описание в справочном 
руководстве Lisp. Или вы можете определить некоторые классы и спросить Лисп, чтобы 
он сказал вам их CPL; большинство реализаций включают в себя функцию с именем
<code>CLASS-PRECEDENCE-LIST</code>, которая ожидает объект класса в качестве своего
единственного аргумента (используйте <code>FIND-CLASS</code>, чтобы получить 
объект класса по его названию) и возвращает CPL.

<pre>
? (class-precedence-list (find-class 'c6))
(C6 C5 C3 C1 C2)
</pre> 

<p>Проектируйте консервативно с множественным наследованием, и вам не придется 
зависеть от знания алгоритма, с помощью которого CLOS вычисляет CPL.

<h2>Комбинации методов предлагают дополнительные варианты выбора
</h2>

<p>
Если вы определяете методы, как мы видели в этой главе, то создаваемая 
обобщенная функция будет предлагать возможность, называемую стандартной 
комбинацией методов. Все методы, которые мы до сих пор использовали, были 
первичными методами. В рамках стандартной комбинации методов мы также можем 
определить методы "до"(<em>before</em>), "после"(<em>after</em>) и 
"вокруг"(<em>around</em>), которые объединяются с 
первичным/основным методом.

<p>Чтобы определить метод <em>before</em>, <em>after</em>, или <em>around</em>, 
мы добавляем соответствующее ключевое слово (квалификатор метода) в нашу форму 
<code>DEFMETHOD</code>, например:

<pre>
(defmethod madness :before (...) ...)
(defmethod madness :after  (...) ...)
(defmethod madness :around (...) ...)
</pre> 

<p>Давайте рассмотрим комбинацию стандартных методов в действии. Мы начнем 
с методов <code>:BEFORE</code> и <code>:AFTER</code>.

<pre>
<i>; Define a primary method</i> 
? (defmethod combo1 ((x number)) (print 'primary) 1)
#&lt;STANDARD-METHOD COMBO1 (NUMBER)&gt;
<i>; Define before methods</i> 
? (defmethod combo1 :before ((x integer)) (print 'before-integer) 2)
#&lt;STANDARD-METHOD COMBO1 :BEFORE (INTEGER)&gt;
? (defmethod combo1 :before ((x rational)) (print 'before-rational) 3)
#&lt;STANDARD-METHOD COMBO1 :BEFORE (RATIONAL)&gt;
<i>; Define after methods</i> 
? (defmethod combo1 :after ((x integer)) (print 'after-integer) 4)
#&lt;STANDARD-METHOD COMBO1 :AFTER (INTEGER)&gt;
? (defmethod combo1 :after ((x rational)) (print 'after-rational) 5)
#&lt;STANDARD-METHOD COMBO1 :AFTER (RATIONAL)&gt;
<i>; Try it</i> 
? (combo1 17)

BEFORE-INTEGER
BEFORE-RATIONAL
PRIMARY
AFTER-RATIONAL
AFTER-INTEGER
1
? (combo 4/5)

BEFORE-RATIONAL
PRIMARY
AFTER-RATIONAL
1
</pre> 

<p>Когда мы вызываем <code>COMBO1</code>, CLOS определяет, какие методы 
применимы. Как мы узнали ранее, применим только один основной метод. 
Но, как мы видели в вызове to <code>(COMBO1 17)</code>, у нас может 
быть несколько применимых методов <code>:BEFORE</code> и <code>:AFTER</code>. 
Поскольку integer - это подтип rational, и аргумент для 
<code>COMBO1</code> целочисленный, применимы методы <code>:BEFORE</code> 
и <code>:AFTER</code>, специализирующиеся на целочисленных и рациональных аргументах.

<p>
Так CLOSE определил набор применимых методов: первичный метод и 
некоторые методы до и после него. Стандартная комбинация методов 
определяет порядок, в котором эти методы вызываются. Во-первых, 
 будут вызваны все применимые методы <code>:BEFORE</code>, более
конкретные методы, вызываются первыми. Затем вызывается соответствующий 
первичный метод. Далее вызвываются все применимые методы <code>:AFTER</code>, 
причем более конкретные методы вызываются последними. Наконец, значение 
первичного метода возвращается как значение универсальной функции.


<p>
<code>:BEFORE</code> и <code>:AFTER</code>  методы часто используются 
для добавления дополнительных поведений к методу. Они обычно вводят 
какой-то побочный эффект - выполняя ввод-вывод, изменяя глобальное 
состояние или изменяя слоты одного или нескольких объектов, передаваемых 
в качестве параметров. Существует три действия, недоступные для методов 
<code>:BEFORE</code> и <code>:AFTER</code>

<ol>
<li>Они не могут изменить параметры, видимые другими применимыми методами.
<li>Они не могут изменить, какой из применимых методов фактически вызывается.
<li>Они не могут изменить значение, возвращаемое из обобщенной функции.
</ol> 

<p>Но стандартная комбинация методов предлагает третий вид 
квалифицированного метода, метод <code>:AROUND</code>, который может 
выполнять все эти действия. <code>:AROUND</code> метод определяется 
с помощью квалификатора метода, как и следовало ожидать:

<pre>
(defmethod madness :around (...) ...)
</pre> 

<p>
Если обобщенная функция имеет один или несколько определенных методов 
<code>:AROUND</code>, то сначала вызывается наиболее специлизированный/конкретный
метод <code>:AROUND</code>, даже если есть применимые методы <code>:BEFORE</code>. 
На этом этапе метод <code>:AROUND</code> имеет полный контроль - если он просто 
возвращается, то ни один из других применимых методов не будет вызван. Обычно 
метод <code>:AROUND</code> вызывает метод <code>CALL-NEXT-METHOD</code>, который 
позволяет осуществлять управление с помощью других применимых методов.

<p>
<code>CALL-NEXT-METHOD</code>  вызывает следующий наиболее 
специфичный метод <code>:AROUND</code>; если нет менее специфичных 
применимых методов <code>:AROUND</code>, то <code>CALL-NEXT-METHOD</code> 
вызывает все применимые методы before, primary и after точно так же, 
как описано выше. Значение, возвращаемое наиболее специфичным методом
<code>:AROUND</code>, возвращается обобщенной функцией; обычно вы будете 
использовать значение - или его некоторую модификацию - возвращаемое методом 
<code>CALL-NEXT-METHOD</code>.

<p>Если вы вызываете <code>CALL-NEXT-METHOD</code> без аргументов, 
он использует аргументы текущего метода. Но вы можете вызвать метод 
<code>CALL-NEXT-METHOD</code> с аргументами и изменить параметры, 
видимые вызываемым методом(ами).

<pre>
<i>; Define a primary method</i> 
? (defmethod combo2 ((x number)) (print 'primary) 1)
#&lt;STANDARD-METHOD COMBO2 (NUMBER)&gt;
<i>; Define before methods</i> 
? (defmethod combo2 :before ((x integer)) (print 'before-integer) 2)
#&lt;STANDARD-METHOD COMBO2 :BEFORE (INTEGER)&gt;
? (defmethod combo2 :before ((x rational)) (print 'before-rational) 3)
#&lt;STANDARD-METHOD COMBO2 :BEFORE (RATIONAL)&gt;
<i>; Define after methods</i> 
? (defmethod combo2 :after ((x integer)) (print 'after-integer) 4)
#&lt;STANDARD-METHOD COMBO2 :AFTER (INTEGER)&gt;
? (defmethod combo2 :after ((x rational)) (print 'after-rational) 5)
#&lt;STANDARD-METHOD COMBO2 :AFTER (RATIONAL)&gt;
<i>; Define around methods</i> 
? (defmethod combo2 :around ((x float))
    (print 'around-float-before-call-next-method)
    (let ((result (call-next-method (float (truncate x)))))
      (print 'around-float-after-call-next-method)
      result))
#&lt;STANDARD-METHOD COMBO2 :AROUND (FLOAT)&gt;
? (defmethod combo2 :around ((x complex)) (print 'sorry) nil)
#&lt;STANDARD-METHOD COMBO2 :AROUND (COMPLEX)&gt;
? (defmethod combo2 :around ((x number))
    (print 'around-number-before-call-next-method)
    (print (call-next-method))
    (print 'around-number-after-call-next-method)
    99)
<i>; Try it</i> 
? (combo2 17)

AROUND-NUMBER-BEFORE-CALL-NEXT-METHOD 
BEFORE-INTEGER 
BEFORE-RATIONAL 
PRIMARY 
AFTER-RATIONAL 
AFTER-INTEGER 
1 
AROUND-NUMBER-AFTER-CALL-NEXT-METHOD 
99
? (combo2 4/5)

AROUND-NUMBER-BEFORE-CALL-NEXT-METHOD 
BEFORE-RATIONAL 
PRIMARY 
AFTER-RATIONAL 
1 
AROUND-NUMBER-AFTER-CALL-NEXT-METHOD 
99
? (combo2 82.3)

AROUND-FLOAT-BEFORE-CALL-NEXT-METHOD 
AROUND-NUMBER-BEFORE-CALL-NEXT-METHOD 
PRIMARY 
1 
AROUND-NUMBER-AFTER-CALL-NEXT-METHOD 
AROUND-FLOAT-AFTER-CALL-NEXT-METHOD 
99
? (combo2 #c(1.0 -1.0))

SORRY 
NIL
</pre> 

<p>
Одна вещь, которую вы не можете сделать, - это предоставить аргументы 
для вызова метода <code>CALL-NEXT-METHOD</code, которые изменили бы 
применимые методы. Другими словами, вы должны сохранять тип методов 
даже при изменении их значений. Например, следующее переопределение 
одного из методов примера <code>COMBO2</code> не будет работать:

<pre>
? (defmethod combo2 :around ((x float))
    (call-next-method (floor x))) <i>; FLOOR returns an integer</i> 
#&lt;STANDARD-METHOD COMBO2 :AROUND (FLOAT)&gt;
? (combo2 45.9)
Error: applicable methods changed
</pre> 

<h2>Ничто не выбито на камне; Взгляд на метаобъектный протокол</h2>

<p>
Протокол метаобъектов(metaobject protocol = MOP) - это набор функций, которые
раскрывают большую часть лежащую в основе работы CLOS. Мы уже видели одну 
функцию, которая принадлежит к MOP <code>CLASS-PRECEDENCE-LIST</code>. Некоторые 
функции MOP, такие как <code>CLASS-PRECEDENCE-LIST</code>, дают вам возможность
заглянуть внутрь работы CLOS. Вот несколько примеров:

<pre>
Function                    Argument   Returns
--------                    --------   -------
CLASS-DIRECT-SUBCLASSES     a class    a list of the immediate subclasses
CLASS-DIRECT-SUPERCLASSES   a class    a list of the immediate superclasses
CLASS-DIRECT-SLOTS          a class    a list of non-inherited slots
CLASS-DIRECT-METHODS        a class    a list of non-inherited methods
</pre> 

<p>
Другие функции MOP позволят вам изменить поведение CLOS. Вы можете 
использовать эту возможность для расширения CLOS - возможно, для 
реализации постоянного хранилища объектов - или для изменения поведения, 
чтобы оно более точно соответствовало другому типу объектной системы. 
Подобные изменения выходят далеко за рамки данной книги. Кроме того, 
вы должны знать, что MOP не является (пока, по состоянию на начало 1999 года) 
стандартной частью CLOS, и нет никакого определения MOP, признанного 
каким-либо национальным или международным органом по стандартизации.

<p>
До сих пор определяющим документом для MOP является 
<a href="chapter33.html#kiczales91">The Art of the Metaobject
Protocol</a>. Большинство поставщиков Lisp предоставляют по крайней мере 
частичную реализацию MOP; вероятно, вам следует начать с документации поставщика, 
если вы заинтересованы в MOP.

<hr>
<div align="center">
<a href="contents.html">Contents</a> | <a href="cover.html">Cover</a> <br> 
<a href="chapter13.html">Chapter 13</a> | Chapter 14 | <a href="chapter15.html">Chapter 15</a> 
</div>
<hr>
<address>
Copyright &copy; 1995-2001, David B. Lamkins<br>
All Rights Reserved Worldwide<br>
<br>
This book may not be reproduced without the written consent of its author.  Online distribution is restricted to the author's site.
</address> 
</body> </html>